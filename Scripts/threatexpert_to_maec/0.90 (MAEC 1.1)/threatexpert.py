#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Thu Sep 23 15:44:59 2010 by generateDS.py version 2.2a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_str_lower(self, instring):
            return instring.lower()
                    
                    

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf_8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class known_threat_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None):
        self.name = name
        self.description = description
    def factory(*args_, **kwargs_):
        if known_threat_type.subclass:
            return known_threat_type.subclass(*args_, **kwargs_)
        else:
            return known_threat_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_name(self, value):
        # validate type name
        pass
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # validate type description
        pass
    def export(self, outfile, level, namespace_='', name_='known_threat_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='known_threat_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='known_threat_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='known_threat_type'):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='known_threat_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'name':
            name_ = child_.text
            self.name = name_
            self.validate_name(self.name)    # validate type name
        elif nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
            self.validate_description(self.description)    # validate type description
# end class known_threat_type


class known_threat_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, known_threat=None):
        if known_threat is None:
            self.known_threat = []
        else:
            self.known_threat = known_threat
    def factory(*args_, **kwargs_):
        if known_threat_collection_type.subclass:
            return known_threat_collection_type.subclass(*args_, **kwargs_)
        else:
            return known_threat_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_known_threat(self): return self.known_threat
    def set_known_threat(self, known_threat): self.known_threat = known_threat
    def add_known_threat(self, value): self.known_threat.append(value)
    def insert_known_threat(self, index, value): self.known_threat[index] = value
    def export(self, outfile, level, namespace_='', name_='known_threat_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='known_threat_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='known_threat_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='known_threat_collection_type'):
        for known_threat_ in self.known_threat:
            known_threat_.export(outfile, level, namespace_, name_='known_threat')
    def hasContent_(self):
        if (
            self.known_threat
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='known_threat_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('known_threat=[\n')
        level += 1
        for known_threat_ in self.known_threat:
            showIndent(outfile, level)
            outfile.write('model_.known_threat_type(\n')
            known_threat_.exportLiteral(outfile, level, name_='known_threat_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'known_threat': 
            obj_ = known_threat_type.factory()
            obj_.build(child_)
            self.known_threat.append(obj_)
# end class known_threat_collection_type


class known_threat_category_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, known_threat_category=None):
        if known_threat_category is None:
            self.known_threat_category = []
        else:
            self.known_threat_category = known_threat_category
    def factory(*args_, **kwargs_):
        if known_threat_category_collection_type.subclass:
            return known_threat_category_collection_type.subclass(*args_, **kwargs_)
        else:
            return known_threat_category_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_known_threat_category(self): return self.known_threat_category
    def set_known_threat_category(self, known_threat_category): self.known_threat_category = known_threat_category
    def add_known_threat_category(self, value): self.known_threat_category.append(value)
    def insert_known_threat_category(self, index, value): self.known_threat_category[index] = value
    def export(self, outfile, level, namespace_='', name_='known_threat_category_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='known_threat_category_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='known_threat_category_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='known_threat_category_collection_type'):
        for known_threat_category_ in self.known_threat_category:
            known_threat_category_.export(outfile, level, namespace_, name_='known_threat_category')
    def hasContent_(self):
        if (
            self.known_threat_category
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='known_threat_category_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('known_threat_category=[\n')
        level += 1
        for known_threat_category_ in self.known_threat_category:
            showIndent(outfile, level)
            outfile.write('model_.known_threat_type(\n')
            known_threat_category_.exportLiteral(outfile, level, name_='known_threat_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'known_threat_category': 
            obj_ = known_threat_type.factory()
            obj_.build(child_)
            self.known_threat_category.append(obj_)
# end class known_threat_category_collection_type


class filenames_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, filename=None):
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
    def factory(*args_, **kwargs_):
        if filenames_collection_type.subclass:
            return filenames_collection_type.subclass(*args_, **kwargs_)
        else:
            return filenames_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def validate_filename(self, value):
        # validate type filename
        pass
    def export(self, outfile, level, namespace_='', name_='filenames_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='filenames_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='filenames_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='filenames_collection_type'):
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_))
    def hasContent_(self):
        if (
            self.filename
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='filenames_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'filename':
            filename_ = child_.text
            self.filename.append(filename_)
            self.validate_filename(self.filename)    # validate type filename
# end class filenames_collection_type


class added_file_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, filenames_collection=None, md5=None, sha1=None, filesize=None, alias_kav=None, alias_nav=None, alias_nai=None, alias_trend=None, alias_sophos=None, alias_microsoft=None, alias_ikarus=None, alias_ahnlab=None, packer=None):
        self.filenames_collection = filenames_collection
        self.md5 = md5
        self.sha1 = sha1
        self.filesize = filesize
        self.alias_kav = alias_kav
        self.alias_nav = alias_nav
        self.alias_nai = alias_nai
        self.alias_trend = alias_trend
        self.alias_sophos = alias_sophos
        self.alias_microsoft = alias_microsoft
        self.alias_ikarus = alias_ikarus
        self.alias_ahnlab = alias_ahnlab
        self.packer = packer
    def factory(*args_, **kwargs_):
        if added_file_type.subclass:
            return added_file_type.subclass(*args_, **kwargs_)
        else:
            return added_file_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filenames_collection(self): return self.filenames_collection
    def set_filenames_collection(self, filenames_collection): self.filenames_collection = filenames_collection
    def get_md5(self): return self.md5
    def set_md5(self, md5): self.md5 = md5
    def validate_md5(self, value):
        # validate type md5
        pass
    def get_sha1(self): return self.sha1
    def set_sha1(self, sha1): self.sha1 = sha1
    def validate_sha1(self, value):
        # validate type sha1
        pass
    def get_filesize(self): return self.filesize
    def set_filesize(self, filesize): self.filesize = filesize
    def validate_filesize(self, value):
        # validate type filesize
        pass
    def get_alias_kav(self): return self.alias_kav
    def set_alias_kav(self, alias_kav): self.alias_kav = alias_kav
    def validate_alias_kav(self, value):
        # validate type alias_kav
        pass
    def get_alias_nav(self): return self.alias_nav
    def set_alias_nav(self, alias_nav): self.alias_nav = alias_nav
    def validate_alias_nav(self, value):
        # validate type alias_nav
        pass
    def get_alias_nai(self): return self.alias_nai
    def set_alias_nai(self, alias_nai): self.alias_nai = alias_nai
    def validate_alias_nai(self, value):
        # validate type alias_nai
        pass
    def get_alias_trend(self): return self.alias_trend
    def set_alias_trend(self, alias_trend): self.alias_trend = alias_trend
    def validate_alias_trend(self, value):
        # validate type alias_trend
        pass
    def get_alias_sophos(self): return self.alias_sophos
    def set_alias_sophos(self, alias_sophos): self.alias_sophos = alias_sophos
    def validate_alias_sophos(self, value):
        # validate type alias_sophos
        pass
    def get_alias_microsoft(self): return self.alias_microsoft
    def set_alias_microsoft(self, alias_microsoft): self.alias_microsoft = alias_microsoft
    def validate_alias_microsoft(self, value):
        # validate type alias_microsoft
        pass
    def get_alias_ikarus(self): return self.alias_ikarus
    def set_alias_ikarus(self, alias_ikarus): self.alias_ikarus = alias_ikarus
    def validate_alias_ikarus(self, value):
        # validate type alias_ikarus
        pass
    def get_alias_ahnlab(self): return self.alias_ahnlab
    def set_alias_ahnlab(self, alias_ahnlab): self.alias_ahnlab = alias_ahnlab
    def validate_alias_ahnlab(self, value):
        # validate type alias_ahnlab
        pass
    def get_packer(self): return self.packer
    def set_packer(self, packer): self.packer = packer
    def validate_packer(self, value):
        # validate type packer
        pass
    def export(self, outfile, level, namespace_='', name_='added_file_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_file_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_file_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_file_type'):
        if self.filenames_collection:
            self.filenames_collection.export(outfile, level, namespace_, name_='filenames_collection', )
        if self.md5 is not None:
            showIndent(outfile, level)
            outfile.write('<%smd5>%s</%smd5>\n' % (namespace_, self.gds_format_string(quote_xml(self.md5).encode(ExternalEncoding), input_name='md5'), namespace_))
        if self.sha1 is not None:
            showIndent(outfile, level)
            outfile.write('<%ssha1>%s</%ssha1>\n' % (namespace_, self.gds_format_string(quote_xml(self.sha1).encode(ExternalEncoding), input_name='sha1'), namespace_))
        if self.filesize is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilesize>%s</%sfilesize>\n' % (namespace_, self.gds_format_string(quote_xml(self.filesize).encode(ExternalEncoding), input_name='filesize'), namespace_))
        if self.alias_kav is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_kav>%s</%salias_kav>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_kav).encode(ExternalEncoding), input_name='alias_kav'), namespace_))
        if self.alias_nav is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_nav>%s</%salias_nav>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_nav).encode(ExternalEncoding), input_name='alias_nav'), namespace_))
        if self.alias_nai is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_nai>%s</%salias_nai>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_nai).encode(ExternalEncoding), input_name='alias_nai'), namespace_))
        if self.alias_trend is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_trend>%s</%salias_trend>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_trend).encode(ExternalEncoding), input_name='alias_trend'), namespace_))
        if self.alias_sophos is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_sophos>%s</%salias_sophos>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_sophos).encode(ExternalEncoding), input_name='alias_sophos'), namespace_))
        if self.alias_microsoft is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_microsoft>%s</%salias_microsoft>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_microsoft).encode(ExternalEncoding), input_name='alias_microsoft'), namespace_))
        if self.alias_ikarus is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_ikarus>%s</%salias_ikarus>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_ikarus).encode(ExternalEncoding), input_name='alias_ikarus'), namespace_))
        if self.alias_ahnlab is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_ahnlab>%s</%salias_ahnlab>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_ahnlab).encode(ExternalEncoding), input_name='alias_ahnlab'), namespace_))
        if self.packer is not None:
            showIndent(outfile, level)
            outfile.write('<%spacker>%s</%spacker>\n' % (namespace_, self.gds_format_string(quote_xml(self.packer).encode(ExternalEncoding), input_name='packer'), namespace_))
    def hasContent_(self):
        if (
            self.filenames_collection is not None or
            self.md5 is not None or
            self.sha1 is not None or
            self.filesize is not None or
            self.alias_kav is not None or
            self.alias_nav is not None or
            self.alias_nai is not None or
            self.alias_trend is not None or
            self.alias_sophos is not None or
            self.alias_microsoft is not None or
            self.alias_ikarus is not None or
            self.alias_ahnlab is not None or
            self.packer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_file_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.filenames_collection is not None:
            showIndent(outfile, level)
            outfile.write('filenames_collection=model_.filenames_collection_type(\n')
            self.filenames_collection.exportLiteral(outfile, level, name_='filenames_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.md5 is not None:
            showIndent(outfile, level)
            outfile.write('md5=%s,\n' % quote_python(self.md5).encode(ExternalEncoding))
        if self.sha1 is not None:
            showIndent(outfile, level)
            outfile.write('sha1=%s,\n' % quote_python(self.sha1).encode(ExternalEncoding))
        if self.filesize is not None:
            showIndent(outfile, level)
            outfile.write('filesize=%s,\n' % quote_python(self.filesize).encode(ExternalEncoding))
        if self.alias_kav is not None:
            showIndent(outfile, level)
            outfile.write('alias_kav=%s,\n' % quote_python(self.alias_kav).encode(ExternalEncoding))
        if self.alias_nav is not None:
            showIndent(outfile, level)
            outfile.write('alias_nav=%s,\n' % quote_python(self.alias_nav).encode(ExternalEncoding))
        if self.alias_nai is not None:
            showIndent(outfile, level)
            outfile.write('alias_nai=%s,\n' % quote_python(self.alias_nai).encode(ExternalEncoding))
        if self.alias_trend is not None:
            showIndent(outfile, level)
            outfile.write('alias_trend=%s,\n' % quote_python(self.alias_trend).encode(ExternalEncoding))
        if self.alias_sophos is not None:
            showIndent(outfile, level)
            outfile.write('alias_sophos=%s,\n' % quote_python(self.alias_sophos).encode(ExternalEncoding))
        if self.alias_microsoft is not None:
            showIndent(outfile, level)
            outfile.write('alias_microsoft=%s,\n' % quote_python(self.alias_microsoft).encode(ExternalEncoding))
        if self.alias_ikarus is not None:
            showIndent(outfile, level)
            outfile.write('alias_ikarus=%s,\n' % quote_python(self.alias_ikarus).encode(ExternalEncoding))
        if self.alias_ahnlab is not None:
            showIndent(outfile, level)
            outfile.write('alias_ahnlab=%s,\n' % quote_python(self.alias_ahnlab).encode(ExternalEncoding))
        if self.packer is not None:
            showIndent(outfile, level)
            outfile.write('packer=%s,\n' % quote_python(self.packer).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'filenames_collection': 
            obj_ = filenames_collection_type.factory()
            obj_.build(child_)
            self.set_filenames_collection(obj_)
        elif nodeName_ == 'md5':
            md5_ = child_.text
            self.md5 = md5_
            self.validate_md5(self.md5)    # validate type md5
        elif nodeName_ == 'sha1':
            sha1_ = child_.text
            self.sha1 = sha1_
            self.validate_sha1(self.sha1)    # validate type sha1
        elif nodeName_ == 'filesize':
            filesize_ = child_.text
            self.filesize = filesize_
            self.validate_filesize(self.filesize)    # validate type filesize
        elif nodeName_ == 'alias_kav':
            alias_kav_ = child_.text
            self.alias_kav = alias_kav_
            self.validate_alias_kav(self.alias_kav)    # validate type alias_kav
        elif nodeName_ == 'alias_nav':
            alias_nav_ = child_.text
            self.alias_nav = alias_nav_
            self.validate_alias_nav(self.alias_nav)    # validate type alias_nav
        elif nodeName_ == 'alias_nai':
            alias_nai_ = child_.text
            self.alias_nai = alias_nai_
            self.validate_alias_nai(self.alias_nai)    # validate type alias_nai
        elif nodeName_ == 'alias_trend':
            alias_trend_ = child_.text
            self.alias_trend = alias_trend_
            self.validate_alias_trend(self.alias_trend)    # validate type alias_trend
        elif nodeName_ == 'alias_sophos':
            alias_sophos_ = child_.text
            self.alias_sophos = alias_sophos_
            self.validate_alias_sophos(self.alias_sophos)    # validate type alias_sophos
        elif nodeName_ == 'alias_microsoft':
            alias_microsoft_ = child_.text
            self.alias_microsoft = alias_microsoft_
            self.validate_alias_microsoft(self.alias_microsoft)    # validate type alias_microsoft
        elif nodeName_ == 'alias_ikarus':
            alias_ikarus_ = child_.text
            self.alias_ikarus = alias_ikarus_
            self.validate_alias_ikarus(self.alias_ikarus)    # validate type alias_ikarus
        elif nodeName_ == 'alias_ahnlab':
            alias_ahnlab_ = child_.text
            self.alias_ahnlab = alias_ahnlab_
            self.validate_alias_ahnlab(self.alias_ahnlab)    # validate type alias_ahnlab
        elif nodeName_ == 'packer':
            packer_ = child_.text
            self.packer = packer_
            self.validate_packer(self.packer)    # validate type packer
# end class added_file_type


class added_files_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_file=None):
        if added_file is None:
            self.added_file = []
        else:
            self.added_file = added_file
    def factory(*args_, **kwargs_):
        if added_files_collection_type.subclass:
            return added_files_collection_type.subclass(*args_, **kwargs_)
        else:
            return added_files_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_file(self): return self.added_file
    def set_added_file(self, added_file): self.added_file = added_file
    def add_added_file(self, value): self.added_file.append(value)
    def insert_added_file(self, index, value): self.added_file[index] = value
    def export(self, outfile, level, namespace_='', name_='added_files_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_files_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_files_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_files_collection_type'):
        for added_file_ in self.added_file:
            added_file_.export(outfile, level, namespace_, name_='added_file')
    def hasContent_(self):
        if (
            self.added_file
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_files_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('added_file=[\n')
        level += 1
        for added_file_ in self.added_file:
            showIndent(outfile, level)
            outfile.write('model_.added_file_type(\n')
            added_file_.exportLiteral(outfile, level, name_='added_file_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_file': 
            obj_ = added_file_type.factory()
            obj_.build(child_)
            self.added_file.append(obj_)
# end class added_files_collection_type


class notes_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, note=None):
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if notes_collection_type.subclass:
            return notes_collection_type.subclass(*args_, **kwargs_)
        else:
            return notes_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def validate_note(self, value):
        # validate type note
        pass
    def export(self, outfile, level, namespace_='', name_='notes_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='notes_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='notes_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='notes_collection_type'):
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('<%snote>%s</%snote>\n' % (namespace_, self.gds_format_string(quote_xml(note_).encode(ExternalEncoding), input_name='note'), namespace_))
    def hasContent_(self):
        if (
            self.note
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='notes_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(note_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'note':
            note_ = child_.text
            self.note.append(note_)
            self.validate_note(self.note)    # validate type note
# end class notes_collection_type


class added_files_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_files_collection=None, notes_collection=None):
        self.added_files_collection = added_files_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if added_files_type.subclass:
            return added_files_type.subclass(*args_, **kwargs_)
        else:
            return added_files_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_files_collection(self): return self.added_files_collection
    def set_added_files_collection(self, added_files_collection): self.added_files_collection = added_files_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='added_files_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_files_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_files_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_files_type'):
        if self.added_files_collection:
            self.added_files_collection.export(outfile, level, namespace_, name_='added_files_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.added_files_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_files_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.added_files_collection is not None:
            showIndent(outfile, level)
            outfile.write('added_files_collection=model_.added_files_collection_type(\n')
            self.added_files_collection.exportLiteral(outfile, level, name_='added_files_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_files_collection': 
            obj_ = added_files_collection_type.factory()
            obj_.build(child_)
            self.set_added_files_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class added_files_type


class filenames_notes_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, filenames_collection=None, notes_collection=None):
        self.filenames_collection = filenames_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if filenames_notes_type.subclass:
            return filenames_notes_type.subclass(*args_, **kwargs_)
        else:
            return filenames_notes_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filenames_collection(self): return self.filenames_collection
    def set_filenames_collection(self, filenames_collection): self.filenames_collection = filenames_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='filenames_notes_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='filenames_notes_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='filenames_notes_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='filenames_notes_type'):
        if self.filenames_collection:
            self.filenames_collection.export(outfile, level, namespace_, name_='filenames_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.filenames_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='filenames_notes_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.filenames_collection is not None:
            showIndent(outfile, level)
            outfile.write('filenames_collection=model_.filenames_collection_type(\n')
            self.filenames_collection.exportLiteral(outfile, level, name_='filenames_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'filenames_collection': 
            obj_ = filenames_collection_type.factory()
            obj_.build(child_)
            self.set_filenames_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class filenames_notes_type


class dirnames_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dirname=None):
        if dirname is None:
            self.dirname = []
        else:
            self.dirname = dirname
    def factory(*args_, **kwargs_):
        if dirnames_collection_type.subclass:
            return dirnames_collection_type.subclass(*args_, **kwargs_)
        else:
            return dirnames_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dirname(self): return self.dirname
    def set_dirname(self, dirname): self.dirname = dirname
    def add_dirname(self, value): self.dirname.append(value)
    def insert_dirname(self, index, value): self.dirname[index] = value
    def validate_dirname(self, value):
        # validate type dirname
        pass
    def export(self, outfile, level, namespace_='', name_='dirnames_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dirnames_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='dirnames_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dirnames_collection_type'):
        for dirname_ in self.dirname:
            showIndent(outfile, level)
            outfile.write('<%sdirname>%s</%sdirname>\n' % (namespace_, self.gds_format_string(quote_xml(dirname_).encode(ExternalEncoding), input_name='dirname'), namespace_))
    def hasContent_(self):
        if (
            self.dirname
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dirnames_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('dirname=[\n')
        level += 1
        for dirname_ in self.dirname:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(dirname_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'dirname':
            dirname_ = child_.text
            self.dirname.append(dirname_)
            self.validate_dirname(self.dirname)    # validate type dirname
# end class dirnames_collection_type


class dirnames_notes_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dirnames_collection=None, notes_collection=None):
        self.dirnames_collection = dirnames_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if dirnames_notes_type.subclass:
            return dirnames_notes_type.subclass(*args_, **kwargs_)
        else:
            return dirnames_notes_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dirnames_collection(self): return self.dirnames_collection
    def set_dirnames_collection(self, dirnames_collection): self.dirnames_collection = dirnames_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='dirnames_notes_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dirnames_notes_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='dirnames_notes_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dirnames_notes_type'):
        if self.dirnames_collection:
            self.dirnames_collection.export(outfile, level, namespace_, name_='dirnames_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.dirnames_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dirnames_notes_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dirnames_collection is not None:
            showIndent(outfile, level)
            outfile.write('dirnames_collection=model_.dirnames_collection_type(\n')
            self.dirnames_collection.exportLiteral(outfile, level, name_='dirnames_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'dirnames_collection': 
            obj_ = dirnames_collection_type.factory()
            obj_.build(child_)
            self.set_dirnames_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class dirnames_notes_type


class added_process_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, process_name=None, process_filename=None, main_module_size=None, attached_zip_dump=None):
        self.process_name = process_name
        self.process_filename = process_filename
        self.main_module_size = main_module_size
        self.attached_zip_dump = attached_zip_dump
    def factory(*args_, **kwargs_):
        if added_process_type.subclass:
            return added_process_type.subclass(*args_, **kwargs_)
        else:
            return added_process_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_process_name(self): return self.process_name
    def set_process_name(self, process_name): self.process_name = process_name
    def validate_process_name(self, value):
        # validate type process_name
        pass
    def get_process_filename(self): return self.process_filename
    def set_process_filename(self, process_filename): self.process_filename = process_filename
    def validate_process_filename(self, value):
        # validate type process_filename
        pass
    def get_main_module_size(self): return self.main_module_size
    def set_main_module_size(self, main_module_size): self.main_module_size = main_module_size
    def validate_main_module_size(self, value):
        # validate type main_module_size
        pass
    def get_attached_zip_dump(self): return self.attached_zip_dump
    def set_attached_zip_dump(self, attached_zip_dump): self.attached_zip_dump = attached_zip_dump
    def validate_attached_zip_dump(self, value):
        # validate type attached_zip_dump
        pass
    def export(self, outfile, level, namespace_='', name_='added_process_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_process_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_process_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_process_type'):
        if self.process_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocess_name>%s</%sprocess_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.process_name).encode(ExternalEncoding), input_name='process_name'), namespace_))
        if self.process_filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocess_filename>%s</%sprocess_filename>\n' % (namespace_, self.gds_format_string(quote_xml(self.process_filename).encode(ExternalEncoding), input_name='process_filename'), namespace_))
        if self.main_module_size is not None:
            showIndent(outfile, level)
            outfile.write('<%smain_module_size>%s</%smain_module_size>\n' % (namespace_, self.gds_format_string(quote_xml(self.main_module_size).encode(ExternalEncoding), input_name='main_module_size'), namespace_))
        if self.attached_zip_dump is not None:
            showIndent(outfile, level)
            outfile.write('<%sattached_zip_dump>%s</%sattached_zip_dump>\n' % (namespace_, self.gds_format_string(quote_xml(self.attached_zip_dump).encode(ExternalEncoding), input_name='attached_zip_dump'), namespace_))
    def hasContent_(self):
        if (
            self.process_name is not None or
            self.process_filename is not None or
            self.main_module_size is not None or
            self.attached_zip_dump is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_process_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.process_name is not None:
            showIndent(outfile, level)
            outfile.write('process_name=%s,\n' % quote_python(self.process_name).encode(ExternalEncoding))
        if self.process_filename is not None:
            showIndent(outfile, level)
            outfile.write('process_filename=%s,\n' % quote_python(self.process_filename).encode(ExternalEncoding))
        if self.main_module_size is not None:
            showIndent(outfile, level)
            outfile.write('main_module_size=%s,\n' % quote_python(self.main_module_size).encode(ExternalEncoding))
        if self.attached_zip_dump is not None:
            showIndent(outfile, level)
            outfile.write('attached_zip_dump=%s,\n' % quote_python(self.attached_zip_dump).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'process_name':
            process_name_ = child_.text
            self.process_name = process_name_
            self.validate_process_name(self.process_name)    # validate type process_name
        elif nodeName_ == 'process_filename':
            process_filename_ = child_.text
            self.process_filename = process_filename_
            self.validate_process_filename(self.process_filename)    # validate type process_filename
        elif nodeName_ == 'main_module_size':
            main_module_size_ = child_.text
            self.main_module_size = main_module_size_
            self.validate_main_module_size(self.main_module_size)    # validate type main_module_size
        elif nodeName_ == 'attached_zip_dump':
            attached_zip_dump_ = child_.text
            self.attached_zip_dump = attached_zip_dump_
            self.validate_attached_zip_dump(self.attached_zip_dump)    # validate type attached_zip_dump
# end class added_process_type


class added_processes_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_process=None):
        if added_process is None:
            self.added_process = []
        else:
            self.added_process = added_process
    def factory(*args_, **kwargs_):
        if added_processes_collection_type.subclass:
            return added_processes_collection_type.subclass(*args_, **kwargs_)
        else:
            return added_processes_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_process(self): return self.added_process
    def set_added_process(self, added_process): self.added_process = added_process
    def add_added_process(self, value): self.added_process.append(value)
    def insert_added_process(self, index, value): self.added_process[index] = value
    def export(self, outfile, level, namespace_='', name_='added_processes_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_processes_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_processes_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_processes_collection_type'):
        for added_process_ in self.added_process:
            added_process_.export(outfile, level, namespace_, name_='added_process')
    def hasContent_(self):
        if (
            self.added_process
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_processes_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('added_process=[\n')
        level += 1
        for added_process_ in self.added_process:
            showIndent(outfile, level)
            outfile.write('model_.added_process_type(\n')
            added_process_.exportLiteral(outfile, level, name_='added_process_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_process': 
            obj_ = added_process_type.factory()
            obj_.build(child_)
            self.added_process.append(obj_)
# end class added_processes_collection_type


class added_processes_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_processes_collection=None, notes_collection=None):
        self.added_processes_collection = added_processes_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if added_processes_type.subclass:
            return added_processes_type.subclass(*args_, **kwargs_)
        else:
            return added_processes_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_processes_collection(self): return self.added_processes_collection
    def set_added_processes_collection(self, added_processes_collection): self.added_processes_collection = added_processes_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='added_processes_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_processes_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_processes_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_processes_type'):
        if self.added_processes_collection:
            self.added_processes_collection.export(outfile, level, namespace_, name_='added_processes_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.added_processes_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_processes_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.added_processes_collection is not None:
            showIndent(outfile, level)
            outfile.write('added_processes_collection=model_.added_processes_collection_type(\n')
            self.added_processes_collection.exportLiteral(outfile, level, name_='added_processes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_processes_collection': 
            obj_ = added_processes_collection_type.factory()
            obj_.build(child_)
            self.set_added_processes_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class added_processes_type


class added_hidden_process_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, process_name=None, main_module_size=None, attached_zip_dump=None):
        self.process_name = process_name
        self.main_module_size = main_module_size
        self.attached_zip_dump = attached_zip_dump
    def factory(*args_, **kwargs_):
        if added_hidden_process_type.subclass:
            return added_hidden_process_type.subclass(*args_, **kwargs_)
        else:
            return added_hidden_process_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_process_name(self): return self.process_name
    def set_process_name(self, process_name): self.process_name = process_name
    def validate_process_name(self, value):
        # validate type process_name
        pass
    def get_main_module_size(self): return self.main_module_size
    def set_main_module_size(self, main_module_size): self.main_module_size = main_module_size
    def validate_main_module_size(self, value):
        # validate type main_module_size
        pass
    def get_attached_zip_dump(self): return self.attached_zip_dump
    def set_attached_zip_dump(self, attached_zip_dump): self.attached_zip_dump = attached_zip_dump
    def validate_attached_zip_dump(self, value):
        # validate type attached_zip_dump
        pass
    def export(self, outfile, level, namespace_='', name_='added_hidden_process_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_hidden_process_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_hidden_process_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_hidden_process_type'):
        if self.process_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocess_name>%s</%sprocess_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.process_name).encode(ExternalEncoding), input_name='process_name'), namespace_))
        if self.main_module_size is not None:
            showIndent(outfile, level)
            outfile.write('<%smain_module_size>%s</%smain_module_size>\n' % (namespace_, self.gds_format_string(quote_xml(self.main_module_size).encode(ExternalEncoding), input_name='main_module_size'), namespace_))
        if self.attached_zip_dump is not None:
            showIndent(outfile, level)
            outfile.write('<%sattached_zip_dump>%s</%sattached_zip_dump>\n' % (namespace_, self.gds_format_string(quote_xml(self.attached_zip_dump).encode(ExternalEncoding), input_name='attached_zip_dump'), namespace_))
    def hasContent_(self):
        if (
            self.process_name is not None or
            self.main_module_size is not None or
            self.attached_zip_dump is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_hidden_process_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.process_name is not None:
            showIndent(outfile, level)
            outfile.write('process_name=%s,\n' % quote_python(self.process_name).encode(ExternalEncoding))
        if self.main_module_size is not None:
            showIndent(outfile, level)
            outfile.write('main_module_size=%s,\n' % quote_python(self.main_module_size).encode(ExternalEncoding))
        if self.attached_zip_dump is not None:
            showIndent(outfile, level)
            outfile.write('attached_zip_dump=%s,\n' % quote_python(self.attached_zip_dump).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'process_name':
            process_name_ = child_.text
            self.process_name = process_name_
            self.validate_process_name(self.process_name)    # validate type process_name
        elif nodeName_ == 'main_module_size':
            main_module_size_ = child_.text
            self.main_module_size = main_module_size_
            self.validate_main_module_size(self.main_module_size)    # validate type main_module_size
        elif nodeName_ == 'attached_zip_dump':
            attached_zip_dump_ = child_.text
            self.attached_zip_dump = attached_zip_dump_
            self.validate_attached_zip_dump(self.attached_zip_dump)    # validate type attached_zip_dump
# end class added_hidden_process_type


class added_hidden_processes_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_hidden_process=None):
        if added_hidden_process is None:
            self.added_hidden_process = []
        else:
            self.added_hidden_process = added_hidden_process
    def factory(*args_, **kwargs_):
        if added_hidden_processes_collection_type.subclass:
            return added_hidden_processes_collection_type.subclass(*args_, **kwargs_)
        else:
            return added_hidden_processes_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_hidden_process(self): return self.added_hidden_process
    def set_added_hidden_process(self, added_hidden_process): self.added_hidden_process = added_hidden_process
    def add_added_hidden_process(self, value): self.added_hidden_process.append(value)
    def insert_added_hidden_process(self, index, value): self.added_hidden_process[index] = value
    def export(self, outfile, level, namespace_='', name_='added_hidden_processes_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_hidden_processes_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_hidden_processes_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_hidden_processes_collection_type'):
        for added_hidden_process_ in self.added_hidden_process:
            added_hidden_process_.export(outfile, level, namespace_, name_='added_hidden_process')
    def hasContent_(self):
        if (
            self.added_hidden_process
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_hidden_processes_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('added_hidden_process=[\n')
        level += 1
        for added_hidden_process_ in self.added_hidden_process:
            showIndent(outfile, level)
            outfile.write('model_.added_hidden_process_type(\n')
            added_hidden_process_.exportLiteral(outfile, level, name_='added_hidden_process_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_hidden_process': 
            obj_ = added_hidden_process_type.factory()
            obj_.build(child_)
            self.added_hidden_process.append(obj_)
# end class added_hidden_processes_collection_type


class added_hidden_processes_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_hidden_processes_collection=None, notes_collection=None):
        self.added_hidden_processes_collection = added_hidden_processes_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if added_hidden_processes_type.subclass:
            return added_hidden_processes_type.subclass(*args_, **kwargs_)
        else:
            return added_hidden_processes_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_hidden_processes_collection(self): return self.added_hidden_processes_collection
    def set_added_hidden_processes_collection(self, added_hidden_processes_collection): self.added_hidden_processes_collection = added_hidden_processes_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='added_hidden_processes_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_hidden_processes_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_hidden_processes_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_hidden_processes_type'):
        if self.added_hidden_processes_collection:
            self.added_hidden_processes_collection.export(outfile, level, namespace_, name_='added_hidden_processes_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.added_hidden_processes_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_hidden_processes_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.added_hidden_processes_collection is not None:
            showIndent(outfile, level)
            outfile.write('added_hidden_processes_collection=model_.added_hidden_processes_collection_type(\n')
            self.added_hidden_processes_collection.exportLiteral(outfile, level, name_='added_hidden_processes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_hidden_processes_collection': 
            obj_ = added_hidden_processes_collection_type.factory()
            obj_.build(child_)
            self.set_added_hidden_processes_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class added_hidden_processes_type


class injected_mempage_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, process_name=None, process_filename=None, allocated_size=None, attached_zip_dump=None):
        self.process_name = process_name
        self.process_filename = process_filename
        self.allocated_size = allocated_size
        self.attached_zip_dump = attached_zip_dump
    def factory(*args_, **kwargs_):
        if injected_mempage_type.subclass:
            return injected_mempage_type.subclass(*args_, **kwargs_)
        else:
            return injected_mempage_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_process_name(self): return self.process_name
    def set_process_name(self, process_name): self.process_name = process_name
    def validate_process_name(self, value):
        # validate type process_name
        pass
    def get_process_filename(self): return self.process_filename
    def set_process_filename(self, process_filename): self.process_filename = process_filename
    def validate_process_filename(self, value):
        # validate type process_filename
        pass
    def get_allocated_size(self): return self.allocated_size
    def set_allocated_size(self, allocated_size): self.allocated_size = allocated_size
    def validate_allocated_size(self, value):
        # validate type allocated_size
        pass
    def get_attached_zip_dump(self): return self.attached_zip_dump
    def set_attached_zip_dump(self, attached_zip_dump): self.attached_zip_dump = attached_zip_dump
    def validate_attached_zip_dump(self, value):
        # validate type attached_zip_dump
        pass
    def export(self, outfile, level, namespace_='', name_='injected_mempage_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='injected_mempage_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='injected_mempage_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='injected_mempage_type'):
        if self.process_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocess_name>%s</%sprocess_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.process_name).encode(ExternalEncoding), input_name='process_name'), namespace_))
        if self.process_filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocess_filename>%s</%sprocess_filename>\n' % (namespace_, self.gds_format_string(quote_xml(self.process_filename).encode(ExternalEncoding), input_name='process_filename'), namespace_))
        if self.allocated_size is not None:
            showIndent(outfile, level)
            outfile.write('<%sallocated_size>%s</%sallocated_size>\n' % (namespace_, self.gds_format_string(quote_xml(self.allocated_size).encode(ExternalEncoding), input_name='allocated_size'), namespace_))
        if self.attached_zip_dump is not None:
            showIndent(outfile, level)
            outfile.write('<%sattached_zip_dump>%s</%sattached_zip_dump>\n' % (namespace_, self.gds_format_string(quote_xml(self.attached_zip_dump).encode(ExternalEncoding), input_name='attached_zip_dump'), namespace_))
    def hasContent_(self):
        if (
            self.process_name is not None or
            self.process_filename is not None or
            self.allocated_size is not None or
            self.attached_zip_dump is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='injected_mempage_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.process_name is not None:
            showIndent(outfile, level)
            outfile.write('process_name=%s,\n' % quote_python(self.process_name).encode(ExternalEncoding))
        if self.process_filename is not None:
            showIndent(outfile, level)
            outfile.write('process_filename=%s,\n' % quote_python(self.process_filename).encode(ExternalEncoding))
        if self.allocated_size is not None:
            showIndent(outfile, level)
            outfile.write('allocated_size=%s,\n' % quote_python(self.allocated_size).encode(ExternalEncoding))
        if self.attached_zip_dump is not None:
            showIndent(outfile, level)
            outfile.write('attached_zip_dump=%s,\n' % quote_python(self.attached_zip_dump).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'process_name':
            process_name_ = child_.text
            self.process_name = process_name_
            self.validate_process_name(self.process_name)    # validate type process_name
        elif nodeName_ == 'process_filename':
            process_filename_ = child_.text
            self.process_filename = process_filename_
            self.validate_process_filename(self.process_filename)    # validate type process_filename
        elif nodeName_ == 'allocated_size':
            allocated_size_ = child_.text
            self.allocated_size = allocated_size_
            self.validate_allocated_size(self.allocated_size)    # validate type allocated_size
        elif nodeName_ == 'attached_zip_dump':
            attached_zip_dump_ = child_.text
            self.attached_zip_dump = attached_zip_dump_
            self.validate_attached_zip_dump(self.attached_zip_dump)    # validate type attached_zip_dump
# end class injected_mempage_type


class injected_mempages_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, injected_mempage=None):
        if injected_mempage is None:
            self.injected_mempage = []
        else:
            self.injected_mempage = injected_mempage
    def factory(*args_, **kwargs_):
        if injected_mempages_collection_type.subclass:
            return injected_mempages_collection_type.subclass(*args_, **kwargs_)
        else:
            return injected_mempages_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_injected_mempage(self): return self.injected_mempage
    def set_injected_mempage(self, injected_mempage): self.injected_mempage = injected_mempage
    def add_injected_mempage(self, value): self.injected_mempage.append(value)
    def insert_injected_mempage(self, index, value): self.injected_mempage[index] = value
    def export(self, outfile, level, namespace_='', name_='injected_mempages_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='injected_mempages_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='injected_mempages_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='injected_mempages_collection_type'):
        for injected_mempage_ in self.injected_mempage:
            injected_mempage_.export(outfile, level, namespace_, name_='injected_mempage')
    def hasContent_(self):
        if (
            self.injected_mempage
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='injected_mempages_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('injected_mempage=[\n')
        level += 1
        for injected_mempage_ in self.injected_mempage:
            showIndent(outfile, level)
            outfile.write('model_.injected_mempage_type(\n')
            injected_mempage_.exportLiteral(outfile, level, name_='injected_mempage_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'injected_mempage': 
            obj_ = injected_mempage_type.factory()
            obj_.build(child_)
            self.injected_mempage.append(obj_)
# end class injected_mempages_collection_type


class injected_mempages_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, injected_mempages_collection=None, notes_collection=None):
        self.injected_mempages_collection = injected_mempages_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if injected_mempages_type.subclass:
            return injected_mempages_type.subclass(*args_, **kwargs_)
        else:
            return injected_mempages_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_injected_mempages_collection(self): return self.injected_mempages_collection
    def set_injected_mempages_collection(self, injected_mempages_collection): self.injected_mempages_collection = injected_mempages_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='injected_mempages_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='injected_mempages_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='injected_mempages_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='injected_mempages_type'):
        if self.injected_mempages_collection:
            self.injected_mempages_collection.export(outfile, level, namespace_, name_='injected_mempages_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.injected_mempages_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='injected_mempages_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.injected_mempages_collection is not None:
            showIndent(outfile, level)
            outfile.write('injected_mempages_collection=model_.injected_mempages_collection_type(\n')
            self.injected_mempages_collection.exportLiteral(outfile, level, name_='injected_mempages_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'injected_mempages_collection': 
            obj_ = injected_mempages_collection_type.factory()
            obj_.build(child_)
            self.set_injected_mempages_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class injected_mempages_type


class added_module_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, module_name=None, module_filename=None, process_name=None, process_filename=None, address_start=None, address_end=None, attached_zip_dump=None):
        self.module_name = module_name
        self.module_filename = module_filename
        self.process_name = process_name
        self.process_filename = process_filename
        self.address_start = address_start
        self.address_end = address_end
        self.attached_zip_dump = attached_zip_dump
    def factory(*args_, **kwargs_):
        if added_module_type.subclass:
            return added_module_type.subclass(*args_, **kwargs_)
        else:
            return added_module_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_module_name(self): return self.module_name
    def set_module_name(self, module_name): self.module_name = module_name
    def validate_module_name(self, value):
        # validate type module_name
        pass
    def get_module_filename(self): return self.module_filename
    def set_module_filename(self, module_filename): self.module_filename = module_filename
    def validate_module_filename(self, value):
        # validate type module_filename
        pass
    def get_process_name(self): return self.process_name
    def set_process_name(self, process_name): self.process_name = process_name
    def validate_process_name(self, value):
        # validate type process_name
        pass
    def get_process_filename(self): return self.process_filename
    def set_process_filename(self, process_filename): self.process_filename = process_filename
    def validate_process_filename(self, value):
        # validate type process_filename
        pass
    def get_address_start(self): return self.address_start
    def set_address_start(self, address_start): self.address_start = address_start
    def validate_address_start(self, value):
        # validate type address_start
        pass
    def get_address_end(self): return self.address_end
    def set_address_end(self, address_end): self.address_end = address_end
    def validate_address_end(self, value):
        # validate type address_end
        pass
    def get_attached_zip_dump(self): return self.attached_zip_dump
    def set_attached_zip_dump(self, attached_zip_dump): self.attached_zip_dump = attached_zip_dump
    def validate_attached_zip_dump(self, value):
        # validate type attached_zip_dump
        pass
    def export(self, outfile, level, namespace_='', name_='added_module_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_module_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_module_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_module_type'):
        if self.module_name is not None:
            showIndent(outfile, level)
            outfile.write('<%smodule_name>%s</%smodule_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.module_name).encode(ExternalEncoding), input_name='module_name'), namespace_))
        if self.module_filename is not None:
            showIndent(outfile, level)
            outfile.write('<%smodule_filename>%s</%smodule_filename>\n' % (namespace_, self.gds_format_string(quote_xml(self.module_filename).encode(ExternalEncoding), input_name='module_filename'), namespace_))
        if self.process_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocess_name>%s</%sprocess_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.process_name).encode(ExternalEncoding), input_name='process_name'), namespace_))
        if self.process_filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocess_filename>%s</%sprocess_filename>\n' % (namespace_, self.gds_format_string(quote_xml(self.process_filename).encode(ExternalEncoding), input_name='process_filename'), namespace_))
        if self.address_start is not None:
            showIndent(outfile, level)
            outfile.write('<%saddress_start>%s</%saddress_start>\n' % (namespace_, self.gds_format_string(quote_xml(self.address_start).encode(ExternalEncoding), input_name='address_start'), namespace_))
        if self.address_end is not None:
            showIndent(outfile, level)
            outfile.write('<%saddress_end>%s</%saddress_end>\n' % (namespace_, self.gds_format_string(quote_xml(self.address_end).encode(ExternalEncoding), input_name='address_end'), namespace_))
        if self.attached_zip_dump is not None:
            showIndent(outfile, level)
            outfile.write('<%sattached_zip_dump>%s</%sattached_zip_dump>\n' % (namespace_, self.gds_format_string(quote_xml(self.attached_zip_dump).encode(ExternalEncoding), input_name='attached_zip_dump'), namespace_))
    def hasContent_(self):
        if (
            self.module_name is not None or
            self.module_filename is not None or
            self.process_name is not None or
            self.process_filename is not None or
            self.address_start is not None or
            self.address_end is not None or
            self.attached_zip_dump is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_module_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.module_name is not None:
            showIndent(outfile, level)
            outfile.write('module_name=%s,\n' % quote_python(self.module_name).encode(ExternalEncoding))
        if self.module_filename is not None:
            showIndent(outfile, level)
            outfile.write('module_filename=%s,\n' % quote_python(self.module_filename).encode(ExternalEncoding))
        if self.process_name is not None:
            showIndent(outfile, level)
            outfile.write('process_name=%s,\n' % quote_python(self.process_name).encode(ExternalEncoding))
        if self.process_filename is not None:
            showIndent(outfile, level)
            outfile.write('process_filename=%s,\n' % quote_python(self.process_filename).encode(ExternalEncoding))
        if self.address_start is not None:
            showIndent(outfile, level)
            outfile.write('address_start=%s,\n' % quote_python(self.address_start).encode(ExternalEncoding))
        if self.address_end is not None:
            showIndent(outfile, level)
            outfile.write('address_end=%s,\n' % quote_python(self.address_end).encode(ExternalEncoding))
        if self.attached_zip_dump is not None:
            showIndent(outfile, level)
            outfile.write('attached_zip_dump=%s,\n' % quote_python(self.attached_zip_dump).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'module_name':
            module_name_ = child_.text
            self.module_name = module_name_
            self.validate_module_name(self.module_name)    # validate type module_name
        elif nodeName_ == 'module_filename':
            module_filename_ = child_.text
            self.module_filename = module_filename_
            self.validate_module_filename(self.module_filename)    # validate type module_filename
        elif nodeName_ == 'process_name':
            process_name_ = child_.text
            self.process_name = process_name_
            self.validate_process_name(self.process_name)    # validate type process_name
        elif nodeName_ == 'process_filename':
            process_filename_ = child_.text
            self.process_filename = process_filename_
            self.validate_process_filename(self.process_filename)    # validate type process_filename
        elif nodeName_ == 'address_start':
            address_start_ = child_.text
            self.address_start = address_start_
            self.validate_address_start(self.address_start)    # validate type address_start
        elif nodeName_ == 'address_end':
            address_end_ = child_.text
            self.address_end = address_end_
            self.validate_address_end(self.address_end)    # validate type address_end
        elif nodeName_ == 'attached_zip_dump':
            attached_zip_dump_ = child_.text
            self.attached_zip_dump = attached_zip_dump_
            self.validate_attached_zip_dump(self.attached_zip_dump)    # validate type attached_zip_dump
# end class added_module_type


class added_modules_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_module=None):
        if added_module is None:
            self.added_module = []
        else:
            self.added_module = added_module
    def factory(*args_, **kwargs_):
        if added_modules_collection_type.subclass:
            return added_modules_collection_type.subclass(*args_, **kwargs_)
        else:
            return added_modules_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_module(self): return self.added_module
    def set_added_module(self, added_module): self.added_module = added_module
    def add_added_module(self, value): self.added_module.append(value)
    def insert_added_module(self, index, value): self.added_module[index] = value
    def export(self, outfile, level, namespace_='', name_='added_modules_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_modules_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_modules_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_modules_collection_type'):
        for added_module_ in self.added_module:
            added_module_.export(outfile, level, namespace_, name_='added_module')
    def hasContent_(self):
        if (
            self.added_module
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_modules_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('added_module=[\n')
        level += 1
        for added_module_ in self.added_module:
            showIndent(outfile, level)
            outfile.write('model_.added_module_type(\n')
            added_module_.exportLiteral(outfile, level, name_='added_module_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_module': 
            obj_ = added_module_type.factory()
            obj_.build(child_)
            self.added_module.append(obj_)
# end class added_modules_collection_type


class added_modules_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_modules_collection=None, notes_collection=None):
        self.added_modules_collection = added_modules_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if added_modules_type.subclass:
            return added_modules_type.subclass(*args_, **kwargs_)
        else:
            return added_modules_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_modules_collection(self): return self.added_modules_collection
    def set_added_modules_collection(self, added_modules_collection): self.added_modules_collection = added_modules_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='added_modules_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_modules_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_modules_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_modules_type'):
        if self.added_modules_collection:
            self.added_modules_collection.export(outfile, level, namespace_, name_='added_modules_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.added_modules_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_modules_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.added_modules_collection is not None:
            showIndent(outfile, level)
            outfile.write('added_modules_collection=model_.added_modules_collection_type(\n')
            self.added_modules_collection.exportLiteral(outfile, level, name_='added_modules_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_modules_collection': 
            obj_ = added_modules_collection_type.factory()
            obj_.build(child_)
            self.set_added_modules_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class added_modules_type


class added_service_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, service_name=None, display_name=None, status=None, service_filename=None):
        self.service_name = service_name
        self.display_name = display_name
        self.status = status
        self.service_filename = service_filename
    def factory(*args_, **kwargs_):
        if added_service_type.subclass:
            return added_service_type.subclass(*args_, **kwargs_)
        else:
            return added_service_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service_name(self): return self.service_name
    def set_service_name(self, service_name): self.service_name = service_name
    def validate_service_name(self, value):
        # validate type service_name
        pass
    def get_display_name(self): return self.display_name
    def set_display_name(self, display_name): self.display_name = display_name
    def validate_display_name(self, value):
        # validate type display_name
        pass
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def validate_status(self, value):
        # validate type status
        pass
    def get_service_filename(self): return self.service_filename
    def set_service_filename(self, service_filename): self.service_filename = service_filename
    def validate_service_filename(self, value):
        # validate type service_filename
        pass
    def export(self, outfile, level, namespace_='', name_='added_service_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_service_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_service_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_service_type'):
        if self.service_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sservice_name>%s</%sservice_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.service_name).encode(ExternalEncoding), input_name='service_name'), namespace_))
        if self.display_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sdisplay_name>%s</%sdisplay_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.display_name).encode(ExternalEncoding), input_name='display_name'), namespace_))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('<%sstatus>%s</%sstatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.status).encode(ExternalEncoding), input_name='status'), namespace_))
        if self.service_filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sservice_filename>%s</%sservice_filename>\n' % (namespace_, self.gds_format_string(quote_xml(self.service_filename).encode(ExternalEncoding), input_name='service_filename'), namespace_))
    def hasContent_(self):
        if (
            self.service_name is not None or
            self.display_name is not None or
            self.status is not None or
            self.service_filename is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_service_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.service_name is not None:
            showIndent(outfile, level)
            outfile.write('service_name=%s,\n' % quote_python(self.service_name).encode(ExternalEncoding))
        if self.display_name is not None:
            showIndent(outfile, level)
            outfile.write('display_name=%s,\n' % quote_python(self.display_name).encode(ExternalEncoding))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % quote_python(self.status).encode(ExternalEncoding))
        if self.service_filename is not None:
            showIndent(outfile, level)
            outfile.write('service_filename=%s,\n' % quote_python(self.service_filename).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'service_name':
            service_name_ = child_.text
            self.service_name = service_name_
            self.validate_service_name(self.service_name)    # validate type service_name
        elif nodeName_ == 'display_name':
            display_name_ = child_.text
            self.display_name = display_name_
            self.validate_display_name(self.display_name)    # validate type display_name
        elif nodeName_ == 'status':
            status_ = child_.text
            self.status = status_
            self.validate_status(self.status)    # validate type status
        elif nodeName_ == 'service_filename':
            service_filename_ = child_.text
            self.service_filename = service_filename_
            self.validate_service_filename(self.service_filename)    # validate type service_filename
# end class added_service_type


class added_services_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_service=None):
        if added_service is None:
            self.added_service = []
        else:
            self.added_service = added_service
    def factory(*args_, **kwargs_):
        if added_services_collection_type.subclass:
            return added_services_collection_type.subclass(*args_, **kwargs_)
        else:
            return added_services_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_service(self): return self.added_service
    def set_added_service(self, added_service): self.added_service = added_service
    def add_added_service(self, value): self.added_service.append(value)
    def insert_added_service(self, index, value): self.added_service[index] = value
    def export(self, outfile, level, namespace_='', name_='added_services_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_services_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_services_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_services_collection_type'):
        for added_service_ in self.added_service:
            added_service_.export(outfile, level, namespace_, name_='added_service')
    def hasContent_(self):
        if (
            self.added_service
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_services_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('added_service=[\n')
        level += 1
        for added_service_ in self.added_service:
            showIndent(outfile, level)
            outfile.write('model_.added_service_type(\n')
            added_service_.exportLiteral(outfile, level, name_='added_service_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_service': 
            obj_ = added_service_type.factory()
            obj_.build(child_)
            self.added_service.append(obj_)
# end class added_services_collection_type


class added_services_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_services_collection=None, notes_collection=None):
        self.added_services_collection = added_services_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if added_services_type.subclass:
            return added_services_type.subclass(*args_, **kwargs_)
        else:
            return added_services_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_services_collection(self): return self.added_services_collection
    def set_added_services_collection(self, added_services_collection): self.added_services_collection = added_services_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='added_services_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_services_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_services_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_services_type'):
        if self.added_services_collection:
            self.added_services_collection.export(outfile, level, namespace_, name_='added_services_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.added_services_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_services_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.added_services_collection is not None:
            showIndent(outfile, level)
            outfile.write('added_services_collection=model_.added_services_collection_type(\n')
            self.added_services_collection.exportLiteral(outfile, level, name_='added_services_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_services_collection': 
            obj_ = added_services_collection_type.factory()
            obj_.build(child_)
            self.set_added_services_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class added_services_type


class modified_service_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, service_name=None, display_name=None, newstatus=None, service_filename=None):
        self.service_name = service_name
        self.display_name = display_name
        self.newstatus = newstatus
        self.service_filename = service_filename
    def factory(*args_, **kwargs_):
        if modified_service_type.subclass:
            return modified_service_type.subclass(*args_, **kwargs_)
        else:
            return modified_service_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service_name(self): return self.service_name
    def set_service_name(self, service_name): self.service_name = service_name
    def validate_service_name(self, value):
        # validate type service_name
        pass
    def get_display_name(self): return self.display_name
    def set_display_name(self, display_name): self.display_name = display_name
    def validate_display_name(self, value):
        # validate type display_name
        pass
    def get_newstatus(self): return self.newstatus
    def set_newstatus(self, newstatus): self.newstatus = newstatus
    def validate_newstatus(self, value):
        # validate type newstatus
        pass
    def get_service_filename(self): return self.service_filename
    def set_service_filename(self, service_filename): self.service_filename = service_filename
    def validate_service_filename(self, value):
        # validate type service_filename
        pass
    def export(self, outfile, level, namespace_='', name_='modified_service_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='modified_service_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='modified_service_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='modified_service_type'):
        if self.service_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sservice_name>%s</%sservice_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.service_name).encode(ExternalEncoding), input_name='service_name'), namespace_))
        if self.display_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sdisplay_name>%s</%sdisplay_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.display_name).encode(ExternalEncoding), input_name='display_name'), namespace_))
        if self.newstatus is not None:
            showIndent(outfile, level)
            outfile.write('<%snewstatus>%s</%snewstatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.newstatus).encode(ExternalEncoding), input_name='newstatus'), namespace_))
        if self.service_filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sservice_filename>%s</%sservice_filename>\n' % (namespace_, self.gds_format_string(quote_xml(self.service_filename).encode(ExternalEncoding), input_name='service_filename'), namespace_))
    def hasContent_(self):
        if (
            self.service_name is not None or
            self.display_name is not None or
            self.newstatus is not None or
            self.service_filename is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='modified_service_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.service_name is not None:
            showIndent(outfile, level)
            outfile.write('service_name=%s,\n' % quote_python(self.service_name).encode(ExternalEncoding))
        if self.display_name is not None:
            showIndent(outfile, level)
            outfile.write('display_name=%s,\n' % quote_python(self.display_name).encode(ExternalEncoding))
        if self.newstatus is not None:
            showIndent(outfile, level)
            outfile.write('newstatus=%s,\n' % quote_python(self.newstatus).encode(ExternalEncoding))
        if self.service_filename is not None:
            showIndent(outfile, level)
            outfile.write('service_filename=%s,\n' % quote_python(self.service_filename).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'service_name':
            service_name_ = child_.text
            self.service_name = service_name_
            self.validate_service_name(self.service_name)    # validate type service_name
        elif nodeName_ == 'display_name':
            display_name_ = child_.text
            self.display_name = display_name_
            self.validate_display_name(self.display_name)    # validate type display_name
        elif nodeName_ == 'newstatus':
            newstatus_ = child_.text
            self.newstatus = newstatus_
            self.validate_newstatus(self.newstatus)    # validate type newstatus
        elif nodeName_ == 'service_filename':
            service_filename_ = child_.text
            self.service_filename = service_filename_
            self.validate_service_filename(self.service_filename)    # validate type service_filename
# end class modified_service_type


class modified_services_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modified_service=None):
        if modified_service is None:
            self.modified_service = []
        else:
            self.modified_service = modified_service
    def factory(*args_, **kwargs_):
        if modified_services_collection_type.subclass:
            return modified_services_collection_type.subclass(*args_, **kwargs_)
        else:
            return modified_services_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modified_service(self): return self.modified_service
    def set_modified_service(self, modified_service): self.modified_service = modified_service
    def add_modified_service(self, value): self.modified_service.append(value)
    def insert_modified_service(self, index, value): self.modified_service[index] = value
    def export(self, outfile, level, namespace_='', name_='modified_services_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='modified_services_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='modified_services_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='modified_services_collection_type'):
        for modified_service_ in self.modified_service:
            modified_service_.export(outfile, level, namespace_, name_='modified_service')
    def hasContent_(self):
        if (
            self.modified_service
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='modified_services_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('modified_service=[\n')
        level += 1
        for modified_service_ in self.modified_service:
            showIndent(outfile, level)
            outfile.write('model_.modified_service_type(\n')
            modified_service_.exportLiteral(outfile, level, name_='modified_service_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'modified_service': 
            obj_ = modified_service_type.factory()
            obj_.build(child_)
            self.modified_service.append(obj_)
# end class modified_services_collection_type


class modified_services_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modified_services_collection=None, notes_collection=None):
        self.modified_services_collection = modified_services_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if modified_services_type.subclass:
            return modified_services_type.subclass(*args_, **kwargs_)
        else:
            return modified_services_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modified_services_collection(self): return self.modified_services_collection
    def set_modified_services_collection(self, modified_services_collection): self.modified_services_collection = modified_services_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='modified_services_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='modified_services_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='modified_services_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='modified_services_type'):
        if self.modified_services_collection:
            self.modified_services_collection.export(outfile, level, namespace_, name_='modified_services_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.modified_services_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='modified_services_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.modified_services_collection is not None:
            showIndent(outfile, level)
            outfile.write('modified_services_collection=model_.modified_services_collection_type(\n')
            self.modified_services_collection.exportLiteral(outfile, level, name_='modified_services_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'modified_services_collection': 
            obj_ = modified_services_collection_type.factory()
            obj_.build(child_)
            self.set_modified_services_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class modified_services_type


class added_driver_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, driver_name=None, driver_filename=None):
        self.driver_name = driver_name
        self.driver_filename = driver_filename
    def factory(*args_, **kwargs_):
        if added_driver_type.subclass:
            return added_driver_type.subclass(*args_, **kwargs_)
        else:
            return added_driver_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_driver_name(self): return self.driver_name
    def set_driver_name(self, driver_name): self.driver_name = driver_name
    def validate_driver_name(self, value):
        # validate type driver_name
        pass
    def get_driver_filename(self): return self.driver_filename
    def set_driver_filename(self, driver_filename): self.driver_filename = driver_filename
    def validate_driver_filename(self, value):
        # validate type driver_filename
        pass
    def export(self, outfile, level, namespace_='', name_='added_driver_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_driver_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_driver_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_driver_type'):
        if self.driver_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sdriver_name>%s</%sdriver_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.driver_name).encode(ExternalEncoding), input_name='driver_name'), namespace_))
        if self.driver_filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sdriver_filename>%s</%sdriver_filename>\n' % (namespace_, self.gds_format_string(quote_xml(self.driver_filename).encode(ExternalEncoding), input_name='driver_filename'), namespace_))
    def hasContent_(self):
        if (
            self.driver_name is not None or
            self.driver_filename is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_driver_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.driver_name is not None:
            showIndent(outfile, level)
            outfile.write('driver_name=%s,\n' % quote_python(self.driver_name).encode(ExternalEncoding))
        if self.driver_filename is not None:
            showIndent(outfile, level)
            outfile.write('driver_filename=%s,\n' % quote_python(self.driver_filename).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'driver_name':
            driver_name_ = child_.text
            self.driver_name = driver_name_
            self.validate_driver_name(self.driver_name)    # validate type driver_name
        elif nodeName_ == 'driver_filename':
            driver_filename_ = child_.text
            self.driver_filename = driver_filename_
            self.validate_driver_filename(self.driver_filename)    # validate type driver_filename
# end class added_driver_type


class added_drivers_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_driver=None):
        if added_driver is None:
            self.added_driver = []
        else:
            self.added_driver = added_driver
    def factory(*args_, **kwargs_):
        if added_drivers_collection_type.subclass:
            return added_drivers_collection_type.subclass(*args_, **kwargs_)
        else:
            return added_drivers_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_driver(self): return self.added_driver
    def set_added_driver(self, added_driver): self.added_driver = added_driver
    def add_added_driver(self, value): self.added_driver.append(value)
    def insert_added_driver(self, index, value): self.added_driver[index] = value
    def export(self, outfile, level, namespace_='', name_='added_drivers_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_drivers_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_drivers_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_drivers_collection_type'):
        for added_driver_ in self.added_driver:
            added_driver_.export(outfile, level, namespace_, name_='added_driver')
    def hasContent_(self):
        if (
            self.added_driver
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_drivers_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('added_driver=[\n')
        level += 1
        for added_driver_ in self.added_driver:
            showIndent(outfile, level)
            outfile.write('model_.added_driver_type(\n')
            added_driver_.exportLiteral(outfile, level, name_='added_driver_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_driver': 
            obj_ = added_driver_type.factory()
            obj_.build(child_)
            self.added_driver.append(obj_)
# end class added_drivers_collection_type


class added_drivers_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_drivers_collection=None, notes_collection=None):
        self.added_drivers_collection = added_drivers_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if added_drivers_type.subclass:
            return added_drivers_type.subclass(*args_, **kwargs_)
        else:
            return added_drivers_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_drivers_collection(self): return self.added_drivers_collection
    def set_added_drivers_collection(self, added_drivers_collection): self.added_drivers_collection = added_drivers_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='added_drivers_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_drivers_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_drivers_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_drivers_type'):
        if self.added_drivers_collection:
            self.added_drivers_collection.export(outfile, level, namespace_, name_='added_drivers_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.added_drivers_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_drivers_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.added_drivers_collection is not None:
            showIndent(outfile, level)
            outfile.write('added_drivers_collection=model_.added_drivers_collection_type(\n')
            self.added_drivers_collection.exportLiteral(outfile, level, name_='added_drivers_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_drivers_collection': 
            obj_ = added_drivers_collection_type.factory()
            obj_.build(child_)
            self.set_added_drivers_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class added_drivers_type


class added_syscallhook_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, syscall=None, driver_name=None, driver_filename=None):
        self.syscall = syscall
        self.driver_name = driver_name
        self.driver_filename = driver_filename
    def factory(*args_, **kwargs_):
        if added_syscallhook_type.subclass:
            return added_syscallhook_type.subclass(*args_, **kwargs_)
        else:
            return added_syscallhook_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_syscall(self): return self.syscall
    def set_syscall(self, syscall): self.syscall = syscall
    def validate_syscall(self, value):
        # validate type syscall
        pass
    def get_driver_name(self): return self.driver_name
    def set_driver_name(self, driver_name): self.driver_name = driver_name
    def validate_driver_name(self, value):
        # validate type driver_name
        pass
    def get_driver_filename(self): return self.driver_filename
    def set_driver_filename(self, driver_filename): self.driver_filename = driver_filename
    def validate_driver_filename(self, value):
        # validate type driver_filename
        pass
    def export(self, outfile, level, namespace_='', name_='added_syscallhook_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_syscallhook_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_syscallhook_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_syscallhook_type'):
        if self.syscall is not None:
            showIndent(outfile, level)
            outfile.write('<%ssyscall>%s</%ssyscall>\n' % (namespace_, self.gds_format_string(quote_xml(self.syscall).encode(ExternalEncoding), input_name='syscall'), namespace_))
        if self.driver_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sdriver_name>%s</%sdriver_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.driver_name).encode(ExternalEncoding), input_name='driver_name'), namespace_))
        if self.driver_filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sdriver_filename>%s</%sdriver_filename>\n' % (namespace_, self.gds_format_string(quote_xml(self.driver_filename).encode(ExternalEncoding), input_name='driver_filename'), namespace_))
    def hasContent_(self):
        if (
            self.syscall is not None or
            self.driver_name is not None or
            self.driver_filename is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_syscallhook_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.syscall is not None:
            showIndent(outfile, level)
            outfile.write('syscall=%s,\n' % quote_python(self.syscall).encode(ExternalEncoding))
        if self.driver_name is not None:
            showIndent(outfile, level)
            outfile.write('driver_name=%s,\n' % quote_python(self.driver_name).encode(ExternalEncoding))
        if self.driver_filename is not None:
            showIndent(outfile, level)
            outfile.write('driver_filename=%s,\n' % quote_python(self.driver_filename).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'syscall':
            syscall_ = child_.text
            self.syscall = syscall_
            self.validate_syscall(self.syscall)    # validate type syscall
        elif nodeName_ == 'driver_name':
            driver_name_ = child_.text
            self.driver_name = driver_name_
            self.validate_driver_name(self.driver_name)    # validate type driver_name
        elif nodeName_ == 'driver_filename':
            driver_filename_ = child_.text
            self.driver_filename = driver_filename_
            self.validate_driver_filename(self.driver_filename)    # validate type driver_filename
# end class added_syscallhook_type


class added_syscallhooks_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_syscallhook=None):
        if added_syscallhook is None:
            self.added_syscallhook = []
        else:
            self.added_syscallhook = added_syscallhook
    def factory(*args_, **kwargs_):
        if added_syscallhooks_collection_type.subclass:
            return added_syscallhooks_collection_type.subclass(*args_, **kwargs_)
        else:
            return added_syscallhooks_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_syscallhook(self): return self.added_syscallhook
    def set_added_syscallhook(self, added_syscallhook): self.added_syscallhook = added_syscallhook
    def add_added_syscallhook(self, value): self.added_syscallhook.append(value)
    def insert_added_syscallhook(self, index, value): self.added_syscallhook[index] = value
    def export(self, outfile, level, namespace_='', name_='added_syscallhooks_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_syscallhooks_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_syscallhooks_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_syscallhooks_collection_type'):
        for added_syscallhook_ in self.added_syscallhook:
            added_syscallhook_.export(outfile, level, namespace_, name_='added_syscallhook')
    def hasContent_(self):
        if (
            self.added_syscallhook
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_syscallhooks_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('added_syscallhook=[\n')
        level += 1
        for added_syscallhook_ in self.added_syscallhook:
            showIndent(outfile, level)
            outfile.write('model_.added_syscallhook_type(\n')
            added_syscallhook_.exportLiteral(outfile, level, name_='added_syscallhook_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_syscallhook': 
            obj_ = added_syscallhook_type.factory()
            obj_.build(child_)
            self.added_syscallhook.append(obj_)
# end class added_syscallhooks_collection_type


class added_syscallhooks_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, added_syscallhooks_collection=None, notes_collection=None):
        self.added_syscallhooks_collection = added_syscallhooks_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if added_syscallhooks_type.subclass:
            return added_syscallhooks_type.subclass(*args_, **kwargs_)
        else:
            return added_syscallhooks_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_added_syscallhooks_collection(self): return self.added_syscallhooks_collection
    def set_added_syscallhooks_collection(self, added_syscallhooks_collection): self.added_syscallhooks_collection = added_syscallhooks_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='added_syscallhooks_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='added_syscallhooks_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='added_syscallhooks_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='added_syscallhooks_type'):
        if self.added_syscallhooks_collection:
            self.added_syscallhooks_collection.export(outfile, level, namespace_, name_='added_syscallhooks_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.added_syscallhooks_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='added_syscallhooks_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.added_syscallhooks_collection is not None:
            showIndent(outfile, level)
            outfile.write('added_syscallhooks_collection=model_.added_syscallhooks_collection_type(\n')
            self.added_syscallhooks_collection.exportLiteral(outfile, level, name_='added_syscallhooks_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'added_syscallhooks_collection': 
            obj_ = added_syscallhooks_collection_type.factory()
            obj_.build(child_)
            self.set_added_syscallhooks_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class added_syscallhooks_type


class irp_hooks_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, irp_hook=None):
        if irp_hook is None:
            self.irp_hook = []
        else:
            self.irp_hook = irp_hook
    def factory(*args_, **kwargs_):
        if irp_hooks_type.subclass:
            return irp_hooks_type.subclass(*args_, **kwargs_)
        else:
            return irp_hooks_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_irp_hook(self): return self.irp_hook
    def set_irp_hook(self, irp_hook): self.irp_hook = irp_hook
    def add_irp_hook(self, value): self.irp_hook.append(value)
    def insert_irp_hook(self, index, value): self.irp_hook[index] = value
    def validate_irp_hook(self, value):
        # validate type irp_hook
        pass
    def export(self, outfile, level, namespace_='', name_='irp_hooks_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='irp_hooks_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='irp_hooks_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='irp_hooks_type'):
        for irp_hook_ in self.irp_hook:
            showIndent(outfile, level)
            outfile.write('<%sirp_hook>%s</%sirp_hook>\n' % (namespace_, self.gds_format_string(quote_xml(irp_hook_).encode(ExternalEncoding), input_name='irp_hook'), namespace_))
    def hasContent_(self):
        if (
            self.irp_hook
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='irp_hooks_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('irp_hook=[\n')
        level += 1
        for irp_hook_ in self.irp_hook:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(irp_hook_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'irp_hook':
            irp_hook_ = child_.text
            self.irp_hook.append(irp_hook_)
            self.validate_irp_hook(self.irp_hook)    # validate type irp_hook
# end class irp_hooks_type


class regkeys_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, regkey=None):
        if regkey is None:
            self.regkey = []
        else:
            self.regkey = regkey
    def factory(*args_, **kwargs_):
        if regkeys_type.subclass:
            return regkeys_type.subclass(*args_, **kwargs_)
        else:
            return regkeys_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regkey(self): return self.regkey
    def set_regkey(self, regkey): self.regkey = regkey
    def add_regkey(self, value): self.regkey.append(value)
    def insert_regkey(self, index, value): self.regkey[index] = value
    def validate_regkey(self, value):
        # validate type regkey
        pass
    def export(self, outfile, level, namespace_='', name_='regkeys_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeys_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='regkeys_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='regkeys_type'):
        for regkey_ in self.regkey:
            showIndent(outfile, level)
            outfile.write('<%sregkey>%s</%sregkey>\n' % (namespace_, self.gds_format_string(quote_xml(regkey_).encode(ExternalEncoding), input_name='regkey'), namespace_))
    def hasContent_(self):
        if (
            self.regkey
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeys_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('regkey=[\n')
        level += 1
        for regkey_ in self.regkey:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(regkey_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'regkey':
            regkey_ = child_.text
            self.regkey.append(regkey_)
            self.validate_regkey(self.regkey)    # validate type regkey
# end class regkeys_type


class regvalue_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, contents=None):
        self.value = value
        self.contents = contents
    def factory(*args_, **kwargs_):
        if regvalue_type.subclass:
            return regvalue_type.subclass(*args_, **kwargs_)
        else:
            return regvalue_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_value(self, value):
        # validate type value
        pass
    def get_contents(self): return self.contents
    def set_contents(self, contents): self.contents = contents
    def validate_contents(self, value):
        # validate type contents
        pass
    def export(self, outfile, level, namespace_='', name_='regvalue_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regvalue_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='regvalue_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='regvalue_type'):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
        if self.contents is not None:
            showIndent(outfile, level)
            outfile.write('<%scontents>%s</%scontents>\n' % (namespace_, self.gds_format_string(quote_xml(self.contents).encode(ExternalEncoding), input_name='contents'), namespace_))
    def hasContent_(self):
        if (
            self.value is not None or
            self.contents is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regvalue_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.contents is not None:
            showIndent(outfile, level)
            outfile.write('contents=%s,\n' % quote_python(self.contents).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'value':
            value_ = child_.text
            self.value = value_
            self.validate_value(self.value)    # validate type value
        elif nodeName_ == 'contents':
            contents_ = child_.text
            self.contents = contents_
            self.validate_contents(self.contents)    # validate type contents
# end class regvalue_type


class regvalues_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, regvalue=None):
        if regvalue is None:
            self.regvalue = []
        else:
            self.regvalue = regvalue
    def factory(*args_, **kwargs_):
        if regvalues_collection_type.subclass:
            return regvalues_collection_type.subclass(*args_, **kwargs_)
        else:
            return regvalues_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regvalue(self): return self.regvalue
    def set_regvalue(self, regvalue): self.regvalue = regvalue
    def add_regvalue(self, value): self.regvalue.append(value)
    def insert_regvalue(self, index, value): self.regvalue[index] = value
    def export(self, outfile, level, namespace_='', name_='regvalues_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regvalues_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='regvalues_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='regvalues_collection_type'):
        for regvalue_ in self.regvalue:
            regvalue_.export(outfile, level, namespace_, name_='regvalue')
    def hasContent_(self):
        if (
            self.regvalue
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regvalues_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('regvalue=[\n')
        level += 1
        for regvalue_ in self.regvalue:
            showIndent(outfile, level)
            outfile.write('model_.regvalue_type(\n')
            regvalue_.exportLiteral(outfile, level, name_='regvalue_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'regvalue': 
            obj_ = regvalue_type.factory()
            obj_.build(child_)
            self.regvalue.append(obj_)
# end class regvalues_collection_type


class regvalues_structure_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, regkey=None, regvalues_collection=None, notes_collection=None):
        self.regkey = regkey
        self.regvalues_collection = regvalues_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if regvalues_structure_type.subclass:
            return regvalues_structure_type.subclass(*args_, **kwargs_)
        else:
            return regvalues_structure_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regkey(self): return self.regkey
    def set_regkey(self, regkey): self.regkey = regkey
    def validate_regkey(self, value):
        # validate type regkey
        pass
    def get_regvalues_collection(self): return self.regvalues_collection
    def set_regvalues_collection(self, regvalues_collection): self.regvalues_collection = regvalues_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='regvalues_structure_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regvalues_structure_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='regvalues_structure_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='regvalues_structure_type'):
        if self.regkey is not None:
            showIndent(outfile, level)
            outfile.write('<%sregkey>%s</%sregkey>\n' % (namespace_, self.gds_format_string(quote_xml(self.regkey).encode(ExternalEncoding), input_name='regkey'), namespace_))
        if self.regvalues_collection:
            self.regvalues_collection.export(outfile, level, namespace_, name_='regvalues_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.regkey is not None or
            self.regvalues_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regvalues_structure_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.regkey is not None:
            showIndent(outfile, level)
            outfile.write('regkey=%s,\n' % quote_python(self.regkey).encode(ExternalEncoding))
        if self.regvalues_collection is not None:
            showIndent(outfile, level)
            outfile.write('regvalues_collection=model_.regvalues_collection_type(\n')
            self.regvalues_collection.exportLiteral(outfile, level, name_='regvalues_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'regkey':
            regkey_ = child_.text
            self.regkey = regkey_
            self.validate_regkey(self.regkey)    # validate type regkey
        elif nodeName_ == 'regvalues_collection': 
            obj_ = regvalues_collection_type.factory()
            obj_.build(child_)
            self.set_regvalues_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class regvalues_structure_type


class regvalue_structures_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, regvalues_structure=None):
        if regvalues_structure is None:
            self.regvalues_structure = []
        else:
            self.regvalues_structure = regvalues_structure
    def factory(*args_, **kwargs_):
        if regvalue_structures_type.subclass:
            return regvalue_structures_type.subclass(*args_, **kwargs_)
        else:
            return regvalue_structures_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regvalues_structure(self): return self.regvalues_structure
    def set_regvalues_structure(self, regvalues_structure): self.regvalues_structure = regvalues_structure
    def add_regvalues_structure(self, value): self.regvalues_structure.append(value)
    def insert_regvalues_structure(self, index, value): self.regvalues_structure[index] = value
    def export(self, outfile, level, namespace_='', name_='regvalue_structures_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regvalue_structures_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='regvalue_structures_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='regvalue_structures_type'):
        for regvalues_structure_ in self.regvalues_structure:
            regvalues_structure_.export(outfile, level, namespace_, name_='regvalues_structure')
    def hasContent_(self):
        if (
            self.regvalues_structure
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regvalue_structures_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('regvalues_structure=[\n')
        level += 1
        for regvalues_structure_ in self.regvalues_structure:
            showIndent(outfile, level)
            outfile.write('model_.regvalues_structure_type(\n')
            regvalues_structure_.exportLiteral(outfile, level, name_='regvalues_structure_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'regvalues_structure': 
            obj_ = regvalues_structure_type.factory()
            obj_.build(child_)
            self.regvalues_structure.append(obj_)
# end class regvalue_structures_type


class countries_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, country=None):
        if country is None:
            self.country = []
        else:
            self.country = country
    def factory(*args_, **kwargs_):
        if countries_type.subclass:
            return countries_type.subclass(*args_, **kwargs_)
        else:
            return countries_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def add_country(self, value): self.country.append(value)
    def insert_country(self, index, value): self.country[index] = value
    def validate_country(self, value):
        # validate type country
        pass
    def export(self, outfile, level, namespace_='', name_='countries_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='countries_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='countries_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='countries_type'):
        for country_ in self.country:
            showIndent(outfile, level)
            outfile.write('<%scountry>%s</%scountry>\n' % (namespace_, self.gds_format_string(quote_xml(country_).encode(ExternalEncoding), input_name='country'), namespace_))
    def hasContent_(self):
        if (
            self.country
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='countries_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('country=[\n')
        level += 1
        for country_ in self.country:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(country_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'country':
            country_ = child_.text
            self.country.append(country_)
            self.validate_country(self.country)    # validate type country
# end class countries_type


class mutexes_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mutex=None):
        if mutex is None:
            self.mutex = []
        else:
            self.mutex = mutex
    def factory(*args_, **kwargs_):
        if mutexes_type.subclass:
            return mutexes_type.subclass(*args_, **kwargs_)
        else:
            return mutexes_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mutex(self): return self.mutex
    def set_mutex(self, mutex): self.mutex = mutex
    def add_mutex(self, value): self.mutex.append(value)
    def insert_mutex(self, index, value): self.mutex[index] = value
    def validate_mutex(self, value):
        # validate type mutex
        pass
    def export(self, outfile, level, namespace_='', name_='mutexes_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='mutexes_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='mutexes_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='mutexes_type'):
        for mutex_ in self.mutex:
            showIndent(outfile, level)
            outfile.write('<%smutex>%s</%smutex>\n' % (namespace_, self.gds_format_string(quote_xml(mutex_).encode(ExternalEncoding), input_name='mutex'), namespace_))
    def hasContent_(self):
        if (
            self.mutex
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mutexes_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mutex=[\n')
        level += 1
        for mutex_ in self.mutex:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(mutex_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'mutex':
            mutex_ = child_.text
            self.mutex.append(mutex_)
            self.validate_mutex(self.mutex)    # validate type mutex
# end class mutexes_type


class open_port_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, port_number=None, protocol=None, procname=None):
        self.port_number = port_number
        self.protocol = protocol
        self.procname = procname
    def factory(*args_, **kwargs_):
        if open_port_type.subclass:
            return open_port_type.subclass(*args_, **kwargs_)
        else:
            return open_port_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port_number(self): return self.port_number
    def set_port_number(self, port_number): self.port_number = port_number
    def validate_port_number(self, value):
        # validate type port_number
        pass
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def validate_protocol(self, value):
        # validate type protocol
        pass
    def get_procname(self): return self.procname
    def set_procname(self, procname): self.procname = procname
    def validate_procname(self, value):
        # validate type procname
        pass
    def export(self, outfile, level, namespace_='', name_='open_port_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='open_port_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='open_port_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='open_port_type'):
        if self.port_number is not None:
            showIndent(outfile, level)
            outfile.write('<%sport_number>%s</%sport_number>\n' % (namespace_, self.gds_format_string(quote_xml(self.port_number).encode(ExternalEncoding), input_name='port_number'), namespace_))
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('<%sprotocol>%s</%sprotocol>\n' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_))
        if self.procname is not None:
            showIndent(outfile, level)
            outfile.write('<%sprocname>%s</%sprocname>\n' % (namespace_, self.gds_format_string(quote_xml(self.procname).encode(ExternalEncoding), input_name='procname'), namespace_))
    def hasContent_(self):
        if (
            self.port_number is not None or
            self.protocol is not None or
            self.procname is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='open_port_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.port_number is not None:
            showIndent(outfile, level)
            outfile.write('port_number=%s,\n' % quote_python(self.port_number).encode(ExternalEncoding))
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.procname is not None:
            showIndent(outfile, level)
            outfile.write('procname=%s,\n' % quote_python(self.procname).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'port_number':
            port_number_ = child_.text
            self.port_number = port_number_
            self.validate_port_number(self.port_number)    # validate type port_number
        elif nodeName_ == 'protocol':
            protocol_ = child_.text
            self.protocol = protocol_
            self.validate_protocol(self.protocol)    # validate type protocol
        elif nodeName_ == 'procname':
            procname_ = child_.text
            self.procname = procname_
            self.validate_procname(self.procname)    # validate type procname
# end class open_port_type


class open_ports_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, open_port=None):
        if open_port is None:
            self.open_port = []
        else:
            self.open_port = open_port
    def factory(*args_, **kwargs_):
        if open_ports_collection_type.subclass:
            return open_ports_collection_type.subclass(*args_, **kwargs_)
        else:
            return open_ports_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_open_port(self): return self.open_port
    def set_open_port(self, open_port): self.open_port = open_port
    def add_open_port(self, value): self.open_port.append(value)
    def insert_open_port(self, index, value): self.open_port[index] = value
    def export(self, outfile, level, namespace_='', name_='open_ports_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='open_ports_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='open_ports_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='open_ports_collection_type'):
        for open_port_ in self.open_port:
            open_port_.export(outfile, level, namespace_, name_='open_port')
    def hasContent_(self):
        if (
            self.open_port
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='open_ports_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('open_port=[\n')
        level += 1
        for open_port_ in self.open_port:
            showIndent(outfile, level)
            outfile.write('model_.open_port_type(\n')
            open_port_.exportLiteral(outfile, level, name_='open_port_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'open_port': 
            obj_ = open_port_type.factory()
            obj_.build(child_)
            self.open_port.append(obj_)
# end class open_ports_collection_type


class open_ports_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, open_ports_collection=None, notes_collection=None):
        self.open_ports_collection = open_ports_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if open_ports_type.subclass:
            return open_ports_type.subclass(*args_, **kwargs_)
        else:
            return open_ports_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_open_ports_collection(self): return self.open_ports_collection
    def set_open_ports_collection(self, open_ports_collection): self.open_ports_collection = open_ports_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='open_ports_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='open_ports_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='open_ports_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='open_ports_type'):
        if self.open_ports_collection:
            self.open_ports_collection.export(outfile, level, namespace_, name_='open_ports_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.open_ports_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='open_ports_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.open_ports_collection is not None:
            showIndent(outfile, level)
            outfile.write('open_ports_collection=model_.open_ports_collection_type(\n')
            self.open_ports_collection.exportLiteral(outfile, level, name_='open_ports_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'open_ports_collection': 
            obj_ = open_ports_collection_type.factory()
            obj_.build(child_)
            self.set_open_ports_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class open_ports_type


class etc_host_lines_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, line=None):
        if line is None:
            self.line = []
        else:
            self.line = line
    def factory(*args_, **kwargs_):
        if etc_host_lines_type.subclass:
            return etc_host_lines_type.subclass(*args_, **kwargs_)
        else:
            return etc_host_lines_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_line(self): return self.line
    def set_line(self, line): self.line = line
    def add_line(self, value): self.line.append(value)
    def insert_line(self, index, value): self.line[index] = value
    def validate_line(self, value):
        # validate type line
        pass
    def export(self, outfile, level, namespace_='', name_='etc_host_lines_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='etc_host_lines_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='etc_host_lines_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='etc_host_lines_type'):
        for line_ in self.line:
            showIndent(outfile, level)
            outfile.write('<%sline>%s</%sline>\n' % (namespace_, self.gds_format_string(quote_xml(line_).encode(ExternalEncoding), input_name='line'), namespace_))
    def hasContent_(self):
        if (
            self.line
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='etc_host_lines_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('line=[\n')
        level += 1
        for line_ in self.line:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(line_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'line':
            line_ = child_.text
            self.line.append(line_)
            self.validate_line(self.line)    # validate type line
# end class etc_host_lines_type


class gethostbyname_api_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, host=None):
        if host is None:
            self.host = []
        else:
            self.host = host
    def factory(*args_, **kwargs_):
        if gethostbyname_api_type.subclass:
            return gethostbyname_api_type.subclass(*args_, **kwargs_)
        else:
            return gethostbyname_api_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self): return self.host
    def set_host(self, host): self.host = host
    def add_host(self, value): self.host.append(value)
    def insert_host(self, index, value): self.host[index] = value
    def validate_host(self, value):
        # validate type host
        pass
    def export(self, outfile, level, namespace_='', name_='gethostbyname_api_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='gethostbyname_api_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='gethostbyname_api_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='gethostbyname_api_type'):
        for host_ in self.host:
            showIndent(outfile, level)
            outfile.write('<%shost>%s</%shost>\n' % (namespace_, self.gds_format_string(quote_xml(host_).encode(ExternalEncoding), input_name='host'), namespace_))
    def hasContent_(self):
        if (
            self.host
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gethostbyname_api_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('host=[\n')
        level += 1
        for host_ in self.host:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(host_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'host':
            host_ = child_.text
            self.host.append(host_)
            self.validate_host(self.host)    # validate type host
# end class gethostbyname_api_type


class connect_ip_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ip=None, port_number=None):
        self.ip = ip
        self.port_number = port_number
    def factory(*args_, **kwargs_):
        if connect_ip_type.subclass:
            return connect_ip_type.subclass(*args_, **kwargs_)
        else:
            return connect_ip_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip(self): return self.ip
    def set_ip(self, ip): self.ip = ip
    def validate_ip(self, value):
        # validate type ip
        pass
    def get_port_number(self): return self.port_number
    def set_port_number(self, port_number): self.port_number = port_number
    def validate_port_number(self, value):
        # validate type port_number
        pass
    def export(self, outfile, level, namespace_='', name_='connect_ip_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='connect_ip_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='connect_ip_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='connect_ip_type'):
        if self.ip is not None:
            showIndent(outfile, level)
            outfile.write('<%sip>%s</%sip>\n' % (namespace_, self.gds_format_string(quote_xml(self.ip).encode(ExternalEncoding), input_name='ip'), namespace_))
        if self.port_number is not None:
            showIndent(outfile, level)
            outfile.write('<%sport_number>%s</%sport_number>\n' % (namespace_, self.gds_format_string(quote_xml(self.port_number).encode(ExternalEncoding), input_name='port_number'), namespace_))
    def hasContent_(self):
        if (
            self.ip is not None or
            self.port_number is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connect_ip_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ip is not None:
            showIndent(outfile, level)
            outfile.write('ip=%s,\n' % quote_python(self.ip).encode(ExternalEncoding))
        if self.port_number is not None:
            showIndent(outfile, level)
            outfile.write('port_number=%s,\n' % quote_python(self.port_number).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'ip':
            ip_ = child_.text
            self.ip = ip_
            self.validate_ip(self.ip)    # validate type ip
        elif nodeName_ == 'port_number':
            port_number_ = child_.text
            self.port_number = port_number_
            self.validate_port_number(self.port_number)    # validate type port_number
# end class connect_ip_type


class connect_ip_api_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connect_ip=None):
        if connect_ip is None:
            self.connect_ip = []
        else:
            self.connect_ip = connect_ip
    def factory(*args_, **kwargs_):
        if connect_ip_api_type.subclass:
            return connect_ip_api_type.subclass(*args_, **kwargs_)
        else:
            return connect_ip_api_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connect_ip(self): return self.connect_ip
    def set_connect_ip(self, connect_ip): self.connect_ip = connect_ip
    def add_connect_ip(self, value): self.connect_ip.append(value)
    def insert_connect_ip(self, index, value): self.connect_ip[index] = value
    def export(self, outfile, level, namespace_='', name_='connect_ip_api_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='connect_ip_api_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='connect_ip_api_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='connect_ip_api_type'):
        for connect_ip_ in self.connect_ip:
            connect_ip_.export(outfile, level, namespace_, name_='connect_ip')
    def hasContent_(self):
        if (
            self.connect_ip
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connect_ip_api_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('connect_ip=[\n')
        level += 1
        for connect_ip_ in self.connect_ip:
            showIndent(outfile, level)
            outfile.write('model_.connect_ip_type(\n')
            connect_ip_.exportLiteral(outfile, level, name_='connect_ip_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'connect_ip': 
            obj_ = connect_ip_type.factory()
            obj_.build(child_)
            self.connect_ip.append(obj_)
# end class connect_ip_api_type


class internetconnect_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, server=None, port_number=None, user_name=None, user_password=None):
        self.server = server
        self.port_number = port_number
        self.user_name = user_name
        self.user_password = user_password
    def factory(*args_, **kwargs_):
        if internetconnect_type.subclass:
            return internetconnect_type.subclass(*args_, **kwargs_)
        else:
            return internetconnect_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_server(self): return self.server
    def set_server(self, server): self.server = server
    def validate_server(self, value):
        # validate type server
        pass
    def get_port_number(self): return self.port_number
    def set_port_number(self, port_number): self.port_number = port_number
    def validate_port_number(self, value):
        # validate type port_number
        pass
    def get_user_name(self): return self.user_name
    def set_user_name(self, user_name): self.user_name = user_name
    def validate_user_name(self, value):
        # validate type user_name
        pass
    def get_user_password(self): return self.user_password
    def set_user_password(self, user_password): self.user_password = user_password
    def validate_user_password(self, value):
        # validate type user_password
        pass
    def export(self, outfile, level, namespace_='', name_='internetconnect_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='internetconnect_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='internetconnect_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='internetconnect_type'):
        if self.server is not None:
            showIndent(outfile, level)
            outfile.write('<%sserver>%s</%sserver>\n' % (namespace_, self.gds_format_string(quote_xml(self.server).encode(ExternalEncoding), input_name='server'), namespace_))
        if self.port_number is not None:
            showIndent(outfile, level)
            outfile.write('<%sport_number>%s</%sport_number>\n' % (namespace_, self.gds_format_string(quote_xml(self.port_number).encode(ExternalEncoding), input_name='port_number'), namespace_))
        if self.user_name is not None:
            showIndent(outfile, level)
            outfile.write('<%suser_name>%s</%suser_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.user_name).encode(ExternalEncoding), input_name='user_name'), namespace_))
        if self.user_password is not None:
            showIndent(outfile, level)
            outfile.write('<%suser_password>%s</%suser_password>\n' % (namespace_, self.gds_format_string(quote_xml(self.user_password).encode(ExternalEncoding), input_name='user_password'), namespace_))
    def hasContent_(self):
        if (
            self.server is not None or
            self.port_number is not None or
            self.user_name is not None or
            self.user_password is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='internetconnect_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.server is not None:
            showIndent(outfile, level)
            outfile.write('server=%s,\n' % quote_python(self.server).encode(ExternalEncoding))
        if self.port_number is not None:
            showIndent(outfile, level)
            outfile.write('port_number=%s,\n' % quote_python(self.port_number).encode(ExternalEncoding))
        if self.user_name is not None:
            showIndent(outfile, level)
            outfile.write('user_name=%s,\n' % quote_python(self.user_name).encode(ExternalEncoding))
        if self.user_password is not None:
            showIndent(outfile, level)
            outfile.write('user_password=%s,\n' % quote_python(self.user_password).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'server':
            server_ = child_.text
            self.server = server_
            self.validate_server(self.server)    # validate type server
        elif nodeName_ == 'port_number':
            port_number_ = child_.text
            self.port_number = port_number_
            self.validate_port_number(self.port_number)    # validate type port_number
        elif nodeName_ == 'user_name':
            user_name_ = child_.text
            self.user_name = user_name_
            self.validate_user_name(self.user_name)    # validate type user_name
        elif nodeName_ == 'user_password':
            user_password_ = child_.text
            self.user_password = user_password_
            self.validate_user_password(self.user_password)    # validate type user_password
# end class internetconnect_type


class internetconnect_api_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, internetconnect=None):
        if internetconnect is None:
            self.internetconnect = []
        else:
            self.internetconnect = internetconnect
    def factory(*args_, **kwargs_):
        if internetconnect_api_type.subclass:
            return internetconnect_api_type.subclass(*args_, **kwargs_)
        else:
            return internetconnect_api_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_internetconnect(self): return self.internetconnect
    def set_internetconnect(self, internetconnect): self.internetconnect = internetconnect
    def add_internetconnect(self, value): self.internetconnect.append(value)
    def insert_internetconnect(self, index, value): self.internetconnect[index] = value
    def export(self, outfile, level, namespace_='', name_='internetconnect_api_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='internetconnect_api_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='internetconnect_api_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='internetconnect_api_type'):
        for internetconnect_ in self.internetconnect:
            internetconnect_.export(outfile, level, namespace_, name_='internetconnect')
    def hasContent_(self):
        if (
            self.internetconnect
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='internetconnect_api_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('internetconnect=[\n')
        level += 1
        for internetconnect_ in self.internetconnect:
            showIndent(outfile, level)
            outfile.write('model_.internetconnect_type(\n')
            internetconnect_.exportLiteral(outfile, level, name_='internetconnect_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'internetconnect': 
            obj_ = internetconnect_type.factory()
            obj_.build(child_)
            self.internetconnect.append(obj_)
# end class internetconnect_api_type


class getrequests_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, request=None):
        if request is None:
            self.request = []
        else:
            self.request = request
    def factory(*args_, **kwargs_):
        if getrequests_type.subclass:
            return getrequests_type.subclass(*args_, **kwargs_)
        else:
            return getrequests_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_request(self): return self.request
    def set_request(self, request): self.request = request
    def add_request(self, value): self.request.append(value)
    def insert_request(self, index, value): self.request[index] = value
    def validate_request(self, value):
        # validate type request
        pass
    def export(self, outfile, level, namespace_='', name_='getrequests_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='getrequests_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='getrequests_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='getrequests_type'):
        for request_ in self.request:
            showIndent(outfile, level)
            outfile.write('<%srequest>%s</%srequest>\n' % (namespace_, self.gds_format_string(quote_xml(request_).encode(ExternalEncoding), input_name='request'), namespace_))
    def hasContent_(self):
        if (
            self.request
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='getrequests_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('request=[\n')
        level += 1
        for request_ in self.request:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(request_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'request':
            request_ = child_.text
            self.request.append(request_)
            self.validate_request(self.request)    # validate type request
# end class getrequests_type


class urls_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, url=None):
        if url is None:
            self.url = []
        else:
            self.url = url
    def factory(*args_, **kwargs_):
        if urls_type.subclass:
            return urls_type.subclass(*args_, **kwargs_)
        else:
            return urls_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def add_url(self, value): self.url.append(value)
    def insert_url(self, index, value): self.url[index] = value
    def validate_url(self, value):
        # validate type url
        pass
    def export(self, outfile, level, namespace_='', name_='urls_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='urls_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='urls_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='urls_type'):
        for url_ in self.url:
            showIndent(outfile, level)
            outfile.write('<%surl>%s</%surl>\n' % (namespace_, self.gds_format_string(quote_xml(url_).encode(ExternalEncoding), input_name='url'), namespace_))
    def hasContent_(self):
        if (
            self.url
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='urls_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('url=[\n')
        level += 1
        for url_ in self.url:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(url_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'url':
            url_ = child_.text
            self.url.append(url_)
            self.validate_url(self.url)    # validate type url
# end class urls_type


class urldownloadtofile_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, url=None, filename=None):
        self.url = url
        self.filename = filename
    def factory(*args_, **kwargs_):
        if urldownloadtofile_type.subclass:
            return urldownloadtofile_type.subclass(*args_, **kwargs_)
        else:
            return urldownloadtofile_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def validate_url(self, value):
        # validate type url
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def export(self, outfile, level, namespace_='', name_='urldownloadtofile_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='urldownloadtofile_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='urldownloadtofile_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='urldownloadtofile_type'):
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('<%surl>%s</%surl>\n' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.gds_format_string(quote_xml(self.filename).encode(ExternalEncoding), input_name='filename'), namespace_))
    def hasContent_(self):
        if (
            self.url is not None or
            self.filename is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='urldownloadtofile_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('url=%s,\n' % quote_python(self.url).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'url':
            url_ = child_.text
            self.url = url_
            self.validate_url(self.url)    # validate type url
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
# end class urldownloadtofile_type


class urldownloadtofile_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, urldownloadtofile=None):
        if urldownloadtofile is None:
            self.urldownloadtofile = []
        else:
            self.urldownloadtofile = urldownloadtofile
    def factory(*args_, **kwargs_):
        if urldownloadtofile_collection_type.subclass:
            return urldownloadtofile_collection_type.subclass(*args_, **kwargs_)
        else:
            return urldownloadtofile_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_urldownloadtofile(self): return self.urldownloadtofile
    def set_urldownloadtofile(self, urldownloadtofile): self.urldownloadtofile = urldownloadtofile
    def add_urldownloadtofile(self, value): self.urldownloadtofile.append(value)
    def insert_urldownloadtofile(self, index, value): self.urldownloadtofile[index] = value
    def export(self, outfile, level, namespace_='', name_='urldownloadtofile_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='urldownloadtofile_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='urldownloadtofile_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='urldownloadtofile_collection_type'):
        for urldownloadtofile_ in self.urldownloadtofile:
            urldownloadtofile_.export(outfile, level, namespace_, name_='urldownloadtofile')
    def hasContent_(self):
        if (
            self.urldownloadtofile
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='urldownloadtofile_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('urldownloadtofile=[\n')
        level += 1
        for urldownloadtofile_ in self.urldownloadtofile:
            showIndent(outfile, level)
            outfile.write('model_.urldownloadtofile_type(\n')
            urldownloadtofile_.exportLiteral(outfile, level, name_='urldownloadtofile_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'urldownloadtofile': 
            obj_ = urldownloadtofile_type.factory()
            obj_.build(child_)
            self.urldownloadtofile.append(obj_)
# end class urldownloadtofile_collection_type


class urldownloadtofile_api_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, urldownloadtofile_collection=None, notes_collection=None):
        self.urldownloadtofile_collection = urldownloadtofile_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if urldownloadtofile_api_type.subclass:
            return urldownloadtofile_api_type.subclass(*args_, **kwargs_)
        else:
            return urldownloadtofile_api_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_urldownloadtofile_collection(self): return self.urldownloadtofile_collection
    def set_urldownloadtofile_collection(self, urldownloadtofile_collection): self.urldownloadtofile_collection = urldownloadtofile_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='urldownloadtofile_api_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='urldownloadtofile_api_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='urldownloadtofile_api_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='urldownloadtofile_api_type'):
        if self.urldownloadtofile_collection:
            self.urldownloadtofile_collection.export(outfile, level, namespace_, name_='urldownloadtofile_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.urldownloadtofile_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='urldownloadtofile_api_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.urldownloadtofile_collection is not None:
            showIndent(outfile, level)
            outfile.write('urldownloadtofile_collection=model_.urldownloadtofile_collection_type(\n')
            self.urldownloadtofile_collection.exportLiteral(outfile, level, name_='urldownloadtofile_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'urldownloadtofile_collection': 
            obj_ = urldownloadtofile_collection_type.factory()
            obj_.build(child_)
            self.set_urldownloadtofile_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class urldownloadtofile_api_type


class setwindowshook_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, module_filename=None, export=None):
        self.module_filename = module_filename
        self.export = export
    def factory(*args_, **kwargs_):
        if setwindowshook_type.subclass:
            return setwindowshook_type.subclass(*args_, **kwargs_)
        else:
            return setwindowshook_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_module_filename(self): return self.module_filename
    def set_module_filename(self, module_filename): self.module_filename = module_filename
    def validate_module_filename(self, value):
        # validate type module_filename
        pass
    def get_export(self): return self.export
    def set_export(self, export): self.export = export
    def validate_export(self, value):
        # validate type export
        pass
    def export(self, outfile, level, namespace_='', name_='setwindowshook_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='setwindowshook_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='setwindowshook_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='setwindowshook_type'):
        if self.module_filename is not None:
            showIndent(outfile, level)
            outfile.write('<%smodule_filename>%s</%smodule_filename>\n' % (namespace_, self.gds_format_string(quote_xml(self.module_filename).encode(ExternalEncoding), input_name='module_filename'), namespace_))
        if self.export is not None:
            showIndent(outfile, level)
            outfile.write('<%sexport>%s</%sexport>\n' % (namespace_, self.gds_format_string(quote_xml(self.export).encode(ExternalEncoding), input_name='export'), namespace_))
    def hasContent_(self):
        if (
            self.module_filename is not None or
            self.export is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='setwindowshook_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.module_filename is not None:
            showIndent(outfile, level)
            outfile.write('module_filename=%s,\n' % quote_python(self.module_filename).encode(ExternalEncoding))
        if self.export is not None:
            showIndent(outfile, level)
            outfile.write('export=%s,\n' % quote_python(self.export).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'module_filename':
            module_filename_ = child_.text
            self.module_filename = module_filename_
            self.validate_module_filename(self.module_filename)    # validate type module_filename
        elif nodeName_ == 'export':
            export_ = child_.text
            self.export = export_
            self.validate_export(self.export)    # validate type export
# end class setwindowshook_type


class setwindowshook_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, setwindowshook=None):
        if setwindowshook is None:
            self.setwindowshook = []
        else:
            self.setwindowshook = setwindowshook
    def factory(*args_, **kwargs_):
        if setwindowshook_collection_type.subclass:
            return setwindowshook_collection_type.subclass(*args_, **kwargs_)
        else:
            return setwindowshook_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_setwindowshook(self): return self.setwindowshook
    def set_setwindowshook(self, setwindowshook): self.setwindowshook = setwindowshook
    def add_setwindowshook(self, value): self.setwindowshook.append(value)
    def insert_setwindowshook(self, index, value): self.setwindowshook[index] = value
    def export(self, outfile, level, namespace_='', name_='setwindowshook_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='setwindowshook_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='setwindowshook_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='setwindowshook_collection_type'):
        for setwindowshook_ in self.setwindowshook:
            setwindowshook_.export(outfile, level, namespace_, name_='setwindowshook')
    def hasContent_(self):
        if (
            self.setwindowshook
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='setwindowshook_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('setwindowshook=[\n')
        level += 1
        for setwindowshook_ in self.setwindowshook:
            showIndent(outfile, level)
            outfile.write('model_.setwindowshook_type(\n')
            setwindowshook_.exportLiteral(outfile, level, name_='setwindowshook_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'setwindowshook': 
            obj_ = setwindowshook_type.factory()
            obj_.build(child_)
            self.setwindowshook.append(obj_)
# end class setwindowshook_collection_type


class setwindowshook_api_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, setwindowshook_collection=None, notes_collection=None):
        self.setwindowshook_collection = setwindowshook_collection
        self.notes_collection = notes_collection
    def factory(*args_, **kwargs_):
        if setwindowshook_api_type.subclass:
            return setwindowshook_api_type.subclass(*args_, **kwargs_)
        else:
            return setwindowshook_api_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_setwindowshook_collection(self): return self.setwindowshook_collection
    def set_setwindowshook_collection(self, setwindowshook_collection): self.setwindowshook_collection = setwindowshook_collection
    def get_notes_collection(self): return self.notes_collection
    def set_notes_collection(self, notes_collection): self.notes_collection = notes_collection
    def export(self, outfile, level, namespace_='', name_='setwindowshook_api_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='setwindowshook_api_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='setwindowshook_api_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='setwindowshook_api_type'):
        if self.setwindowshook_collection:
            self.setwindowshook_collection.export(outfile, level, namespace_, name_='setwindowshook_collection', )
        if self.notes_collection:
            self.notes_collection.export(outfile, level, namespace_, name_='notes_collection')
    def hasContent_(self):
        if (
            self.setwindowshook_collection is not None or
            self.notes_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='setwindowshook_api_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.setwindowshook_collection is not None:
            showIndent(outfile, level)
            outfile.write('setwindowshook_collection=model_.setwindowshook_collection_type(\n')
            self.setwindowshook_collection.exportLiteral(outfile, level, name_='setwindowshook_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes_collection is not None:
            showIndent(outfile, level)
            outfile.write('notes_collection=model_.notes_collection_type(\n')
            self.notes_collection.exportLiteral(outfile, level, name_='notes_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'setwindowshook_collection': 
            obj_ = setwindowshook_collection_type.factory()
            obj_.build(child_)
            self.set_setwindowshook_collection(obj_)
        elif nodeName_ == 'notes_collection': 
            obj_ = notes_collection_type.factory()
            obj_.build(child_)
            self.set_notes_collection(obj_)
# end class setwindowshook_api_type


class wnetaddconnection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, remote_name=None, resource_type=None, local_name=None, user_name=None, user_password=None):
        self.remote_name = remote_name
        self.resource_type = resource_type
        self.local_name = local_name
        self.user_name = user_name
        self.user_password = user_password
    def factory(*args_, **kwargs_):
        if wnetaddconnection_type.subclass:
            return wnetaddconnection_type.subclass(*args_, **kwargs_)
        else:
            return wnetaddconnection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_remote_name(self): return self.remote_name
    def set_remote_name(self, remote_name): self.remote_name = remote_name
    def validate_remote_name(self, value):
        # validate type remote_name
        pass
    def get_resource_type(self): return self.resource_type
    def set_resource_type(self, resource_type): self.resource_type = resource_type
    def validate_resource_type(self, value):
        # validate type resource_type
        pass
    def get_local_name(self): return self.local_name
    def set_local_name(self, local_name): self.local_name = local_name
    def validate_local_name(self, value):
        # validate type local_name
        pass
    def get_user_name(self): return self.user_name
    def set_user_name(self, user_name): self.user_name = user_name
    def validate_user_name(self, value):
        # validate type user_name
        pass
    def get_user_password(self): return self.user_password
    def set_user_password(self, user_password): self.user_password = user_password
    def validate_user_password(self, value):
        # validate type user_password
        pass
    def export(self, outfile, level, namespace_='', name_='wnetaddconnection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wnetaddconnection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='wnetaddconnection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='wnetaddconnection_type'):
        if self.remote_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sremote_name>%s</%sremote_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.remote_name).encode(ExternalEncoding), input_name='remote_name'), namespace_))
        if self.resource_type is not None:
            showIndent(outfile, level)
            outfile.write('<%sresource_type>%s</%sresource_type>\n' % (namespace_, self.gds_format_string(quote_xml(self.resource_type).encode(ExternalEncoding), input_name='resource_type'), namespace_))
        if self.local_name is not None:
            showIndent(outfile, level)
            outfile.write('<%slocal_name>%s</%slocal_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.local_name).encode(ExternalEncoding), input_name='local_name'), namespace_))
        if self.user_name is not None:
            showIndent(outfile, level)
            outfile.write('<%suser_name>%s</%suser_name>\n' % (namespace_, self.gds_format_string(quote_xml(self.user_name).encode(ExternalEncoding), input_name='user_name'), namespace_))
        if self.user_password is not None:
            showIndent(outfile, level)
            outfile.write('<%suser_password>%s</%suser_password>\n' % (namespace_, self.gds_format_string(quote_xml(self.user_password).encode(ExternalEncoding), input_name='user_password'), namespace_))
    def hasContent_(self):
        if (
            self.remote_name is not None or
            self.resource_type is not None or
            self.local_name is not None or
            self.user_name is not None or
            self.user_password is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wnetaddconnection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.remote_name is not None:
            showIndent(outfile, level)
            outfile.write('remote_name=%s,\n' % quote_python(self.remote_name).encode(ExternalEncoding))
        if self.resource_type is not None:
            showIndent(outfile, level)
            outfile.write('resource_type=%s,\n' % quote_python(self.resource_type).encode(ExternalEncoding))
        if self.local_name is not None:
            showIndent(outfile, level)
            outfile.write('local_name=%s,\n' % quote_python(self.local_name).encode(ExternalEncoding))
        if self.user_name is not None:
            showIndent(outfile, level)
            outfile.write('user_name=%s,\n' % quote_python(self.user_name).encode(ExternalEncoding))
        if self.user_password is not None:
            showIndent(outfile, level)
            outfile.write('user_password=%s,\n' % quote_python(self.user_password).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'remote_name':
            remote_name_ = child_.text
            self.remote_name = remote_name_
            self.validate_remote_name(self.remote_name)    # validate type remote_name
        elif nodeName_ == 'resource_type':
            resource_type_ = child_.text
            self.resource_type = resource_type_
            self.validate_resource_type(self.resource_type)    # validate type resource_type
        elif nodeName_ == 'local_name':
            local_name_ = child_.text
            self.local_name = local_name_
            self.validate_local_name(self.local_name)    # validate type local_name
        elif nodeName_ == 'user_name':
            user_name_ = child_.text
            self.user_name = user_name_
            self.validate_user_name(self.user_name)    # validate type user_name
        elif nodeName_ == 'user_password':
            user_password_ = child_.text
            self.user_password = user_password_
            self.validate_user_password(self.user_password)    # validate type user_password
# end class wnetaddconnection_type


class wnetaddconnection_api_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, wnetaddconnection=None):
        if wnetaddconnection is None:
            self.wnetaddconnection = []
        else:
            self.wnetaddconnection = wnetaddconnection
    def factory(*args_, **kwargs_):
        if wnetaddconnection_api_type.subclass:
            return wnetaddconnection_api_type.subclass(*args_, **kwargs_)
        else:
            return wnetaddconnection_api_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_wnetaddconnection(self): return self.wnetaddconnection
    def set_wnetaddconnection(self, wnetaddconnection): self.wnetaddconnection = wnetaddconnection
    def add_wnetaddconnection(self, value): self.wnetaddconnection.append(value)
    def insert_wnetaddconnection(self, index, value): self.wnetaddconnection[index] = value
    def export(self, outfile, level, namespace_='', name_='wnetaddconnection_api_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wnetaddconnection_api_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='wnetaddconnection_api_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='wnetaddconnection_api_type'):
        for wnetaddconnection_ in self.wnetaddconnection:
            wnetaddconnection_.export(outfile, level, namespace_, name_='wnetaddconnection')
    def hasContent_(self):
        if (
            self.wnetaddconnection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wnetaddconnection_api_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('wnetaddconnection=[\n')
        level += 1
        for wnetaddconnection_ in self.wnetaddconnection:
            showIndent(outfile, level)
            outfile.write('model_.wnetaddconnection_type(\n')
            wnetaddconnection_.exportLiteral(outfile, level, name_='wnetaddconnection_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'wnetaddconnection': 
            obj_ = wnetaddconnection_type.factory()
            obj_.build(child_)
            self.wnetaddconnection.append(obj_)
# end class wnetaddconnection_api_type


class irc_traffic_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, command=None):
        if command is None:
            self.command = []
        else:
            self.command = command
    def factory(*args_, **kwargs_):
        if irc_traffic_type.subclass:
            return irc_traffic_type.subclass(*args_, **kwargs_)
        else:
            return irc_traffic_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_command(self): return self.command
    def set_command(self, command): self.command = command
    def add_command(self, value): self.command.append(value)
    def insert_command(self, index, value): self.command[index] = value
    def validate_command(self, value):
        # validate type command
        pass
    def export(self, outfile, level, namespace_='', name_='irc_traffic_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='irc_traffic_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='irc_traffic_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='irc_traffic_type'):
        for command_ in self.command:
            showIndent(outfile, level)
            outfile.write('<%scommand>%s</%scommand>\n' % (namespace_, self.gds_format_string(quote_xml(command_).encode(ExternalEncoding), input_name='command'), namespace_))
    def hasContent_(self):
        if (
            self.command
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='irc_traffic_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('command=[\n')
        level += 1
        for command_ in self.command:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(command_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'command':
            command_ = child_.text
            self.command.append(command_)
            self.validate_command(self.command)    # validate type command
# end class irc_traffic_type


class textlines_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, textline=None):
        if textline is None:
            self.textline = []
        else:
            self.textline = textline
    def factory(*args_, **kwargs_):
        if textlines_collection_type.subclass:
            return textlines_collection_type.subclass(*args_, **kwargs_)
        else:
            return textlines_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_textline(self): return self.textline
    def set_textline(self, textline): self.textline = textline
    def add_textline(self, value): self.textline.append(value)
    def insert_textline(self, index, value): self.textline[index] = value
    def validate_textline(self, value):
        # validate type textline
        pass
    def export(self, outfile, level, namespace_='', name_='textlines_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='textlines_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='textlines_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='textlines_collection_type'):
        for textline_ in self.textline:
            showIndent(outfile, level)
            outfile.write('<%stextline>%s</%stextline>\n' % (namespace_, self.gds_format_string(quote_xml(textline_).encode(ExternalEncoding), input_name='textline'), namespace_))
    def hasContent_(self):
        if (
            self.textline
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='textlines_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('textline=[\n')
        level += 1
        for textline_ in self.textline:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(textline_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'textline':
            textline_ = child_.text
            self.textline.append(textline_)
            self.validate_textline(self.textline)    # validate type textline
# end class textlines_collection_type


class outbound_traffic_element_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, port_number=None, textlines_collection=None):
        self.port_number = port_number
        self.textlines_collection = textlines_collection
    def factory(*args_, **kwargs_):
        if outbound_traffic_element_type.subclass:
            return outbound_traffic_element_type.subclass(*args_, **kwargs_)
        else:
            return outbound_traffic_element_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port_number(self): return self.port_number
    def set_port_number(self, port_number): self.port_number = port_number
    def validate_port_number(self, value):
        # validate type port_number
        pass
    def get_textlines_collection(self): return self.textlines_collection
    def set_textlines_collection(self, textlines_collection): self.textlines_collection = textlines_collection
    def export(self, outfile, level, namespace_='', name_='outbound_traffic_element_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='outbound_traffic_element_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='outbound_traffic_element_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='outbound_traffic_element_type'):
        if self.port_number is not None:
            showIndent(outfile, level)
            outfile.write('<%sport_number>%s</%sport_number>\n' % (namespace_, self.gds_format_string(quote_xml(self.port_number).encode(ExternalEncoding), input_name='port_number'), namespace_))
        if self.textlines_collection:
            self.textlines_collection.export(outfile, level, namespace_, name_='textlines_collection', )
    def hasContent_(self):
        if (
            self.port_number is not None or
            self.textlines_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='outbound_traffic_element_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.port_number is not None:
            showIndent(outfile, level)
            outfile.write('port_number=%s,\n' % quote_python(self.port_number).encode(ExternalEncoding))
        if self.textlines_collection is not None:
            showIndent(outfile, level)
            outfile.write('textlines_collection=model_.textlines_collection_type(\n')
            self.textlines_collection.exportLiteral(outfile, level, name_='textlines_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'port_number':
            port_number_ = child_.text
            self.port_number = port_number_
            self.validate_port_number(self.port_number)    # validate type port_number
        elif nodeName_ == 'textlines_collection': 
            obj_ = textlines_collection_type.factory()
            obj_.build(child_)
            self.set_textlines_collection(obj_)
# end class outbound_traffic_element_type


class outbound_traffic_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, outbound_traffic_element=None):
        if outbound_traffic_element is None:
            self.outbound_traffic_element = []
        else:
            self.outbound_traffic_element = outbound_traffic_element
    def factory(*args_, **kwargs_):
        if outbound_traffic_type.subclass:
            return outbound_traffic_type.subclass(*args_, **kwargs_)
        else:
            return outbound_traffic_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_outbound_traffic_element(self): return self.outbound_traffic_element
    def set_outbound_traffic_element(self, outbound_traffic_element): self.outbound_traffic_element = outbound_traffic_element
    def add_outbound_traffic_element(self, value): self.outbound_traffic_element.append(value)
    def insert_outbound_traffic_element(self, index, value): self.outbound_traffic_element[index] = value
    def export(self, outfile, level, namespace_='', name_='outbound_traffic_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='outbound_traffic_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='outbound_traffic_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='outbound_traffic_type'):
        for outbound_traffic_element_ in self.outbound_traffic_element:
            outbound_traffic_element_.export(outfile, level, namespace_, name_='outbound_traffic_element')
    def hasContent_(self):
        if (
            self.outbound_traffic_element
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='outbound_traffic_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('outbound_traffic_element=[\n')
        level += 1
        for outbound_traffic_element_ in self.outbound_traffic_element:
            showIndent(outfile, level)
            outfile.write('model_.outbound_traffic_element_type(\n')
            outbound_traffic_element_.exportLiteral(outfile, level, name_='outbound_traffic_element_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'outbound_traffic_element': 
            obj_ = outbound_traffic_element_type.factory()
            obj_.build(child_)
            self.outbound_traffic_element.append(obj_)
# end class outbound_traffic_type


class procnames_to_terminate_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, procname=None):
        if procname is None:
            self.procname = []
        else:
            self.procname = procname
    def factory(*args_, **kwargs_):
        if procnames_to_terminate_type.subclass:
            return procnames_to_terminate_type.subclass(*args_, **kwargs_)
        else:
            return procnames_to_terminate_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_procname(self): return self.procname
    def set_procname(self, procname): self.procname = procname
    def add_procname(self, value): self.procname.append(value)
    def insert_procname(self, index, value): self.procname[index] = value
    def validate_procname(self, value):
        # validate type procname
        pass
    def export(self, outfile, level, namespace_='', name_='procnames_to_terminate_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='procnames_to_terminate_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='procnames_to_terminate_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procnames_to_terminate_type'):
        for procname_ in self.procname:
            showIndent(outfile, level)
            outfile.write('<%sprocname>%s</%sprocname>\n' % (namespace_, self.gds_format_string(quote_xml(procname_).encode(ExternalEncoding), input_name='procname'), namespace_))
    def hasContent_(self):
        if (
            self.procname
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='procnames_to_terminate_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('procname=[\n')
        level += 1
        for procname_ in self.procname:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(procname_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'procname':
            procname_ = child_.text
            self.procname.append(procname_)
            self.validate_procname(self.procname)    # validate type procname
# end class procnames_to_terminate_type


class extensions_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extension=None):
        if extension is None:
            self.extension = []
        else:
            self.extension = extension
    def factory(*args_, **kwargs_):
        if extensions_type.subclass:
            return extensions_type.subclass(*args_, **kwargs_)
        else:
            return extensions_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def add_extension(self, value): self.extension.append(value)
    def insert_extension(self, index, value): self.extension[index] = value
    def validate_extension(self, value):
        # validate type extension
        pass
    def export(self, outfile, level, namespace_='', name_='extensions_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='extensions_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='extensions_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='extensions_type'):
        for extension_ in self.extension:
            showIndent(outfile, level)
            outfile.write('<%sextension>%s</%sextension>\n' % (namespace_, self.gds_format_string(quote_xml(extension_).encode(ExternalEncoding), input_name='extension'), namespace_))
    def hasContent_(self):
        if (
            self.extension
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='extensions_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('extension=[\n')
        level += 1
        for extension_ in self.extension:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(extension_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'extension':
            extension_ = child_.text
            self.extension.append(extension_)
            self.validate_extension(self.extension)    # validate type extension
# end class extensions_type


class excluded_email_addresses_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, email_part=None):
        if email_part is None:
            self.email_part = []
        else:
            self.email_part = email_part
    def factory(*args_, **kwargs_):
        if excluded_email_addresses_type.subclass:
            return excluded_email_addresses_type.subclass(*args_, **kwargs_)
        else:
            return excluded_email_addresses_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_email_part(self): return self.email_part
    def set_email_part(self, email_part): self.email_part = email_part
    def add_email_part(self, value): self.email_part.append(value)
    def insert_email_part(self, index, value): self.email_part[index] = value
    def validate_email_part(self, value):
        # validate type email_part
        pass
    def export(self, outfile, level, namespace_='', name_='excluded_email_addresses_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='excluded_email_addresses_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='excluded_email_addresses_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='excluded_email_addresses_type'):
        for email_part_ in self.email_part:
            showIndent(outfile, level)
            outfile.write('<%semail_part>%s</%semail_part>\n' % (namespace_, self.gds_format_string(quote_xml(email_part_).encode(ExternalEncoding), input_name='email_part'), namespace_))
    def hasContent_(self):
        if (
            self.email_part
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='excluded_email_addresses_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('email_part=[\n')
        level += 1
        for email_part_ in self.email_part:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(email_part_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'email_part':
            email_part_ = child_.text
            self.email_part.append(email_part_)
            self.validate_email_part(self.email_part)    # validate type email_part
# end class excluded_email_addresses_type


class share_probes_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, share=None):
        if share is None:
            self.share = []
        else:
            self.share = share
    def factory(*args_, **kwargs_):
        if share_probes_type.subclass:
            return share_probes_type.subclass(*args_, **kwargs_)
        else:
            return share_probes_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_share(self): return self.share
    def set_share(self, share): self.share = share
    def add_share(self, value): self.share.append(value)
    def insert_share(self, index, value): self.share[index] = value
    def validate_share(self, value):
        # validate type share
        pass
    def export(self, outfile, level, namespace_='', name_='share_probes_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='share_probes_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='share_probes_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='share_probes_type'):
        for share_ in self.share:
            showIndent(outfile, level)
            outfile.write('<%sshare>%s</%sshare>\n' % (namespace_, self.gds_format_string(quote_xml(share_).encode(ExternalEncoding), input_name='share'), namespace_))
    def hasContent_(self):
        if (
            self.share
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='share_probes_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('share=[\n')
        level += 1
        for share_ in self.share:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(share_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'share':
            share_ = child_.text
            self.share.append(share_)
            self.validate_share(self.share)    # validate type share
# end class share_probes_type


class share_logins_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, login=None):
        if login is None:
            self.login = []
        else:
            self.login = login
    def factory(*args_, **kwargs_):
        if share_logins_type.subclass:
            return share_logins_type.subclass(*args_, **kwargs_)
        else:
            return share_logins_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_login(self): return self.login
    def set_login(self, login): self.login = login
    def add_login(self, value): self.login.append(value)
    def insert_login(self, index, value): self.login[index] = value
    def validate_login(self, value):
        # validate type login
        pass
    def export(self, outfile, level, namespace_='', name_='share_logins_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='share_logins_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='share_logins_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='share_logins_type'):
        for login_ in self.login:
            showIndent(outfile, level)
            outfile.write('<%slogin>%s</%slogin>\n' % (namespace_, self.gds_format_string(quote_xml(login_).encode(ExternalEncoding), input_name='login'), namespace_))
    def hasContent_(self):
        if (
            self.login
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='share_logins_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('login=[\n')
        level += 1
        for login_ in self.login:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(login_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'login':
            login_ = child_.text
            self.login.append(login_)
            self.validate_login(self.login)    # validate type login
# end class share_logins_type


class bits_downloads_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bits_download=None):
        if bits_download is None:
            self.bits_download = []
        else:
            self.bits_download = bits_download
    def factory(*args_, **kwargs_):
        if bits_downloads_type.subclass:
            return bits_downloads_type.subclass(*args_, **kwargs_)
        else:
            return bits_downloads_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bits_download(self): return self.bits_download
    def set_bits_download(self, bits_download): self.bits_download = bits_download
    def add_bits_download(self, value): self.bits_download.append(value)
    def insert_bits_download(self, index, value): self.bits_download[index] = value
    def validate_bits_download(self, value):
        # validate type bits_download
        pass
    def export(self, outfile, level, namespace_='', name_='bits_downloads_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='bits_downloads_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='bits_downloads_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='bits_downloads_type'):
        for bits_download_ in self.bits_download:
            showIndent(outfile, level)
            outfile.write('<%sbits_download>%s</%sbits_download>\n' % (namespace_, self.gds_format_string(quote_xml(bits_download_).encode(ExternalEncoding), input_name='bits_download'), namespace_))
    def hasContent_(self):
        if (
            self.bits_download
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='bits_downloads_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bits_download=[\n')
        level += 1
        for bits_download_ in self.bits_download:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(bits_download_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'bits_download':
            bits_download_ = child_.text
            self.bits_download.append(bits_download_)
            self.validate_bits_download(self.bits_download)    # validate type bits_download
# end class bits_downloads_type


class botnet_peers_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, botnet_peer=None):
        if botnet_peer is None:
            self.botnet_peer = []
        else:
            self.botnet_peer = botnet_peer
    def factory(*args_, **kwargs_):
        if botnet_peers_type.subclass:
            return botnet_peers_type.subclass(*args_, **kwargs_)
        else:
            return botnet_peers_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_botnet_peer(self): return self.botnet_peer
    def set_botnet_peer(self, botnet_peer): self.botnet_peer = botnet_peer
    def add_botnet_peer(self, value): self.botnet_peer.append(value)
    def insert_botnet_peer(self, index, value): self.botnet_peer[index] = value
    def validate_botnet_peer(self, value):
        # validate type botnet_peer
        pass
    def export(self, outfile, level, namespace_='', name_='botnet_peers_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='botnet_peers_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='botnet_peers_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='botnet_peers_type'):
        for botnet_peer_ in self.botnet_peer:
            showIndent(outfile, level)
            outfile.write('<%sbotnet_peer>%s</%sbotnet_peer>\n' % (namespace_, self.gds_format_string(quote_xml(botnet_peer_).encode(ExternalEncoding), input_name='botnet_peer'), namespace_))
    def hasContent_(self):
        if (
            self.botnet_peer
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='botnet_peers_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('botnet_peer=[\n')
        level += 1
        for botnet_peer_ in self.botnet_peer:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(botnet_peer_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'botnet_peer':
            botnet_peer_ = child_.text
            self.botnet_peer.append(botnet_peer_)
            self.validate_botnet_peer(self.botnet_peer)    # validate type botnet_peer
# end class botnet_peers_type


class firewalls_to_bypass_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, firewall_to_bypass=None):
        if firewall_to_bypass is None:
            self.firewall_to_bypass = []
        else:
            self.firewall_to_bypass = firewall_to_bypass
    def factory(*args_, **kwargs_):
        if firewalls_to_bypass_type.subclass:
            return firewalls_to_bypass_type.subclass(*args_, **kwargs_)
        else:
            return firewalls_to_bypass_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firewall_to_bypass(self): return self.firewall_to_bypass
    def set_firewall_to_bypass(self, firewall_to_bypass): self.firewall_to_bypass = firewall_to_bypass
    def add_firewall_to_bypass(self, value): self.firewall_to_bypass.append(value)
    def insert_firewall_to_bypass(self, index, value): self.firewall_to_bypass[index] = value
    def validate_firewall_to_bypass(self, value):
        # validate type firewall_to_bypass
        pass
    def export(self, outfile, level, namespace_='', name_='firewalls_to_bypass_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='firewalls_to_bypass_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='firewalls_to_bypass_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='firewalls_to_bypass_type'):
        for firewall_to_bypass_ in self.firewall_to_bypass:
            showIndent(outfile, level)
            outfile.write('<%sfirewall_to_bypass>%s</%sfirewall_to_bypass>\n' % (namespace_, self.gds_format_string(quote_xml(firewall_to_bypass_).encode(ExternalEncoding), input_name='firewall_to_bypass'), namespace_))
    def hasContent_(self):
        if (
            self.firewall_to_bypass
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='firewalls_to_bypass_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('firewall_to_bypass=[\n')
        level += 1
        for firewall_to_bypass_ in self.firewall_to_bypass:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(firewall_to_bypass_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'firewall_to_bypass':
            firewall_to_bypass_ = child_.text
            self.firewall_to_bypass.append(firewall_to_bypass_)
            self.validate_firewall_to_bypass(self.firewall_to_bypass)    # validate type firewall_to_bypass
# end class firewalls_to_bypass_type


class heur_downloads_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, heur_download=None):
        if heur_download is None:
            self.heur_download = []
        else:
            self.heur_download = heur_download
    def factory(*args_, **kwargs_):
        if heur_downloads_type.subclass:
            return heur_downloads_type.subclass(*args_, **kwargs_)
        else:
            return heur_downloads_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_heur_download(self): return self.heur_download
    def set_heur_download(self, heur_download): self.heur_download = heur_download
    def add_heur_download(self, value): self.heur_download.append(value)
    def insert_heur_download(self, index, value): self.heur_download[index] = value
    def validate_heur_download(self, value):
        # validate type heur_download
        pass
    def export(self, outfile, level, namespace_='', name_='heur_downloads_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='heur_downloads_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='heur_downloads_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='heur_downloads_type'):
        for heur_download_ in self.heur_download:
            showIndent(outfile, level)
            outfile.write('<%sheur_download>%s</%sheur_download>\n' % (namespace_, self.gds_format_string(quote_xml(heur_download_).encode(ExternalEncoding), input_name='heur_download'), namespace_))
    def hasContent_(self):
        if (
            self.heur_download
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='heur_downloads_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('heur_download=[\n')
        level += 1
        for heur_download_ in self.heur_download:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(heur_download_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'heur_download':
            heur_download_ = child_.text
            self.heur_download.append(heur_download_)
            self.validate_heur_download(self.heur_download)    # validate type heur_download
# end class heur_downloads_type


class bankjet_urls_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bankjet_url=None):
        if bankjet_url is None:
            self.bankjet_url = []
        else:
            self.bankjet_url = bankjet_url
    def factory(*args_, **kwargs_):
        if bankjet_urls_type.subclass:
            return bankjet_urls_type.subclass(*args_, **kwargs_)
        else:
            return bankjet_urls_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bankjet_url(self): return self.bankjet_url
    def set_bankjet_url(self, bankjet_url): self.bankjet_url = bankjet_url
    def add_bankjet_url(self, value): self.bankjet_url.append(value)
    def insert_bankjet_url(self, index, value): self.bankjet_url[index] = value
    def validate_bankjet_url(self, value):
        # validate type bankjet_url
        pass
    def export(self, outfile, level, namespace_='', name_='bankjet_urls_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='bankjet_urls_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='bankjet_urls_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='bankjet_urls_type'):
        for bankjet_url_ in self.bankjet_url:
            showIndent(outfile, level)
            outfile.write('<%sbankjet_url>%s</%sbankjet_url>\n' % (namespace_, self.gds_format_string(quote_xml(bankjet_url_).encode(ExternalEncoding), input_name='bankjet_url'), namespace_))
    def hasContent_(self):
        if (
            self.bankjet_url
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='bankjet_urls_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bankjet_url=[\n')
        level += 1
        for bankjet_url_ in self.bankjet_url:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(bankjet_url_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'bankjet_url':
            bankjet_url_ = child_.text
            self.bankjet_url.append(bankjet_url_)
            self.validate_bankjet_url(self.bankjet_url)    # validate type bankjet_url
# end class bankjet_urls_type


class senders_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sender=None):
        if sender is None:
            self.sender = []
        else:
            self.sender = sender
    def factory(*args_, **kwargs_):
        if senders_type.subclass:
            return senders_type.subclass(*args_, **kwargs_)
        else:
            return senders_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sender(self): return self.sender
    def set_sender(self, sender): self.sender = sender
    def add_sender(self, value): self.sender.append(value)
    def insert_sender(self, index, value): self.sender[index] = value
    def validate_sender(self, value):
        # validate type sender
        pass
    def export(self, outfile, level, namespace_='', name_='senders_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='senders_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='senders_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='senders_type'):
        for sender_ in self.sender:
            showIndent(outfile, level)
            outfile.write('<%ssender>%s</%ssender>\n' % (namespace_, self.gds_format_string(quote_xml(sender_).encode(ExternalEncoding), input_name='sender'), namespace_))
    def hasContent_(self):
        if (
            self.sender
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='senders_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sender=[\n')
        level += 1
        for sender_ in self.sender:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(sender_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'sender':
            sender_ = child_.text
            self.sender.append(sender_)
            self.validate_sender(self.sender)    # validate type sender
# end class senders_type


class recipients_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, recipient=None):
        if recipient is None:
            self.recipient = []
        else:
            self.recipient = recipient
    def factory(*args_, **kwargs_):
        if recipients_type.subclass:
            return recipients_type.subclass(*args_, **kwargs_)
        else:
            return recipients_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recipient(self): return self.recipient
    def set_recipient(self, recipient): self.recipient = recipient
    def add_recipient(self, value): self.recipient.append(value)
    def insert_recipient(self, index, value): self.recipient[index] = value
    def validate_recipient(self, value):
        # validate type recipient
        pass
    def export(self, outfile, level, namespace_='', name_='recipients_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='recipients_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='recipients_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='recipients_type'):
        for recipient_ in self.recipient:
            showIndent(outfile, level)
            outfile.write('<%srecipient>%s</%srecipient>\n' % (namespace_, self.gds_format_string(quote_xml(recipient_).encode(ExternalEncoding), input_name='recipient'), namespace_))
    def hasContent_(self):
        if (
            self.recipient
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='recipients_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('recipient=[\n')
        level += 1
        for recipient_ in self.recipient:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(recipient_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'recipient':
            recipient_ = child_.text
            self.recipient.append(recipient_)
            self.validate_recipient(self.recipient)    # validate type recipient
# end class recipients_type


class subjects_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, subject=None):
        if subject is None:
            self.subject = []
        else:
            self.subject = subject
    def factory(*args_, **kwargs_):
        if subjects_type.subclass:
            return subjects_type.subclass(*args_, **kwargs_)
        else:
            return subjects_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def add_subject(self, value): self.subject.append(value)
    def insert_subject(self, index, value): self.subject[index] = value
    def validate_subject(self, value):
        # validate type subject
        pass
    def export(self, outfile, level, namespace_='', name_='subjects_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='subjects_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='subjects_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='subjects_type'):
        for subject_ in self.subject:
            showIndent(outfile, level)
            outfile.write('<%ssubject>%s</%ssubject>\n' % (namespace_, self.gds_format_string(quote_xml(subject_).encode(ExternalEncoding), input_name='subject'), namespace_))
    def hasContent_(self):
        if (
            self.subject
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subjects_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subject=[\n')
        level += 1
        for subject_ in self.subject:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(subject_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'subject':
            subject_ = child_.text
            self.subject.append(subject_)
            self.validate_subject(self.subject)    # validate type subject
# end class subjects_type


class attachments_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachment=None):
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment
    def factory(*args_, **kwargs_):
        if attachments_type.subclass:
            return attachments_type.subclass(*args_, **kwargs_)
        else:
            return attachments_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def add_attachment(self, value): self.attachment.append(value)
    def insert_attachment(self, index, value): self.attachment[index] = value
    def validate_attachment(self, value):
        # validate type attachment
        pass
    def export(self, outfile, level, namespace_='', name_='attachments_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='attachments_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='attachments_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='attachments_type'):
        for attachment_ in self.attachment:
            showIndent(outfile, level)
            outfile.write('<%sattachment>%s</%sattachment>\n' % (namespace_, self.gds_format_string(quote_xml(attachment_).encode(ExternalEncoding), input_name='attachment'), namespace_))
    def hasContent_(self):
        if (
            self.attachment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='attachments_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachment=[\n')
        level += 1
        for attachment_ in self.attachment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'attachment':
            attachment_ = child_.text
            self.attachment.append(attachment_)
            self.validate_attachment(self.attachment)    # validate type attachment
# end class attachments_type


class bodies_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, body=None):
        if body is None:
            self.body = []
        else:
            self.body = body
    def factory(*args_, **kwargs_):
        if bodies_type.subclass:
            return bodies_type.subclass(*args_, **kwargs_)
        else:
            return bodies_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_body(self): return self.body
    def set_body(self, body): self.body = body
    def add_body(self, value): self.body.append(value)
    def insert_body(self, index, value): self.body[index] = value
    def validate_body(self, value):
        # validate type body
        pass
    def export(self, outfile, level, namespace_='', name_='bodies_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='bodies_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='bodies_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='bodies_type'):
        for body_ in self.body:
            showIndent(outfile, level)
            outfile.write('<%sbody>%s</%sbody>\n' % (namespace_, self.gds_format_string(quote_xml(body_).encode(ExternalEncoding), input_name='body'), namespace_))
    def hasContent_(self):
        if (
            self.body
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='bodies_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('body=[\n')
        level += 1
        for body_ in self.body:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(body_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'body':
            body_ = child_.text
            self.body.append(body_)
            self.validate_body(self.body)    # validate type body
# end class bodies_type


class smtp_traffic_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, senders=None, recipients=None, subjects=None, attachments=None, bodies=None, smtp_gif=None):
        self.senders = senders
        self.recipients = recipients
        self.subjects = subjects
        self.attachments = attachments
        self.bodies = bodies
        self.smtp_gif = smtp_gif
    def factory(*args_, **kwargs_):
        if smtp_traffic_type.subclass:
            return smtp_traffic_type.subclass(*args_, **kwargs_)
        else:
            return smtp_traffic_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_senders(self): return self.senders
    def set_senders(self, senders): self.senders = senders
    def get_recipients(self): return self.recipients
    def set_recipients(self, recipients): self.recipients = recipients
    def get_subjects(self): return self.subjects
    def set_subjects(self, subjects): self.subjects = subjects
    def get_attachments(self): return self.attachments
    def set_attachments(self, attachments): self.attachments = attachments
    def get_bodies(self): return self.bodies
    def set_bodies(self, bodies): self.bodies = bodies
    def get_smtp_gif(self): return self.smtp_gif
    def set_smtp_gif(self, smtp_gif): self.smtp_gif = smtp_gif
    def validate_smtp_gif(self, value):
        # validate type smtp_gif
        pass
    def export(self, outfile, level, namespace_='', name_='smtp_traffic_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='smtp_traffic_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='smtp_traffic_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='smtp_traffic_type'):
        if self.senders:
            self.senders.export(outfile, level, namespace_, name_='senders')
        if self.recipients:
            self.recipients.export(outfile, level, namespace_, name_='recipients')
        if self.subjects:
            self.subjects.export(outfile, level, namespace_, name_='subjects')
        if self.attachments:
            self.attachments.export(outfile, level, namespace_, name_='attachments')
        if self.bodies:
            self.bodies.export(outfile, level, namespace_, name_='bodies')
        if self.smtp_gif is not None:
            showIndent(outfile, level)
            outfile.write('<%ssmtp_gif>%s</%ssmtp_gif>\n' % (namespace_, self.gds_format_string(quote_xml(self.smtp_gif).encode(ExternalEncoding), input_name='smtp_gif'), namespace_))
    def hasContent_(self):
        if (
            self.senders is not None or
            self.recipients is not None or
            self.subjects is not None or
            self.attachments is not None or
            self.bodies is not None or
            self.smtp_gif is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='smtp_traffic_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.senders is not None:
            showIndent(outfile, level)
            outfile.write('senders=model_.senders_type(\n')
            self.senders.exportLiteral(outfile, level, name_='senders')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.recipients is not None:
            showIndent(outfile, level)
            outfile.write('recipients=model_.recipients_type(\n')
            self.recipients.exportLiteral(outfile, level, name_='recipients')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subjects is not None:
            showIndent(outfile, level)
            outfile.write('subjects=model_.subjects_type(\n')
            self.subjects.exportLiteral(outfile, level, name_='subjects')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attachments is not None:
            showIndent(outfile, level)
            outfile.write('attachments=model_.attachments_type(\n')
            self.attachments.exportLiteral(outfile, level, name_='attachments')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bodies is not None:
            showIndent(outfile, level)
            outfile.write('bodies=model_.bodies_type(\n')
            self.bodies.exportLiteral(outfile, level, name_='bodies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.smtp_gif is not None:
            showIndent(outfile, level)
            outfile.write('smtp_gif=%s,\n' % quote_python(self.smtp_gif).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'senders': 
            obj_ = senders_type.factory()
            obj_.build(child_)
            self.set_senders(obj_)
        elif nodeName_ == 'recipients': 
            obj_ = recipients_type.factory()
            obj_.build(child_)
            self.set_recipients(obj_)
        elif nodeName_ == 'subjects': 
            obj_ = subjects_type.factory()
            obj_.build(child_)
            self.set_subjects(obj_)
        elif nodeName_ == 'attachments': 
            obj_ = attachments_type.factory()
            obj_.build(child_)
            self.set_attachments(obj_)
        elif nodeName_ == 'bodies': 
            obj_ = bodies_type.factory()
            obj_.build(child_)
            self.set_bodies(obj_)
        elif nodeName_ == 'smtp_gif':
            smtp_gif_ = child_.text
            self.smtp_gif = smtp_gif_
            self.validate_smtp_gif(self.smtp_gif)    # validate type smtp_gif
# end class smtp_traffic_type


class technical_details_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, screen_gif=None, known_threat_collection=None, known_threat_category_collection=None, added_files=None, added_hidden_files=None, added_streams=None, added_hidden_streams=None, deleted_files=None, modified_files=None, added_directories=None, added_hidden_directories=None, deleted_directories=None, added_processes=None, added_hidden_processes=None, injected_mempages=None, added_modules=None, added_services=None, modified_services=None, added_drivers=None, added_syscallhooks=None, irp_hooks=None, added_regkeys=None, added_hidden_regkeys=None, deleted_regkeys=None, added_regvalues=None, added_hidden_regvalues=None, deleted_regvalues=None, modified_regvalues=None, countries=None, mutexes=None, open_ports=None, etc_host_lines=None, gethostbyname_api=None, connect_ip_api=None, internetconnect_api=None, getrequests=None, urlrequests=None, internetopenurl_api=None, urldownloadtofile_api=None, ftpgetfile_api=None, setwindowshook_api=None, wnetaddconnection_api=None, exitwindows_api=None, irc_traffic=None, traffic_135=None, traffic_445=None, outbound_traffic=None, procnames_to_terminate=None, filestosearch=None, excluded_email_addresses=None, share_probes=None, share_logins=None, bits_downloads=None, botnet_peers=None, firewalls_to_bypass=None, heur_downloads=None, bankjet_urls=None, smtp_traffic=None):
        self.screen_gif = screen_gif
        self.known_threat_collection = known_threat_collection
        self.known_threat_category_collection = known_threat_category_collection
        self.added_files = added_files
        self.added_hidden_files = added_hidden_files
        self.added_streams = added_streams
        self.added_hidden_streams = added_hidden_streams
        self.deleted_files = deleted_files
        self.modified_files = modified_files
        self.added_directories = added_directories
        self.added_hidden_directories = added_hidden_directories
        self.deleted_directories = deleted_directories
        self.added_processes = added_processes
        self.added_hidden_processes = added_hidden_processes
        self.injected_mempages = injected_mempages
        self.added_modules = added_modules
        self.added_services = added_services
        self.modified_services = modified_services
        self.added_drivers = added_drivers
        self.added_syscallhooks = added_syscallhooks
        self.irp_hooks = irp_hooks
        self.added_regkeys = added_regkeys
        self.added_hidden_regkeys = added_hidden_regkeys
        self.deleted_regkeys = deleted_regkeys
        self.added_regvalues = added_regvalues
        self.added_hidden_regvalues = added_hidden_regvalues
        self.deleted_regvalues = deleted_regvalues
        self.modified_regvalues = modified_regvalues
        self.countries = countries
        self.mutexes = mutexes
        self.open_ports = open_ports
        self.etc_host_lines = etc_host_lines
        self.gethostbyname_api = gethostbyname_api
        self.connect_ip_api = connect_ip_api
        self.internetconnect_api = internetconnect_api
        self.getrequests = getrequests
        self.urlrequests = urlrequests
        self.internetopenurl_api = internetopenurl_api
        self.urldownloadtofile_api = urldownloadtofile_api
        self.ftpgetfile_api = ftpgetfile_api
        self.setwindowshook_api = setwindowshook_api
        self.wnetaddconnection_api = wnetaddconnection_api
        self.exitwindows_api = exitwindows_api
        self.irc_traffic = irc_traffic
        self.traffic_135 = traffic_135
        self.traffic_445 = traffic_445
        self.outbound_traffic = outbound_traffic
        self.procnames_to_terminate = procnames_to_terminate
        self.filestosearch = filestosearch
        self.excluded_email_addresses = excluded_email_addresses
        self.share_probes = share_probes
        self.share_logins = share_logins
        self.bits_downloads = bits_downloads
        self.botnet_peers = botnet_peers
        self.firewalls_to_bypass = firewalls_to_bypass
        self.heur_downloads = heur_downloads
        self.bankjet_urls = bankjet_urls
        self.smtp_traffic = smtp_traffic
    def factory(*args_, **kwargs_):
        if technical_details_type.subclass:
            return technical_details_type.subclass(*args_, **kwargs_)
        else:
            return technical_details_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_screen_gif(self): return self.screen_gif
    def set_screen_gif(self, screen_gif): self.screen_gif = screen_gif
    def validate_screen_gif(self, value):
        # validate type screen_gif
        pass
    def get_known_threat_collection(self): return self.known_threat_collection
    def set_known_threat_collection(self, known_threat_collection): self.known_threat_collection = known_threat_collection
    def get_known_threat_category_collection(self): return self.known_threat_category_collection
    def set_known_threat_category_collection(self, known_threat_category_collection): self.known_threat_category_collection = known_threat_category_collection
    def get_added_files(self): return self.added_files
    def set_added_files(self, added_files): self.added_files = added_files
    def get_added_hidden_files(self): return self.added_hidden_files
    def set_added_hidden_files(self, added_hidden_files): self.added_hidden_files = added_hidden_files
    def get_added_streams(self): return self.added_streams
    def set_added_streams(self, added_streams): self.added_streams = added_streams
    def get_added_hidden_streams(self): return self.added_hidden_streams
    def set_added_hidden_streams(self, added_hidden_streams): self.added_hidden_streams = added_hidden_streams
    def get_deleted_files(self): return self.deleted_files
    def set_deleted_files(self, deleted_files): self.deleted_files = deleted_files
    def get_modified_files(self): return self.modified_files
    def set_modified_files(self, modified_files): self.modified_files = modified_files
    def get_added_directories(self): return self.added_directories
    def set_added_directories(self, added_directories): self.added_directories = added_directories
    def get_added_hidden_directories(self): return self.added_hidden_directories
    def set_added_hidden_directories(self, added_hidden_directories): self.added_hidden_directories = added_hidden_directories
    def get_deleted_directories(self): return self.deleted_directories
    def set_deleted_directories(self, deleted_directories): self.deleted_directories = deleted_directories
    def get_added_processes(self): return self.added_processes
    def set_added_processes(self, added_processes): self.added_processes = added_processes
    def get_added_hidden_processes(self): return self.added_hidden_processes
    def set_added_hidden_processes(self, added_hidden_processes): self.added_hidden_processes = added_hidden_processes
    def get_injected_mempages(self): return self.injected_mempages
    def set_injected_mempages(self, injected_mempages): self.injected_mempages = injected_mempages
    def get_added_modules(self): return self.added_modules
    def set_added_modules(self, added_modules): self.added_modules = added_modules
    def get_added_services(self): return self.added_services
    def set_added_services(self, added_services): self.added_services = added_services
    def get_modified_services(self): return self.modified_services
    def set_modified_services(self, modified_services): self.modified_services = modified_services
    def get_added_drivers(self): return self.added_drivers
    def set_added_drivers(self, added_drivers): self.added_drivers = added_drivers
    def get_added_syscallhooks(self): return self.added_syscallhooks
    def set_added_syscallhooks(self, added_syscallhooks): self.added_syscallhooks = added_syscallhooks
    def get_irp_hooks(self): return self.irp_hooks
    def set_irp_hooks(self, irp_hooks): self.irp_hooks = irp_hooks
    def get_added_regkeys(self): return self.added_regkeys
    def set_added_regkeys(self, added_regkeys): self.added_regkeys = added_regkeys
    def get_added_hidden_regkeys(self): return self.added_hidden_regkeys
    def set_added_hidden_regkeys(self, added_hidden_regkeys): self.added_hidden_regkeys = added_hidden_regkeys
    def get_deleted_regkeys(self): return self.deleted_regkeys
    def set_deleted_regkeys(self, deleted_regkeys): self.deleted_regkeys = deleted_regkeys
    def get_added_regvalues(self): return self.added_regvalues
    def set_added_regvalues(self, added_regvalues): self.added_regvalues = added_regvalues
    def get_added_hidden_regvalues(self): return self.added_hidden_regvalues
    def set_added_hidden_regvalues(self, added_hidden_regvalues): self.added_hidden_regvalues = added_hidden_regvalues
    def get_deleted_regvalues(self): return self.deleted_regvalues
    def set_deleted_regvalues(self, deleted_regvalues): self.deleted_regvalues = deleted_regvalues
    def get_modified_regvalues(self): return self.modified_regvalues
    def set_modified_regvalues(self, modified_regvalues): self.modified_regvalues = modified_regvalues
    def get_countries(self): return self.countries
    def set_countries(self, countries): self.countries = countries
    def get_mutexes(self): return self.mutexes
    def set_mutexes(self, mutexes): self.mutexes = mutexes
    def get_open_ports(self): return self.open_ports
    def set_open_ports(self, open_ports): self.open_ports = open_ports
    def get_etc_host_lines(self): return self.etc_host_lines
    def set_etc_host_lines(self, etc_host_lines): self.etc_host_lines = etc_host_lines
    def get_gethostbyname_api(self): return self.gethostbyname_api
    def set_gethostbyname_api(self, gethostbyname_api): self.gethostbyname_api = gethostbyname_api
    def get_connect_ip_api(self): return self.connect_ip_api
    def set_connect_ip_api(self, connect_ip_api): self.connect_ip_api = connect_ip_api
    def get_internetconnect_api(self): return self.internetconnect_api
    def set_internetconnect_api(self, internetconnect_api): self.internetconnect_api = internetconnect_api
    def get_getrequests(self): return self.getrequests
    def set_getrequests(self, getrequests): self.getrequests = getrequests
    def get_urlrequests(self): return self.urlrequests
    def set_urlrequests(self, urlrequests): self.urlrequests = urlrequests
    def get_internetopenurl_api(self): return self.internetopenurl_api
    def set_internetopenurl_api(self, internetopenurl_api): self.internetopenurl_api = internetopenurl_api
    def get_urldownloadtofile_api(self): return self.urldownloadtofile_api
    def set_urldownloadtofile_api(self, urldownloadtofile_api): self.urldownloadtofile_api = urldownloadtofile_api
    def get_ftpgetfile_api(self): return self.ftpgetfile_api
    def set_ftpgetfile_api(self, ftpgetfile_api): self.ftpgetfile_api = ftpgetfile_api
    def get_setwindowshook_api(self): return self.setwindowshook_api
    def set_setwindowshook_api(self, setwindowshook_api): self.setwindowshook_api = setwindowshook_api
    def get_wnetaddconnection_api(self): return self.wnetaddconnection_api
    def set_wnetaddconnection_api(self, wnetaddconnection_api): self.wnetaddconnection_api = wnetaddconnection_api
    def get_exitwindows_api(self): return self.exitwindows_api
    def set_exitwindows_api(self, exitwindows_api): self.exitwindows_api = exitwindows_api
    def validate_exitwindows_api(self, value):
        # validate type exitwindows_api
        pass
    def get_irc_traffic(self): return self.irc_traffic
    def set_irc_traffic(self, irc_traffic): self.irc_traffic = irc_traffic
    def get_traffic_135(self): return self.traffic_135
    def set_traffic_135(self, traffic_135): self.traffic_135 = traffic_135
    def validate_traffic_135(self, value):
        # validate type traffic_135
        pass
    def get_traffic_445(self): return self.traffic_445
    def set_traffic_445(self, traffic_445): self.traffic_445 = traffic_445
    def validate_traffic_445(self, value):
        # validate type traffic_445
        pass
    def get_outbound_traffic(self): return self.outbound_traffic
    def set_outbound_traffic(self, outbound_traffic): self.outbound_traffic = outbound_traffic
    def get_procnames_to_terminate(self): return self.procnames_to_terminate
    def set_procnames_to_terminate(self, procnames_to_terminate): self.procnames_to_terminate = procnames_to_terminate
    def get_filestosearch(self): return self.filestosearch
    def set_filestosearch(self, filestosearch): self.filestosearch = filestosearch
    def get_excluded_email_addresses(self): return self.excluded_email_addresses
    def set_excluded_email_addresses(self, excluded_email_addresses): self.excluded_email_addresses = excluded_email_addresses
    def get_share_probes(self): return self.share_probes
    def set_share_probes(self, share_probes): self.share_probes = share_probes
    def get_share_logins(self): return self.share_logins
    def set_share_logins(self, share_logins): self.share_logins = share_logins
    def get_bits_downloads(self): return self.bits_downloads
    def set_bits_downloads(self, bits_downloads): self.bits_downloads = bits_downloads
    def get_botnet_peers(self): return self.botnet_peers
    def set_botnet_peers(self, botnet_peers): self.botnet_peers = botnet_peers
    def get_firewalls_to_bypass(self): return self.firewalls_to_bypass
    def set_firewalls_to_bypass(self, firewalls_to_bypass): self.firewalls_to_bypass = firewalls_to_bypass
    def get_heur_downloads(self): return self.heur_downloads
    def set_heur_downloads(self, heur_downloads): self.heur_downloads = heur_downloads
    def get_bankjet_urls(self): return self.bankjet_urls
    def set_bankjet_urls(self, bankjet_urls): self.bankjet_urls = bankjet_urls
    def get_smtp_traffic(self): return self.smtp_traffic
    def set_smtp_traffic(self, smtp_traffic): self.smtp_traffic = smtp_traffic
    def export(self, outfile, level, namespace_='', name_='technical_details_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='technical_details_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='technical_details_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='technical_details_type'):
        if self.screen_gif is not None:
            showIndent(outfile, level)
            outfile.write('<%sscreen_gif>%s</%sscreen_gif>\n' % (namespace_, self.gds_format_string(quote_xml(self.screen_gif).encode(ExternalEncoding), input_name='screen_gif'), namespace_))
        if self.known_threat_collection:
            self.known_threat_collection.export(outfile, level, namespace_, name_='known_threat_collection')
        if self.known_threat_category_collection:
            self.known_threat_category_collection.export(outfile, level, namespace_, name_='known_threat_category_collection')
        if self.added_files:
            self.added_files.export(outfile, level, namespace_, name_='added_files')
        if self.added_hidden_files:
            self.added_hidden_files.export(outfile, level, namespace_, name_='added_hidden_files')
        if self.added_streams:
            self.added_streams.export(outfile, level, namespace_, name_='added_streams')
        if self.added_hidden_streams:
            self.added_hidden_streams.export(outfile, level, namespace_, name_='added_hidden_streams')
        if self.deleted_files:
            self.deleted_files.export(outfile, level, namespace_, name_='deleted_files')
        if self.modified_files:
            self.modified_files.export(outfile, level, namespace_, name_='modified_files')
        if self.added_directories:
            self.added_directories.export(outfile, level, namespace_, name_='added_directories')
        if self.added_hidden_directories:
            self.added_hidden_directories.export(outfile, level, namespace_, name_='added_hidden_directories')
        if self.deleted_directories:
            self.deleted_directories.export(outfile, level, namespace_, name_='deleted_directories')
        if self.added_processes:
            self.added_processes.export(outfile, level, namespace_, name_='added_processes')
        if self.added_hidden_processes:
            self.added_hidden_processes.export(outfile, level, namespace_, name_='added_hidden_processes')
        if self.injected_mempages:
            self.injected_mempages.export(outfile, level, namespace_, name_='injected_mempages')
        if self.added_modules:
            self.added_modules.export(outfile, level, namespace_, name_='added_modules')
        if self.added_services:
            self.added_services.export(outfile, level, namespace_, name_='added_services')
        if self.modified_services:
            self.modified_services.export(outfile, level, namespace_, name_='modified_services')
        if self.added_drivers:
            self.added_drivers.export(outfile, level, namespace_, name_='added_drivers')
        if self.added_syscallhooks:
            self.added_syscallhooks.export(outfile, level, namespace_, name_='added_syscallhooks')
        if self.irp_hooks:
            self.irp_hooks.export(outfile, level, namespace_, name_='irp_hooks')
        if self.added_regkeys:
            self.added_regkeys.export(outfile, level, namespace_, name_='added_regkeys')
        if self.added_hidden_regkeys:
            self.added_hidden_regkeys.export(outfile, level, namespace_, name_='added_hidden_regkeys')
        if self.deleted_regkeys:
            self.deleted_regkeys.export(outfile, level, namespace_, name_='deleted_regkeys')
        if self.added_regvalues:
            self.added_regvalues.export(outfile, level, namespace_, name_='added_regvalues')
        if self.added_hidden_regvalues:
            self.added_hidden_regvalues.export(outfile, level, namespace_, name_='added_hidden_regvalues')
        if self.deleted_regvalues:
            self.deleted_regvalues.export(outfile, level, namespace_, name_='deleted_regvalues')
        if self.modified_regvalues:
            self.modified_regvalues.export(outfile, level, namespace_, name_='modified_regvalues')
        if self.countries:
            self.countries.export(outfile, level, namespace_, name_='countries')
        if self.mutexes:
            self.mutexes.export(outfile, level, namespace_, name_='mutexes')
        if self.open_ports:
            self.open_ports.export(outfile, level, namespace_, name_='open_ports')
        if self.etc_host_lines:
            self.etc_host_lines.export(outfile, level, namespace_, name_='etc_host_lines')
        if self.gethostbyname_api:
            self.gethostbyname_api.export(outfile, level, namespace_, name_='gethostbyname_api')
        if self.connect_ip_api:
            self.connect_ip_api.export(outfile, level, namespace_, name_='connect_ip_api')
        if self.internetconnect_api:
            self.internetconnect_api.export(outfile, level, namespace_, name_='internetconnect_api')
        if self.getrequests:
            self.getrequests.export(outfile, level, namespace_, name_='getrequests')
        if self.urlrequests:
            self.urlrequests.export(outfile, level, namespace_, name_='urlrequests')
        if self.internetopenurl_api:
            self.internetopenurl_api.export(outfile, level, namespace_, name_='internetopenurl_api')
        if self.urldownloadtofile_api:
            self.urldownloadtofile_api.export(outfile, level, namespace_, name_='urldownloadtofile_api')
        if self.ftpgetfile_api:
            self.ftpgetfile_api.export(outfile, level, namespace_, name_='ftpgetfile_api')
        if self.setwindowshook_api:
            self.setwindowshook_api.export(outfile, level, namespace_, name_='setwindowshook_api')
        if self.wnetaddconnection_api:
            self.wnetaddconnection_api.export(outfile, level, namespace_, name_='wnetaddconnection_api')
        if self.exitwindows_api is not None:
            showIndent(outfile, level)
            outfile.write('<%sexitwindows_api>%s</%sexitwindows_api>\n' % (namespace_, self.gds_format_string(quote_xml(self.exitwindows_api).encode(ExternalEncoding), input_name='exitwindows_api'), namespace_))
        if self.irc_traffic:
            self.irc_traffic.export(outfile, level, namespace_, name_='irc_traffic')
        if self.traffic_135 is not None:
            showIndent(outfile, level)
            outfile.write('<%straffic_135>%s</%straffic_135>\n' % (namespace_, self.gds_format_string(quote_xml(self.traffic_135).encode(ExternalEncoding), input_name='traffic_135'), namespace_))
        if self.traffic_445 is not None:
            showIndent(outfile, level)
            outfile.write('<%straffic_445>%s</%straffic_445>\n' % (namespace_, self.gds_format_string(quote_xml(self.traffic_445).encode(ExternalEncoding), input_name='traffic_445'), namespace_))
        if self.outbound_traffic:
            self.outbound_traffic.export(outfile, level, namespace_, name_='outbound_traffic')
        if self.procnames_to_terminate:
            self.procnames_to_terminate.export(outfile, level, namespace_, name_='procnames_to_terminate')
        if self.filestosearch:
            self.filestosearch.export(outfile, level, namespace_, name_='filestosearch')
        if self.excluded_email_addresses:
            self.excluded_email_addresses.export(outfile, level, namespace_, name_='excluded_email_addresses')
        if self.share_probes:
            self.share_probes.export(outfile, level, namespace_, name_='share_probes')
        if self.share_logins:
            self.share_logins.export(outfile, level, namespace_, name_='share_logins')
        if self.bits_downloads:
            self.bits_downloads.export(outfile, level, namespace_, name_='bits_downloads')
        if self.botnet_peers:
            self.botnet_peers.export(outfile, level, namespace_, name_='botnet_peers')
        if self.firewalls_to_bypass:
            self.firewalls_to_bypass.export(outfile, level, namespace_, name_='firewalls_to_bypass')
        if self.heur_downloads:
            self.heur_downloads.export(outfile, level, namespace_, name_='heur_downloads')
        if self.bankjet_urls:
            self.bankjet_urls.export(outfile, level, namespace_, name_='bankjet_urls')
        if self.smtp_traffic:
            self.smtp_traffic.export(outfile, level, namespace_, name_='smtp_traffic')
    def hasContent_(self):
        if (
            self.screen_gif is not None or
            self.known_threat_collection is not None or
            self.known_threat_category_collection is not None or
            self.added_files is not None or
            self.added_hidden_files is not None or
            self.added_streams is not None or
            self.added_hidden_streams is not None or
            self.deleted_files is not None or
            self.modified_files is not None or
            self.added_directories is not None or
            self.added_hidden_directories is not None or
            self.deleted_directories is not None or
            self.added_processes is not None or
            self.added_hidden_processes is not None or
            self.injected_mempages is not None or
            self.added_modules is not None or
            self.added_services is not None or
            self.modified_services is not None or
            self.added_drivers is not None or
            self.added_syscallhooks is not None or
            self.irp_hooks is not None or
            self.added_regkeys is not None or
            self.added_hidden_regkeys is not None or
            self.deleted_regkeys is not None or
            self.added_regvalues is not None or
            self.added_hidden_regvalues is not None or
            self.deleted_regvalues is not None or
            self.modified_regvalues is not None or
            self.countries is not None or
            self.mutexes is not None or
            self.open_ports is not None or
            self.etc_host_lines is not None or
            self.gethostbyname_api is not None or
            self.connect_ip_api is not None or
            self.internetconnect_api is not None or
            self.getrequests is not None or
            self.urlrequests is not None or
            self.internetopenurl_api is not None or
            self.urldownloadtofile_api is not None or
            self.ftpgetfile_api is not None or
            self.setwindowshook_api is not None or
            self.wnetaddconnection_api is not None or
            self.exitwindows_api is not None or
            self.irc_traffic is not None or
            self.traffic_135 is not None or
            self.traffic_445 is not None or
            self.outbound_traffic is not None or
            self.procnames_to_terminate is not None or
            self.filestosearch is not None or
            self.excluded_email_addresses is not None or
            self.share_probes is not None or
            self.share_logins is not None or
            self.bits_downloads is not None or
            self.botnet_peers is not None or
            self.firewalls_to_bypass is not None or
            self.heur_downloads is not None or
            self.bankjet_urls is not None or
            self.smtp_traffic is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='technical_details_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.screen_gif is not None:
            showIndent(outfile, level)
            outfile.write('screen_gif=%s,\n' % quote_python(self.screen_gif).encode(ExternalEncoding))
        if self.known_threat_collection is not None:
            showIndent(outfile, level)
            outfile.write('known_threat_collection=model_.known_threat_collection_type(\n')
            self.known_threat_collection.exportLiteral(outfile, level, name_='known_threat_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.known_threat_category_collection is not None:
            showIndent(outfile, level)
            outfile.write('known_threat_category_collection=model_.known_threat_category_collection_type(\n')
            self.known_threat_category_collection.exportLiteral(outfile, level, name_='known_threat_category_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_files is not None:
            showIndent(outfile, level)
            outfile.write('added_files=model_.added_files_type(\n')
            self.added_files.exportLiteral(outfile, level, name_='added_files')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_hidden_files is not None:
            showIndent(outfile, level)
            outfile.write('added_hidden_files=model_.added_files_type(\n')
            self.added_hidden_files.exportLiteral(outfile, level, name_='added_hidden_files')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_streams is not None:
            showIndent(outfile, level)
            outfile.write('added_streams=model_.added_files_type(\n')
            self.added_streams.exportLiteral(outfile, level, name_='added_streams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_hidden_streams is not None:
            showIndent(outfile, level)
            outfile.write('added_hidden_streams=model_.added_files_type(\n')
            self.added_hidden_streams.exportLiteral(outfile, level, name_='added_hidden_streams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deleted_files is not None:
            showIndent(outfile, level)
            outfile.write('deleted_files=model_.filenames_notes_type(\n')
            self.deleted_files.exportLiteral(outfile, level, name_='deleted_files')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.modified_files is not None:
            showIndent(outfile, level)
            outfile.write('modified_files=model_.filenames_notes_type(\n')
            self.modified_files.exportLiteral(outfile, level, name_='modified_files')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_directories is not None:
            showIndent(outfile, level)
            outfile.write('added_directories=model_.dirnames_notes_type(\n')
            self.added_directories.exportLiteral(outfile, level, name_='added_directories')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_hidden_directories is not None:
            showIndent(outfile, level)
            outfile.write('added_hidden_directories=model_.dirnames_notes_type(\n')
            self.added_hidden_directories.exportLiteral(outfile, level, name_='added_hidden_directories')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deleted_directories is not None:
            showIndent(outfile, level)
            outfile.write('deleted_directories=model_.dirnames_notes_type(\n')
            self.deleted_directories.exportLiteral(outfile, level, name_='deleted_directories')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_processes is not None:
            showIndent(outfile, level)
            outfile.write('added_processes=model_.added_processes_type(\n')
            self.added_processes.exportLiteral(outfile, level, name_='added_processes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_hidden_processes is not None:
            showIndent(outfile, level)
            outfile.write('added_hidden_processes=model_.added_hidden_processes_type(\n')
            self.added_hidden_processes.exportLiteral(outfile, level, name_='added_hidden_processes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.injected_mempages is not None:
            showIndent(outfile, level)
            outfile.write('injected_mempages=model_.injected_mempages_type(\n')
            self.injected_mempages.exportLiteral(outfile, level, name_='injected_mempages')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_modules is not None:
            showIndent(outfile, level)
            outfile.write('added_modules=model_.added_modules_type(\n')
            self.added_modules.exportLiteral(outfile, level, name_='added_modules')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_services is not None:
            showIndent(outfile, level)
            outfile.write('added_services=model_.added_services_type(\n')
            self.added_services.exportLiteral(outfile, level, name_='added_services')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.modified_services is not None:
            showIndent(outfile, level)
            outfile.write('modified_services=model_.modified_services_type(\n')
            self.modified_services.exportLiteral(outfile, level, name_='modified_services')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_drivers is not None:
            showIndent(outfile, level)
            outfile.write('added_drivers=model_.added_drivers_type(\n')
            self.added_drivers.exportLiteral(outfile, level, name_='added_drivers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_syscallhooks is not None:
            showIndent(outfile, level)
            outfile.write('added_syscallhooks=model_.added_syscallhooks_type(\n')
            self.added_syscallhooks.exportLiteral(outfile, level, name_='added_syscallhooks')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.irp_hooks is not None:
            showIndent(outfile, level)
            outfile.write('irp_hooks=model_.irp_hooks_type(\n')
            self.irp_hooks.exportLiteral(outfile, level, name_='irp_hooks')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_regkeys is not None:
            showIndent(outfile, level)
            outfile.write('added_regkeys=model_.regkeys_type(\n')
            self.added_regkeys.exportLiteral(outfile, level, name_='added_regkeys')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_hidden_regkeys is not None:
            showIndent(outfile, level)
            outfile.write('added_hidden_regkeys=model_.regkeys_type(\n')
            self.added_hidden_regkeys.exportLiteral(outfile, level, name_='added_hidden_regkeys')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deleted_regkeys is not None:
            showIndent(outfile, level)
            outfile.write('deleted_regkeys=model_.regkeys_type(\n')
            self.deleted_regkeys.exportLiteral(outfile, level, name_='deleted_regkeys')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_regvalues is not None:
            showIndent(outfile, level)
            outfile.write('added_regvalues=model_.regvalue_structures_type(\n')
            self.added_regvalues.exportLiteral(outfile, level, name_='added_regvalues')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.added_hidden_regvalues is not None:
            showIndent(outfile, level)
            outfile.write('added_hidden_regvalues=model_.regvalue_structures_type(\n')
            self.added_hidden_regvalues.exportLiteral(outfile, level, name_='added_hidden_regvalues')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deleted_regvalues is not None:
            showIndent(outfile, level)
            outfile.write('deleted_regvalues=model_.regvalue_structures_type(\n')
            self.deleted_regvalues.exportLiteral(outfile, level, name_='deleted_regvalues')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.modified_regvalues is not None:
            showIndent(outfile, level)
            outfile.write('modified_regvalues=model_.regvalue_structures_type(\n')
            self.modified_regvalues.exportLiteral(outfile, level, name_='modified_regvalues')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.countries is not None:
            showIndent(outfile, level)
            outfile.write('countries=model_.countries_type(\n')
            self.countries.exportLiteral(outfile, level, name_='countries')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mutexes is not None:
            showIndent(outfile, level)
            outfile.write('mutexes=model_.mutexes_type(\n')
            self.mutexes.exportLiteral(outfile, level, name_='mutexes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.open_ports is not None:
            showIndent(outfile, level)
            outfile.write('open_ports=model_.open_ports_type(\n')
            self.open_ports.exportLiteral(outfile, level, name_='open_ports')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.etc_host_lines is not None:
            showIndent(outfile, level)
            outfile.write('etc_host_lines=model_.etc_host_lines_type(\n')
            self.etc_host_lines.exportLiteral(outfile, level, name_='etc_host_lines')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gethostbyname_api is not None:
            showIndent(outfile, level)
            outfile.write('gethostbyname_api=model_.gethostbyname_api_type(\n')
            self.gethostbyname_api.exportLiteral(outfile, level, name_='gethostbyname_api')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.connect_ip_api is not None:
            showIndent(outfile, level)
            outfile.write('connect_ip_api=model_.connect_ip_api_type(\n')
            self.connect_ip_api.exportLiteral(outfile, level, name_='connect_ip_api')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.internetconnect_api is not None:
            showIndent(outfile, level)
            outfile.write('internetconnect_api=model_.internetconnect_api_type(\n')
            self.internetconnect_api.exportLiteral(outfile, level, name_='internetconnect_api')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.getrequests is not None:
            showIndent(outfile, level)
            outfile.write('getrequests=model_.getrequests_type(\n')
            self.getrequests.exportLiteral(outfile, level, name_='getrequests')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.urlrequests is not None:
            showIndent(outfile, level)
            outfile.write('urlrequests=model_.urls_type(\n')
            self.urlrequests.exportLiteral(outfile, level, name_='urlrequests')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.internetopenurl_api is not None:
            showIndent(outfile, level)
            outfile.write('internetopenurl_api=model_.urls_type(\n')
            self.internetopenurl_api.exportLiteral(outfile, level, name_='internetopenurl_api')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.urldownloadtofile_api is not None:
            showIndent(outfile, level)
            outfile.write('urldownloadtofile_api=model_.urldownloadtofile_api_type(\n')
            self.urldownloadtofile_api.exportLiteral(outfile, level, name_='urldownloadtofile_api')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ftpgetfile_api is not None:
            showIndent(outfile, level)
            outfile.write('ftpgetfile_api=model_.urls_type(\n')
            self.ftpgetfile_api.exportLiteral(outfile, level, name_='ftpgetfile_api')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setwindowshook_api is not None:
            showIndent(outfile, level)
            outfile.write('setwindowshook_api=model_.setwindowshook_api_type(\n')
            self.setwindowshook_api.exportLiteral(outfile, level, name_='setwindowshook_api')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.wnetaddconnection_api is not None:
            showIndent(outfile, level)
            outfile.write('wnetaddconnection_api=model_.wnetaddconnection_api_type(\n')
            self.wnetaddconnection_api.exportLiteral(outfile, level, name_='wnetaddconnection_api')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.exitwindows_api is not None:
            showIndent(outfile, level)
            outfile.write('exitwindows_api=%s,\n' % quote_python(self.exitwindows_api).encode(ExternalEncoding))
        if self.irc_traffic is not None:
            showIndent(outfile, level)
            outfile.write('irc_traffic=model_.irc_traffic_type(\n')
            self.irc_traffic.exportLiteral(outfile, level, name_='irc_traffic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.traffic_135 is not None:
            showIndent(outfile, level)
            outfile.write('traffic_135=%s,\n' % quote_python(self.traffic_135).encode(ExternalEncoding))
        if self.traffic_445 is not None:
            showIndent(outfile, level)
            outfile.write('traffic_445=%s,\n' % quote_python(self.traffic_445).encode(ExternalEncoding))
        if self.outbound_traffic is not None:
            showIndent(outfile, level)
            outfile.write('outbound_traffic=model_.outbound_traffic_type(\n')
            self.outbound_traffic.exportLiteral(outfile, level, name_='outbound_traffic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.procnames_to_terminate is not None:
            showIndent(outfile, level)
            outfile.write('procnames_to_terminate=model_.procnames_to_terminate_type(\n')
            self.procnames_to_terminate.exportLiteral(outfile, level, name_='procnames_to_terminate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.filestosearch is not None:
            showIndent(outfile, level)
            outfile.write('filestosearch=model_.extensions_type(\n')
            self.filestosearch.exportLiteral(outfile, level, name_='filestosearch')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.excluded_email_addresses is not None:
            showIndent(outfile, level)
            outfile.write('excluded_email_addresses=model_.excluded_email_addresses_type(\n')
            self.excluded_email_addresses.exportLiteral(outfile, level, name_='excluded_email_addresses')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.share_probes is not None:
            showIndent(outfile, level)
            outfile.write('share_probes=model_.share_probes_type(\n')
            self.share_probes.exportLiteral(outfile, level, name_='share_probes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.share_logins is not None:
            showIndent(outfile, level)
            outfile.write('share_logins=model_.share_logins_type(\n')
            self.share_logins.exportLiteral(outfile, level, name_='share_logins')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bits_downloads is not None:
            showIndent(outfile, level)
            outfile.write('bits_downloads=model_.bits_downloads_type(\n')
            self.bits_downloads.exportLiteral(outfile, level, name_='bits_downloads')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.botnet_peers is not None:
            showIndent(outfile, level)
            outfile.write('botnet_peers=model_.botnet_peers_type(\n')
            self.botnet_peers.exportLiteral(outfile, level, name_='botnet_peers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.firewalls_to_bypass is not None:
            showIndent(outfile, level)
            outfile.write('firewalls_to_bypass=model_.firewalls_to_bypass_type(\n')
            self.firewalls_to_bypass.exportLiteral(outfile, level, name_='firewalls_to_bypass')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.heur_downloads is not None:
            showIndent(outfile, level)
            outfile.write('heur_downloads=model_.heur_downloads_type(\n')
            self.heur_downloads.exportLiteral(outfile, level, name_='heur_downloads')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bankjet_urls is not None:
            showIndent(outfile, level)
            outfile.write('bankjet_urls=model_.bankjet_urls_type(\n')
            self.bankjet_urls.exportLiteral(outfile, level, name_='bankjet_urls')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.smtp_traffic is not None:
            showIndent(outfile, level)
            outfile.write('smtp_traffic=model_.smtp_traffic_type(\n')
            self.smtp_traffic.exportLiteral(outfile, level, name_='smtp_traffic')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'screen_gif':
            screen_gif_ = child_.text
            self.screen_gif = screen_gif_
            self.validate_screen_gif(self.screen_gif)    # validate type screen_gif
        elif nodeName_ == 'known_threat_collection': 
            obj_ = known_threat_collection_type.factory()
            obj_.build(child_)
            self.set_known_threat_collection(obj_)
        elif nodeName_ == 'known_threat_category_collection': 
            obj_ = known_threat_category_collection_type.factory()
            obj_.build(child_)
            self.set_known_threat_category_collection(obj_)
        elif nodeName_ == 'added_files': 
            obj_ = added_files_type.factory()
            obj_.build(child_)
            self.set_added_files(obj_)
        elif nodeName_ == 'added_hidden_files': 
            obj_ = added_files_type.factory()
            obj_.build(child_)
            self.set_added_hidden_files(obj_)
        elif nodeName_ == 'added_streams': 
            obj_ = added_files_type.factory()
            obj_.build(child_)
            self.set_added_streams(obj_)
        elif nodeName_ == 'added_hidden_streams': 
            obj_ = added_files_type.factory()
            obj_.build(child_)
            self.set_added_hidden_streams(obj_)
        elif nodeName_ == 'deleted_files': 
            obj_ = filenames_notes_type.factory()
            obj_.build(child_)
            self.set_deleted_files(obj_)
        elif nodeName_ == 'modified_files': 
            obj_ = filenames_notes_type.factory()
            obj_.build(child_)
            self.set_modified_files(obj_)
        elif nodeName_ == 'added_directories': 
            obj_ = dirnames_notes_type.factory()
            obj_.build(child_)
            self.set_added_directories(obj_)
        elif nodeName_ == 'added_hidden_directories': 
            obj_ = dirnames_notes_type.factory()
            obj_.build(child_)
            self.set_added_hidden_directories(obj_)
        elif nodeName_ == 'deleted_directories': 
            obj_ = dirnames_notes_type.factory()
            obj_.build(child_)
            self.set_deleted_directories(obj_)
        elif nodeName_ == 'added_processes': 
            obj_ = added_processes_type.factory()
            obj_.build(child_)
            self.set_added_processes(obj_)
        elif nodeName_ == 'added_hidden_processes': 
            obj_ = added_hidden_processes_type.factory()
            obj_.build(child_)
            self.set_added_hidden_processes(obj_)
        elif nodeName_ == 'injected_mempages': 
            obj_ = injected_mempages_type.factory()
            obj_.build(child_)
            self.set_injected_mempages(obj_)
        elif nodeName_ == 'added_modules': 
            obj_ = added_modules_type.factory()
            obj_.build(child_)
            self.set_added_modules(obj_)
        elif nodeName_ == 'added_services': 
            obj_ = added_services_type.factory()
            obj_.build(child_)
            self.set_added_services(obj_)
        elif nodeName_ == 'modified_services': 
            obj_ = modified_services_type.factory()
            obj_.build(child_)
            self.set_modified_services(obj_)
        elif nodeName_ == 'added_drivers': 
            obj_ = added_drivers_type.factory()
            obj_.build(child_)
            self.set_added_drivers(obj_)
        elif nodeName_ == 'added_syscallhooks': 
            obj_ = added_syscallhooks_type.factory()
            obj_.build(child_)
            self.set_added_syscallhooks(obj_)
        elif nodeName_ == 'irp_hooks': 
            obj_ = irp_hooks_type.factory()
            obj_.build(child_)
            self.set_irp_hooks(obj_)
        elif nodeName_ == 'added_regkeys': 
            obj_ = regkeys_type.factory()
            obj_.build(child_)
            self.set_added_regkeys(obj_)
        elif nodeName_ == 'added_hidden_regkeys': 
            obj_ = regkeys_type.factory()
            obj_.build(child_)
            self.set_added_hidden_regkeys(obj_)
        elif nodeName_ == 'deleted_regkeys': 
            obj_ = regkeys_type.factory()
            obj_.build(child_)
            self.set_deleted_regkeys(obj_)
        elif nodeName_ == 'added_regvalues': 
            obj_ = regvalue_structures_type.factory()
            obj_.build(child_)
            self.set_added_regvalues(obj_)
        elif nodeName_ == 'added_hidden_regvalues': 
            obj_ = regvalue_structures_type.factory()
            obj_.build(child_)
            self.set_added_hidden_regvalues(obj_)
        elif nodeName_ == 'deleted_regvalues': 
            obj_ = regvalue_structures_type.factory()
            obj_.build(child_)
            self.set_deleted_regvalues(obj_)
        elif nodeName_ == 'modified_regvalues': 
            obj_ = regvalue_structures_type.factory()
            obj_.build(child_)
            self.set_modified_regvalues(obj_)
        elif nodeName_ == 'countries': 
            obj_ = countries_type.factory()
            obj_.build(child_)
            self.set_countries(obj_)
        elif nodeName_ == 'mutexes': 
            obj_ = mutexes_type.factory()
            obj_.build(child_)
            self.set_mutexes(obj_)
        elif nodeName_ == 'open_ports': 
            obj_ = open_ports_type.factory()
            obj_.build(child_)
            self.set_open_ports(obj_)
        elif nodeName_ == 'etc_host_lines': 
            obj_ = etc_host_lines_type.factory()
            obj_.build(child_)
            self.set_etc_host_lines(obj_)
        elif nodeName_ == 'gethostbyname_api': 
            obj_ = gethostbyname_api_type.factory()
            obj_.build(child_)
            self.set_gethostbyname_api(obj_)
        elif nodeName_ == 'connect_ip_api': 
            obj_ = connect_ip_api_type.factory()
            obj_.build(child_)
            self.set_connect_ip_api(obj_)
        elif nodeName_ == 'internetconnect_api': 
            obj_ = internetconnect_api_type.factory()
            obj_.build(child_)
            self.set_internetconnect_api(obj_)
        elif nodeName_ == 'getrequests': 
            obj_ = getrequests_type.factory()
            obj_.build(child_)
            self.set_getrequests(obj_)
        elif nodeName_ == 'urlrequests': 
            obj_ = urls_type.factory()
            obj_.build(child_)
            self.set_urlrequests(obj_)
        elif nodeName_ == 'internetopenurl_api': 
            obj_ = urls_type.factory()
            obj_.build(child_)
            self.set_internetopenurl_api(obj_)
        elif nodeName_ == 'urldownloadtofile_api': 
            obj_ = urldownloadtofile_api_type.factory()
            obj_.build(child_)
            self.set_urldownloadtofile_api(obj_)
        elif nodeName_ == 'ftpgetfile_api': 
            obj_ = urls_type.factory()
            obj_.build(child_)
            self.set_ftpgetfile_api(obj_)
        elif nodeName_ == 'setwindowshook_api': 
            obj_ = setwindowshook_api_type.factory()
            obj_.build(child_)
            self.set_setwindowshook_api(obj_)
        elif nodeName_ == 'wnetaddconnection_api': 
            obj_ = wnetaddconnection_api_type.factory()
            obj_.build(child_)
            self.set_wnetaddconnection_api(obj_)
        elif nodeName_ == 'exitwindows_api':
            exitwindows_api_ = child_.text
            self.exitwindows_api = exitwindows_api_
            self.validate_exitwindows_api(self.exitwindows_api)    # validate type exitwindows_api
        elif nodeName_ == 'irc_traffic': 
            obj_ = irc_traffic_type.factory()
            obj_.build(child_)
            self.set_irc_traffic(obj_)
        elif nodeName_ == 'traffic_135':
            traffic_135_ = child_.text
            self.traffic_135 = traffic_135_
            self.validate_traffic_135(self.traffic_135)    # validate type traffic_135
        elif nodeName_ == 'traffic_445':
            traffic_445_ = child_.text
            self.traffic_445 = traffic_445_
            self.validate_traffic_445(self.traffic_445)    # validate type traffic_445
        elif nodeName_ == 'outbound_traffic': 
            obj_ = outbound_traffic_type.factory()
            obj_.build(child_)
            self.set_outbound_traffic(obj_)
        elif nodeName_ == 'procnames_to_terminate': 
            obj_ = procnames_to_terminate_type.factory()
            obj_.build(child_)
            self.set_procnames_to_terminate(obj_)
        elif nodeName_ == 'filestosearch': 
            obj_ = extensions_type.factory()
            obj_.build(child_)
            self.set_filestosearch(obj_)
        elif nodeName_ == 'excluded_email_addresses': 
            obj_ = excluded_email_addresses_type.factory()
            obj_.build(child_)
            self.set_excluded_email_addresses(obj_)
        elif nodeName_ == 'share_probes': 
            obj_ = share_probes_type.factory()
            obj_.build(child_)
            self.set_share_probes(obj_)
        elif nodeName_ == 'share_logins': 
            obj_ = share_logins_type.factory()
            obj_.build(child_)
            self.set_share_logins(obj_)
        elif nodeName_ == 'bits_downloads': 
            obj_ = bits_downloads_type.factory()
            obj_.build(child_)
            self.set_bits_downloads(obj_)
        elif nodeName_ == 'botnet_peers': 
            obj_ = botnet_peers_type.factory()
            obj_.build(child_)
            self.set_botnet_peers(obj_)
        elif nodeName_ == 'firewalls_to_bypass': 
            obj_ = firewalls_to_bypass_type.factory()
            obj_.build(child_)
            self.set_firewalls_to_bypass(obj_)
        elif nodeName_ == 'heur_downloads': 
            obj_ = heur_downloads_type.factory()
            obj_.build(child_)
            self.set_heur_downloads(obj_)
        elif nodeName_ == 'bankjet_urls': 
            obj_ = bankjet_urls_type.factory()
            obj_.build(child_)
            self.set_bankjet_urls(obj_)
        elif nodeName_ == 'smtp_traffic': 
            obj_ = smtp_traffic_type.factory()
            obj_.build(child_)
            self.set_smtp_traffic(obj_)
# end class technical_details_type


class flag_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, severity=None):
        self.description = description
        self.severity = severity
    def factory(*args_, **kwargs_):
        if flag_type.subclass:
            return flag_type.subclass(*args_, **kwargs_)
        else:
            return flag_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # validate type description
        pass
    def get_severity(self): return self.severity
    def set_severity(self, severity): self.severity = severity
    def validate_severity(self, value):
        # validate type severity
        pass
    def export(self, outfile, level, namespace_='', name_='flag_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='flag_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='flag_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='flag_type'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.severity is not None:
            showIndent(outfile, level)
            outfile.write('<%sseverity>%s</%sseverity>\n' % (namespace_, self.gds_format_string(quote_xml(self.severity).encode(ExternalEncoding), input_name='severity'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None or
            self.severity is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='flag_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.severity is not None:
            showIndent(outfile, level)
            outfile.write('severity=%s,\n' % quote_python(self.severity).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
            self.validate_description(self.description)    # validate type description
        elif nodeName_ == 'severity':
            severity_ = child_.text
            self.severity = severity_
            self.validate_severity(self.severity)    # validate type severity
# end class flag_type


class flag_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, flag=None):
        if flag is None:
            self.flag = []
        else:
            self.flag = flag
    def factory(*args_, **kwargs_):
        if flag_collection_type.subclass:
            return flag_collection_type.subclass(*args_, **kwargs_)
        else:
            return flag_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_flag(self): return self.flag
    def set_flag(self, flag): self.flag = flag
    def add_flag(self, value): self.flag.append(value)
    def insert_flag(self, index, value): self.flag[index] = value
    def export(self, outfile, level, namespace_='', name_='flag_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='flag_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='flag_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='flag_collection_type'):
        for flag_ in self.flag:
            flag_.export(outfile, level, namespace_, name_='flag')
    def hasContent_(self):
        if (
            self.flag
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='flag_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('flag=[\n')
        level += 1
        for flag_ in self.flag:
            showIndent(outfile, level)
            outfile.write('model_.flag_type(\n')
            flag_.exportLiteral(outfile, level, name_='flag_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'flag': 
            obj_ = flag_type.factory()
            obj_.build(child_)
            self.flag.append(obj_)
# end class flag_collection_type


class sample_info_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, md5=None, sha1=None, filesize=None, alias_kav=None, alias_nav=None, alias_nai=None, alias_trend=None, alias_sophos=None, alias_microsoft=None, alias_ikarus=None, alias_ahnlab=None, packer=None):
        self.md5 = md5
        self.sha1 = sha1
        self.filesize = filesize
        self.alias_kav = alias_kav
        self.alias_nav = alias_nav
        self.alias_nai = alias_nai
        self.alias_trend = alias_trend
        self.alias_sophos = alias_sophos
        self.alias_microsoft = alias_microsoft
        self.alias_ikarus = alias_ikarus
        self.alias_ahnlab = alias_ahnlab
        self.packer = packer
    def factory(*args_, **kwargs_):
        if sample_info_type.subclass:
            return sample_info_type.subclass(*args_, **kwargs_)
        else:
            return sample_info_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_md5(self): return self.md5
    def set_md5(self, md5): self.md5 = md5
    def validate_md5(self, value):
        # validate type md5
        pass
    def get_sha1(self): return self.sha1
    def set_sha1(self, sha1): self.sha1 = sha1
    def validate_sha1(self, value):
        # validate type sha1
        pass
    def get_filesize(self): return self.filesize
    def set_filesize(self, filesize): self.filesize = filesize
    def validate_filesize(self, value):
        # validate type filesize
        pass
    def get_alias_kav(self): return self.alias_kav
    def set_alias_kav(self, alias_kav): self.alias_kav = alias_kav
    def validate_alias_kav(self, value):
        # validate type alias_kav
        pass
    def get_alias_nav(self): return self.alias_nav
    def set_alias_nav(self, alias_nav): self.alias_nav = alias_nav
    def validate_alias_nav(self, value):
        # validate type alias_nav
        pass
    def get_alias_nai(self): return self.alias_nai
    def set_alias_nai(self, alias_nai): self.alias_nai = alias_nai
    def validate_alias_nai(self, value):
        # validate type alias_nai
        pass
    def get_alias_trend(self): return self.alias_trend
    def set_alias_trend(self, alias_trend): self.alias_trend = alias_trend
    def validate_alias_trend(self, value):
        # validate type alias_trend
        pass
    def get_alias_sophos(self): return self.alias_sophos
    def set_alias_sophos(self, alias_sophos): self.alias_sophos = alias_sophos
    def validate_alias_sophos(self, value):
        # validate type alias_sophos
        pass
    def get_alias_microsoft(self): return self.alias_microsoft
    def set_alias_microsoft(self, alias_microsoft): self.alias_microsoft = alias_microsoft
    def validate_alias_microsoft(self, value):
        # validate type alias_microsoft
        pass
    def get_alias_ikarus(self): return self.alias_ikarus
    def set_alias_ikarus(self, alias_ikarus): self.alias_ikarus = alias_ikarus
    def validate_alias_ikarus(self, value):
        # validate type alias_ikarus
        pass
    def get_alias_ahnlab(self): return self.alias_ahnlab
    def set_alias_ahnlab(self, alias_ahnlab): self.alias_ahnlab = alias_ahnlab
    def validate_alias_ahnlab(self, value):
        # validate type alias_ahnlab
        pass
    def get_packer(self): return self.packer
    def set_packer(self, packer): self.packer = packer
    def validate_packer(self, value):
        # validate type packer
        pass
    def export(self, outfile, level, namespace_='', name_='sample_info_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sample_info_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='sample_info_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sample_info_type'):
        if self.md5 is not None:
            showIndent(outfile, level)
            outfile.write('<%smd5>%s</%smd5>\n' % (namespace_, self.gds_format_string(quote_xml(self.md5).encode(ExternalEncoding), input_name='md5'), namespace_))
        if self.sha1 is not None:
            showIndent(outfile, level)
            outfile.write('<%ssha1>%s</%ssha1>\n' % (namespace_, self.gds_format_string(quote_xml(self.sha1).encode(ExternalEncoding), input_name='sha1'), namespace_))
        if self.filesize is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilesize>%s</%sfilesize>\n' % (namespace_, self.gds_format_string(quote_xml(self.filesize).encode(ExternalEncoding), input_name='filesize'), namespace_))
        if self.alias_kav is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_kav>%s</%salias_kav>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_kav).encode(ExternalEncoding), input_name='alias_kav'), namespace_))
        if self.alias_nav is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_nav>%s</%salias_nav>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_nav).encode(ExternalEncoding), input_name='alias_nav'), namespace_))
        if self.alias_nai is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_nai>%s</%salias_nai>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_nai).encode(ExternalEncoding), input_name='alias_nai'), namespace_))
        if self.alias_trend is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_trend>%s</%salias_trend>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_trend).encode(ExternalEncoding), input_name='alias_trend'), namespace_))
        if self.alias_sophos is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_sophos>%s</%salias_sophos>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_sophos).encode(ExternalEncoding), input_name='alias_sophos'), namespace_))
        if self.alias_microsoft is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_microsoft>%s</%salias_microsoft>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_microsoft).encode(ExternalEncoding), input_name='alias_microsoft'), namespace_))
        if self.alias_ikarus is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_ikarus>%s</%salias_ikarus>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_ikarus).encode(ExternalEncoding), input_name='alias_ikarus'), namespace_))
        if self.alias_ahnlab is not None:
            showIndent(outfile, level)
            outfile.write('<%salias_ahnlab>%s</%salias_ahnlab>\n' % (namespace_, self.gds_format_string(quote_xml(self.alias_ahnlab).encode(ExternalEncoding), input_name='alias_ahnlab'), namespace_))
        if self.packer is not None:
            showIndent(outfile, level)
            outfile.write('<%spacker>%s</%spacker>\n' % (namespace_, self.gds_format_string(quote_xml(self.packer).encode(ExternalEncoding), input_name='packer'), namespace_))
    def hasContent_(self):
        if (
            self.md5 is not None or
            self.sha1 is not None or
            self.filesize is not None or
            self.alias_kav is not None or
            self.alias_nav is not None or
            self.alias_nai is not None or
            self.alias_trend is not None or
            self.alias_sophos is not None or
            self.alias_microsoft is not None or
            self.alias_ikarus is not None or
            self.alias_ahnlab is not None or
            self.packer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sample_info_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.md5 is not None:
            showIndent(outfile, level)
            outfile.write('md5=%s,\n' % quote_python(self.md5).encode(ExternalEncoding))
        if self.sha1 is not None:
            showIndent(outfile, level)
            outfile.write('sha1=%s,\n' % quote_python(self.sha1).encode(ExternalEncoding))
        if self.filesize is not None:
            showIndent(outfile, level)
            outfile.write('filesize=%s,\n' % quote_python(self.filesize).encode(ExternalEncoding))
        if self.alias_kav is not None:
            showIndent(outfile, level)
            outfile.write('alias_kav=%s,\n' % quote_python(self.alias_kav).encode(ExternalEncoding))
        if self.alias_nav is not None:
            showIndent(outfile, level)
            outfile.write('alias_nav=%s,\n' % quote_python(self.alias_nav).encode(ExternalEncoding))
        if self.alias_nai is not None:
            showIndent(outfile, level)
            outfile.write('alias_nai=%s,\n' % quote_python(self.alias_nai).encode(ExternalEncoding))
        if self.alias_trend is not None:
            showIndent(outfile, level)
            outfile.write('alias_trend=%s,\n' % quote_python(self.alias_trend).encode(ExternalEncoding))
        if self.alias_sophos is not None:
            showIndent(outfile, level)
            outfile.write('alias_sophos=%s,\n' % quote_python(self.alias_sophos).encode(ExternalEncoding))
        if self.alias_microsoft is not None:
            showIndent(outfile, level)
            outfile.write('alias_microsoft=%s,\n' % quote_python(self.alias_microsoft).encode(ExternalEncoding))
        if self.alias_ikarus is not None:
            showIndent(outfile, level)
            outfile.write('alias_ikarus=%s,\n' % quote_python(self.alias_ikarus).encode(ExternalEncoding))
        if self.alias_ahnlab is not None:
            showIndent(outfile, level)
            outfile.write('alias_ahnlab=%s,\n' % quote_python(self.alias_ahnlab).encode(ExternalEncoding))
        if self.packer is not None:
            showIndent(outfile, level)
            outfile.write('packer=%s,\n' % quote_python(self.packer).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'md5':
            md5_ = child_.text
            self.md5 = md5_
            self.validate_md5(self.md5)    # validate type md5
        elif nodeName_ == 'sha1':
            sha1_ = child_.text
            self.sha1 = sha1_
            self.validate_sha1(self.sha1)    # validate type sha1
        elif nodeName_ == 'filesize':
            filesize_ = child_.text
            self.filesize = filesize_
            self.validate_filesize(self.filesize)    # validate type filesize
        elif nodeName_ == 'alias_kav':
            alias_kav_ = child_.text
            self.alias_kav = alias_kav_
            self.validate_alias_kav(self.alias_kav)    # validate type alias_kav
        elif nodeName_ == 'alias_nav':
            alias_nav_ = child_.text
            self.alias_nav = alias_nav_
            self.validate_alias_nav(self.alias_nav)    # validate type alias_nav
        elif nodeName_ == 'alias_nai':
            alias_nai_ = child_.text
            self.alias_nai = alias_nai_
            self.validate_alias_nai(self.alias_nai)    # validate type alias_nai
        elif nodeName_ == 'alias_trend':
            alias_trend_ = child_.text
            self.alias_trend = alias_trend_
            self.validate_alias_trend(self.alias_trend)    # validate type alias_trend
        elif nodeName_ == 'alias_sophos':
            alias_sophos_ = child_.text
            self.alias_sophos = alias_sophos_
            self.validate_alias_sophos(self.alias_sophos)    # validate type alias_sophos
        elif nodeName_ == 'alias_microsoft':
            alias_microsoft_ = child_.text
            self.alias_microsoft = alias_microsoft_
            self.validate_alias_microsoft(self.alias_microsoft)    # validate type alias_microsoft
        elif nodeName_ == 'alias_ikarus':
            alias_ikarus_ = child_.text
            self.alias_ikarus = alias_ikarus_
            self.validate_alias_ikarus(self.alias_ikarus)    # validate type alias_ikarus
        elif nodeName_ == 'alias_ahnlab':
            alias_ahnlab_ = child_.text
            self.alias_ahnlab = alias_ahnlab_
            self.validate_alias_ahnlab(self.alias_ahnlab)    # validate type alias_ahnlab
        elif nodeName_ == 'packer':
            packer_ = child_.text
            self.packer = packer_
            self.validate_packer(self.packer)    # validate type packer
# end class sample_info_type


class sample_info_collection_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sample_info=None):
        if sample_info is None:
            self.sample_info = []
        else:
            self.sample_info = sample_info
    def factory(*args_, **kwargs_):
        if sample_info_collection_type.subclass:
            return sample_info_collection_type.subclass(*args_, **kwargs_)
        else:
            return sample_info_collection_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sample_info(self): return self.sample_info
    def set_sample_info(self, sample_info): self.sample_info = sample_info
    def add_sample_info(self, value): self.sample_info.append(value)
    def insert_sample_info(self, index, value): self.sample_info[index] = value
    def export(self, outfile, level, namespace_='', name_='sample_info_collection_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sample_info_collection_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='sample_info_collection_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sample_info_collection_type'):
        for sample_info_ in self.sample_info:
            sample_info_.export(outfile, level, namespace_, name_='sample_info')
    def hasContent_(self):
        if (
            self.sample_info
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sample_info_collection_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sample_info=[\n')
        level += 1
        for sample_info_ in self.sample_info:
            showIndent(outfile, level)
            outfile.write('model_.sample_info_type(\n')
            sample_info_.exportLiteral(outfile, level, name_='sample_info_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'sample_info': 
            obj_ = sample_info_type.factory()
            obj_.build(child_)
            self.sample_info.append(obj_)
# end class sample_info_collection_type


class processing_time_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hours=None, minutes=None, seconds=None):
        self.hours = hours
        self.minutes = minutes
        self.seconds = seconds
    def factory(*args_, **kwargs_):
        if processing_time_type.subclass:
            return processing_time_type.subclass(*args_, **kwargs_)
        else:
            return processing_time_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hours(self): return self.hours
    def set_hours(self, hours): self.hours = hours
    def validate_hours(self, value):
        # validate type hours
        pass
    def get_minutes(self): return self.minutes
    def set_minutes(self, minutes): self.minutes = minutes
    def validate_minutes(self, value):
        # validate type minutes
        pass
    def get_seconds(self): return self.seconds
    def set_seconds(self, seconds): self.seconds = seconds
    def validate_seconds(self, value):
        # validate type seconds
        pass
    def export(self, outfile, level, namespace_='', name_='processing_time_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='processing_time_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='processing_time_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='processing_time_type'):
        if self.hours is not None:
            showIndent(outfile, level)
            outfile.write('<%shours>%s</%shours>\n' % (namespace_, self.gds_format_string(quote_xml(self.hours).encode(ExternalEncoding), input_name='hours'), namespace_))
        if self.minutes is not None:
            showIndent(outfile, level)
            outfile.write('<%sminutes>%s</%sminutes>\n' % (namespace_, self.gds_format_string(quote_xml(self.minutes).encode(ExternalEncoding), input_name='minutes'), namespace_))
        if self.seconds is not None:
            showIndent(outfile, level)
            outfile.write('<%sseconds>%s</%sseconds>\n' % (namespace_, self.gds_format_string(quote_xml(self.seconds).encode(ExternalEncoding), input_name='seconds'), namespace_))
    def hasContent_(self):
        if (
            self.hours is not None or
            self.minutes is not None or
            self.seconds is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='processing_time_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.hours is not None:
            showIndent(outfile, level)
            outfile.write('hours=%s,\n' % quote_python(self.hours).encode(ExternalEncoding))
        if self.minutes is not None:
            showIndent(outfile, level)
            outfile.write('minutes=%s,\n' % quote_python(self.minutes).encode(ExternalEncoding))
        if self.seconds is not None:
            showIndent(outfile, level)
            outfile.write('seconds=%s,\n' % quote_python(self.seconds).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'hours':
            hours_ = child_.text
            self.hours = hours_
            self.validate_hours(self.hours)    # validate type hours
        elif nodeName_ == 'minutes':
            minutes_ = child_.text
            self.minutes = minutes_
            self.validate_minutes(self.minutes)    # validate type minutes
        elif nodeName_ == 'seconds':
            seconds_ = child_.text
            self.seconds = seconds_
            self.validate_seconds(self.seconds)    # validate type seconds
# end class processing_time_type


class submission_received_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, day=None, month=None, year=None, hour=None, minute=None, second=None):
        self.day = day
        self.month = month
        self.year = year
        self.hour = hour
        self.minute = minute
        self.second = second
    def factory(*args_, **kwargs_):
        if submission_received_type.subclass:
            return submission_received_type.subclass(*args_, **kwargs_)
        else:
            return submission_received_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_day(self): return self.day
    def set_day(self, day): self.day = day
    def validate_day(self, value):
        # validate type day
        pass
    def get_month(self): return self.month
    def set_month(self, month): self.month = month
    def validate_month(self, value):
        # validate type month
        pass
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def validate_year(self, value):
        # validate type year
        pass
    def get_hour(self): return self.hour
    def set_hour(self, hour): self.hour = hour
    def validate_hour(self, value):
        # validate type hour
        pass
    def get_minute(self): return self.minute
    def set_minute(self, minute): self.minute = minute
    def validate_minute(self, value):
        # validate type minute
        pass
    def get_second(self): return self.second
    def set_second(self, second): self.second = second
    def validate_second(self, value):
        # validate type second
        pass
    def export(self, outfile, level, namespace_='', name_='submission_received_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='submission_received_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='submission_received_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='submission_received_type'):
        if self.day is not None:
            showIndent(outfile, level)
            outfile.write('<%sday>%s</%sday>\n' % (namespace_, self.gds_format_string(quote_xml(self.day).encode(ExternalEncoding), input_name='day'), namespace_))
        if self.month is not None:
            showIndent(outfile, level)
            outfile.write('<%smonth>%s</%smonth>\n' % (namespace_, self.gds_format_string(quote_xml(self.month).encode(ExternalEncoding), input_name='month'), namespace_))
        if self.year is not None:
            showIndent(outfile, level)
            outfile.write('<%syear>%s</%syear>\n' % (namespace_, self.gds_format_string(quote_xml(self.year).encode(ExternalEncoding), input_name='year'), namespace_))
        if self.hour is not None:
            showIndent(outfile, level)
            outfile.write('<%shour>%s</%shour>\n' % (namespace_, self.gds_format_string(quote_xml(self.hour).encode(ExternalEncoding), input_name='hour'), namespace_))
        if self.minute is not None:
            showIndent(outfile, level)
            outfile.write('<%sminute>%s</%sminute>\n' % (namespace_, self.gds_format_string(quote_xml(self.minute).encode(ExternalEncoding), input_name='minute'), namespace_))
        if self.second is not None:
            showIndent(outfile, level)
            outfile.write('<%ssecond>%s</%ssecond>\n' % (namespace_, self.gds_format_string(quote_xml(self.second).encode(ExternalEncoding), input_name='second'), namespace_))
    def hasContent_(self):
        if (
            self.day is not None or
            self.month is not None or
            self.year is not None or
            self.hour is not None or
            self.minute is not None or
            self.second is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='submission_received_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.day is not None:
            showIndent(outfile, level)
            outfile.write('day=%s,\n' % quote_python(self.day).encode(ExternalEncoding))
        if self.month is not None:
            showIndent(outfile, level)
            outfile.write('month=%s,\n' % quote_python(self.month).encode(ExternalEncoding))
        if self.year is not None:
            showIndent(outfile, level)
            outfile.write('year=%s,\n' % quote_python(self.year).encode(ExternalEncoding))
        if self.hour is not None:
            showIndent(outfile, level)
            outfile.write('hour=%s,\n' % quote_python(self.hour).encode(ExternalEncoding))
        if self.minute is not None:
            showIndent(outfile, level)
            outfile.write('minute=%s,\n' % quote_python(self.minute).encode(ExternalEncoding))
        if self.second is not None:
            showIndent(outfile, level)
            outfile.write('second=%s,\n' % quote_python(self.second).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'day':
            day_ = child_.text
            self.day = day_
            self.validate_day(self.day)    # validate type day
        elif nodeName_ == 'month':
            month_ = child_.text
            self.month = month_
            self.validate_month(self.month)    # validate type month
        elif nodeName_ == 'year':
            year_ = child_.text
            self.year = year_
            self.validate_year(self.year)    # validate type year
        elif nodeName_ == 'hour':
            hour_ = child_.text
            self.hour = hour_
            self.validate_hour(self.hour)    # validate type hour
        elif nodeName_ == 'minute':
            minute_ = child_.text
            self.minute = minute_
            self.validate_minute(self.minute)    # validate type minute
        elif nodeName_ == 'second':
            second_ = child_.text
            self.second = second_
            self.validate_second(self.second)    # validate type second
# end class submission_received_type


class submission_details_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, submission_received=None, processing_time=None, sample_info_collection=None):
        self.submission_received = submission_received
        self.processing_time = processing_time
        self.sample_info_collection = sample_info_collection
    def factory(*args_, **kwargs_):
        if submission_details_type.subclass:
            return submission_details_type.subclass(*args_, **kwargs_)
        else:
            return submission_details_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_submission_received(self): return self.submission_received
    def set_submission_received(self, submission_received): self.submission_received = submission_received
    def get_processing_time(self): return self.processing_time
    def set_processing_time(self, processing_time): self.processing_time = processing_time
    def get_sample_info_collection(self): return self.sample_info_collection
    def set_sample_info_collection(self, sample_info_collection): self.sample_info_collection = sample_info_collection
    def export(self, outfile, level, namespace_='', name_='submission_details_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='submission_details_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='submission_details_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='submission_details_type'):
        if self.submission_received:
            self.submission_received.export(outfile, level, namespace_, name_='submission_received', )
        if self.processing_time:
            self.processing_time.export(outfile, level, namespace_, name_='processing_time', )
        if self.sample_info_collection:
            self.sample_info_collection.export(outfile, level, namespace_, name_='sample_info_collection', )
    def hasContent_(self):
        if (
            self.submission_received is not None or
            self.processing_time is not None or
            self.sample_info_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='submission_details_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.submission_received is not None:
            showIndent(outfile, level)
            outfile.write('submission_received=model_.submission_received_type(\n')
            self.submission_received.exportLiteral(outfile, level, name_='submission_received')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.processing_time is not None:
            showIndent(outfile, level)
            outfile.write('processing_time=model_.processing_time_type(\n')
            self.processing_time.exportLiteral(outfile, level, name_='processing_time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sample_info_collection is not None:
            showIndent(outfile, level)
            outfile.write('sample_info_collection=model_.sample_info_collection_type(\n')
            self.sample_info_collection.exportLiteral(outfile, level, name_='sample_info_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'submission_received': 
            obj_ = submission_received_type.factory()
            obj_.build(child_)
            self.set_submission_received(obj_)
        elif nodeName_ == 'processing_time': 
            obj_ = processing_time_type.factory()
            obj_.build(child_)
            self.set_processing_time(obj_)
        elif nodeName_ == 'sample_info_collection': 
            obj_ = sample_info_collection_type.factory()
            obj_.build(child_)
            self.set_sample_info_collection(obj_)
# end class submission_details_type


class submission_summary_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, submission_details=None, flag_collection=None):
        self.submission_details = submission_details
        self.flag_collection = flag_collection
    def factory(*args_, **kwargs_):
        if submission_summary_type.subclass:
            return submission_summary_type.subclass(*args_, **kwargs_)
        else:
            return submission_summary_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_submission_details(self): return self.submission_details
    def set_submission_details(self, submission_details): self.submission_details = submission_details
    def get_flag_collection(self): return self.flag_collection
    def set_flag_collection(self, flag_collection): self.flag_collection = flag_collection
    def export(self, outfile, level, namespace_='', name_='submission_summary_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='submission_summary_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='submission_summary_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='submission_summary_type'):
        if self.submission_details:
            self.submission_details.export(outfile, level, namespace_, name_='submission_details', )
        if self.flag_collection:
            self.flag_collection.export(outfile, level, namespace_, name_='flag_collection')
    def hasContent_(self):
        if (
            self.submission_details is not None or
            self.flag_collection is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='submission_summary_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.submission_details is not None:
            showIndent(outfile, level)
            outfile.write('submission_details=model_.submission_details_type(\n')
            self.submission_details.exportLiteral(outfile, level, name_='submission_details')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flag_collection is not None:
            showIndent(outfile, level)
            outfile.write('flag_collection=model_.flag_collection_type(\n')
            self.flag_collection.exportLiteral(outfile, level, name_='flag_collection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'submission_details': 
            obj_ = submission_details_type.factory()
            obj_.build(child_)
            self.set_submission_details(obj_)
        elif nodeName_ == 'flag_collection': 
            obj_ = flag_collection_type.factory()
            obj_.build(child_)
            self.set_flag_collection(obj_)
# end class submission_summary_type


class subreport_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, submission_summary=None, technical_details=None):
        self.submission_summary = submission_summary
        self.technical_details = technical_details
    def factory(*args_, **kwargs_):
        if subreport_type.subclass:
            return subreport_type.subclass(*args_, **kwargs_)
        else:
            return subreport_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_submission_summary(self): return self.submission_summary
    def set_submission_summary(self, submission_summary): self.submission_summary = submission_summary
    def get_technical_details(self): return self.technical_details
    def set_technical_details(self, technical_details): self.technical_details = technical_details
    def export(self, outfile, level, namespace_='', name_='subreport_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='subreport_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='subreport_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='subreport_type'):
        if self.submission_summary:
            self.submission_summary.export(outfile, level, namespace_, name_='submission_summary', )
        if self.technical_details:
            self.technical_details.export(outfile, level, namespace_, name_='technical_details', )
    def hasContent_(self):
        if (
            self.submission_summary is not None or
            self.technical_details is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subreport_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.submission_summary is not None:
            showIndent(outfile, level)
            outfile.write('submission_summary=model_.submission_summary_type(\n')
            self.submission_summary.exportLiteral(outfile, level, name_='submission_summary')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.technical_details is not None:
            showIndent(outfile, level)
            outfile.write('technical_details=model_.technical_details_type(\n')
            self.technical_details.exportLiteral(outfile, level, name_='technical_details')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'submission_summary': 
            obj_ = submission_summary_type.factory()
            obj_.build(child_)
            self.set_submission_summary(obj_)
        elif nodeName_ == 'technical_details': 
            obj_ = technical_details_type.factory()
            obj_.build(child_)
            self.set_technical_details(obj_)
# end class subreport_type


class subreports_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, subreport=None):
        if subreport is None:
            self.subreport = []
        else:
            self.subreport = subreport
    def factory(*args_, **kwargs_):
        if subreports_type.subclass:
            return subreports_type.subclass(*args_, **kwargs_)
        else:
            return subreports_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subreport(self): return self.subreport
    def set_subreport(self, subreport): self.subreport = subreport
    def add_subreport(self, value): self.subreport.append(value)
    def insert_subreport(self, index, value): self.subreport[index] = value
    def export(self, outfile, level, namespace_='', name_='subreports_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='subreports_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='subreports_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='subreports_type'):
        for subreport_ in self.subreport:
            subreport_.export(outfile, level, namespace_, name_='subreport')
    def hasContent_(self):
        if (
            self.subreport
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subreports_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subreport=[\n')
        level += 1
        for subreport_ in self.subreport:
            showIndent(outfile, level)
            outfile.write('model_.subreport_type(\n')
            subreport_.exportLiteral(outfile, level, name_='subreport_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'subreport': 
            obj_ = subreport_type.factory()
            obj_.build(child_)
            self.subreport.append(obj_)
# end class subreports_type


class report_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, subreports=None):
        self.title = title
        self.subreports = subreports
    def factory(*args_, **kwargs_):
        if report_type.subclass:
            return report_type.subclass(*args_, **kwargs_)
        else:
            return report_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def validate_title(self, value):
        # validate type title
        pass
    def get_subreports(self): return self.subreports
    def set_subreports(self, subreports): self.subreports = subreports
    def export(self, outfile, level, namespace_='', name_='report_type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='report_type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='report_type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='report_type'):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('<%stitle>%s</%stitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.title).encode(ExternalEncoding), input_name='title'), namespace_))
        if self.subreports:
            self.subreports.export(outfile, level, namespace_, name_='subreports', )
    def hasContent_(self):
        if (
            self.title is not None or
            self.subreports is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='report_type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=%s,\n' % quote_python(self.title).encode(ExternalEncoding))
        if self.subreports is not None:
            showIndent(outfile, level)
            outfile.write('subreports=model_.subreports_type(\n')
            self.subreports.exportLiteral(outfile, level, name_='subreports')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'title':
            title_ = child_.text
            self.title = title_
            self.validate_title(self.title)    # validate type title
        elif nodeName_ == 'subreports': 
            obj_ = subreports_type.factory()
            obj_.build(child_)
            self.set_subreports(obj_)
# end class report_type


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'report_type'
        rootClass = report_type
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    #sys.stdout.write('<?xml version="1.0" ?>\n')
    #rootObj.export(sys.stdout, 0, name_=rootTag, 
        #namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'report_type'
        rootClass = report_type
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="report_type",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'report_type'
        rootClass = report_type
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from threatexpert import *\n\n')
    sys.stdout.write('import threatexpert as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

