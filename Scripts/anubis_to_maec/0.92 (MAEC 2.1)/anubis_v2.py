#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Tue Nov 02 11:08:11 2010 by generateDS.py version 2.2a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_str_lower(self, instring):
            return instring.lower()
                    
                    

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class analysis(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, report_version=None, configuration=None, program_options=None, summary=None, analysis_subject=None, tracked_dll=None, popups=None, global_network_activities=None, global_file_info=None, system_file_info=None):
        self.report_version = report_version
        self.configuration = configuration
        self.program_options = program_options
        self.summary = summary
        if analysis_subject is None:
            self.analysis_subject = []
        else:
            self.analysis_subject = analysis_subject
        if tracked_dll is None:
            self.tracked_dll = []
        else:
            self.tracked_dll = tracked_dll
        self.popups = popups
        self.global_network_activities = global_network_activities
        self.global_file_info = global_file_info
        self.system_file_info = system_file_info
    def factory(*args_, **kwargs_):
        if analysis.subclass:
            return analysis.subclass(*args_, **kwargs_)
        else:
            return analysis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_report_version(self): return self.report_version
    def set_report_version(self, report_version): self.report_version = report_version
    def get_configuration(self): return self.configuration
    def set_configuration(self, configuration): self.configuration = configuration
    def get_program_options(self): return self.program_options
    def set_program_options(self, program_options): self.program_options = program_options
    def get_summary(self): return self.summary
    def set_summary(self, summary): self.summary = summary
    def get_analysis_subject(self): return self.analysis_subject
    def set_analysis_subject(self, analysis_subject): self.analysis_subject = analysis_subject
    def add_analysis_subject(self, value): self.analysis_subject.append(value)
    def insert_analysis_subject(self, index, value): self.analysis_subject[index] = value
    def get_tracked_dll(self): return self.tracked_dll
    def set_tracked_dll(self, tracked_dll): self.tracked_dll = tracked_dll
    def add_tracked_dll(self, value): self.tracked_dll.append(value)
    def insert_tracked_dll(self, index, value): self.tracked_dll[index] = value
    def get_popups(self): return self.popups
    def set_popups(self, popups): self.popups = popups
    def get_global_network_activities(self): return self.global_network_activities
    def set_global_network_activities(self, global_network_activities): self.global_network_activities = global_network_activities
    def get_global_file_info(self): return self.global_file_info
    def set_global_file_info(self, global_file_info): self.global_file_info = global_file_info
    def get_system_file_info(self): return self.system_file_info
    def set_system_file_info(self, system_file_info): self.system_file_info = system_file_info
    def export(self, outfile, level, namespace_='', name_='analysis', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='analysis')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='analysis'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='analysis'):
        if self.report_version:
            self.report_version.export(outfile, level, namespace_, name_='report_version', )
        if self.configuration:
            self.configuration.export(outfile, level, namespace_, name_='configuration', )
        if self.program_options:
            self.program_options.export(outfile, level, namespace_, name_='program_options')
        if self.summary:
            self.summary.export(outfile, level, namespace_, name_='summary', )
        for analysis_subject_ in self.analysis_subject:
            analysis_subject_.export(outfile, level, namespace_, name_='analysis_subject')
        for tracked_dll_ in self.tracked_dll:
            tracked_dll_.export(outfile, level, namespace_, name_='tracked_dll')
        if self.popups:
            self.popups.export(outfile, level, namespace_, name_='popups')
        if self.global_network_activities:
            self.global_network_activities.export(outfile, level, namespace_, name_='global_network_activities')
        if self.global_file_info:
            self.global_file_info.export(outfile, level, namespace_, name_='global_file_info')
        if self.system_file_info:
            self.system_file_info.export(outfile, level, namespace_, name_='system_file_info')
    def hasContent_(self):
        if (
            self.report_version is not None or
            self.configuration is not None or
            self.program_options is not None or
            self.summary is not None or
            self.analysis_subject or
            self.tracked_dll or
            self.popups is not None or
            self.global_network_activities is not None or
            self.global_file_info is not None or
            self.system_file_info is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='analysis'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.report_version is not None:
            showIndent(outfile, level)
            outfile.write('report_version=model_.report_version(\n')
            self.report_version.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.configuration is not None:
            showIndent(outfile, level)
            outfile.write('configuration=model_.configuration(\n')
            self.configuration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.program_options is not None:
            showIndent(outfile, level)
            outfile.write('program_options=model_.program_options(\n')
            self.program_options.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.summary is not None:
            showIndent(outfile, level)
            outfile.write('summary=model_.summary(\n')
            self.summary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('analysis_subject=[\n')
        level += 1
        for analysis_subject_ in self.analysis_subject:
            showIndent(outfile, level)
            outfile.write('model_.analysis_subject(\n')
            analysis_subject_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tracked_dll=[\n')
        level += 1
        for tracked_dll_ in self.tracked_dll:
            showIndent(outfile, level)
            outfile.write('model_.tracked_dll(\n')
            tracked_dll_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.popups is not None:
            showIndent(outfile, level)
            outfile.write('popups=model_.popups(\n')
            self.popups.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.global_network_activities is not None:
            showIndent(outfile, level)
            outfile.write('global_network_activities=model_.global_network_activities(\n')
            self.global_network_activities.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.global_file_info is not None:
            showIndent(outfile, level)
            outfile.write('global_file_info=model_.global_file_info(\n')
            self.global_file_info.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.system_file_info is not None:
            showIndent(outfile, level)
            outfile.write('system_file_info=model_.system_file_info(\n')
            self.system_file_info.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'report_version': 
            obj_ = report_version.factory()
            obj_.build(child_)
            self.set_report_version(obj_)
        elif nodeName_ == 'configuration': 
            obj_ = configuration.factory()
            obj_.build(child_)
            self.set_configuration(obj_)
        elif nodeName_ == 'program_options': 
            obj_ = program_options.factory()
            obj_.build(child_)
            self.set_program_options(obj_)
        elif nodeName_ == 'summary': 
            obj_ = summary.factory()
            obj_.build(child_)
            self.set_summary(obj_)
        elif nodeName_ == 'analysis_subject': 
            obj_ = analysis_subject.factory()
            obj_.build(child_)
            self.analysis_subject.append(obj_)
        elif nodeName_ == 'tracked_dll': 
            obj_ = tracked_dll.factory()
            obj_.build(child_)
            self.tracked_dll.append(obj_)
        elif nodeName_ == 'popups': 
            obj_ = popups.factory()
            obj_.build(child_)
            self.set_popups(obj_)
        elif nodeName_ == 'global_network_activities': 
            obj_ = global_network_activities.factory()
            obj_.build(child_)
            self.set_global_network_activities(obj_)
        elif nodeName_ == 'global_file_info': 
            obj_ = global_file_info.factory()
            obj_.build(child_)
            self.set_global_file_info(obj_)
        elif nodeName_ == 'system_file_info': 
            obj_ = system_file_info.factory()
            obj_.build(child_)
            self.set_system_file_info(obj_)
# end class analysis


class report_version(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, major=None, minor=None):
        self.major = major
        self.minor = minor
    def factory(*args_, **kwargs_):
        if report_version.subclass:
            return report_version.subclass(*args_, **kwargs_)
        else:
            return report_version(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_major(self): return self.major
    def set_major(self, major): self.major = major
    def get_minor(self): return self.minor
    def set_minor(self, minor): self.minor = minor
    def export(self, outfile, level, namespace_='', name_='report_version', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='report_version')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='report_version'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='report_version'):
        if self.major is not None:
            showIndent(outfile, level)
            outfile.write('<%smajor>%s</%smajor>\n' % (namespace_, self.gds_format_integer(self.major, input_name='major'), namespace_))
        if self.minor is not None:
            showIndent(outfile, level)
            outfile.write('<%sminor>%s</%sminor>\n' % (namespace_, self.gds_format_integer(self.minor, input_name='minor'), namespace_))
    def hasContent_(self):
        if (
            self.major is not None or
            self.minor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='report_version'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.major is not None:
            showIndent(outfile, level)
            outfile.write('major=%d,\n' % self.major)
        if self.minor is not None:
            showIndent(outfile, level)
            outfile.write('minor=%d,\n' % self.minor)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'major':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.major = ival_
        elif nodeName_ == 'minor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.minor = ival_
# end class report_version


class configuration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, time_needed=None, report_created=None, termination_reason=None, ttanalyze_version=None):
        self.time_needed = time_needed
        self.report_created = report_created
        self.termination_reason = termination_reason
        self.ttanalyze_version = ttanalyze_version
    def factory(*args_, **kwargs_):
        if configuration.subclass:
            return configuration.subclass(*args_, **kwargs_)
        else:
            return configuration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time_needed(self): return self.time_needed
    def set_time_needed(self, time_needed): self.time_needed = time_needed
    def get_report_created(self): return self.report_created
    def set_report_created(self, report_created): self.report_created = report_created
    def get_termination_reason(self): return self.termination_reason
    def set_termination_reason(self, termination_reason): self.termination_reason = termination_reason
    def get_ttanalyze_version(self): return self.ttanalyze_version
    def set_ttanalyze_version(self, ttanalyze_version): self.ttanalyze_version = ttanalyze_version
    def export(self, outfile, level, namespace_='', name_='configuration', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='configuration')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='configuration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='configuration'):
        if self.time_needed is not None:
            showIndent(outfile, level)
            outfile.write('<%stime_needed>%s</%stime_needed>\n' % (namespace_, self.gds_format_string(quote_xml(self.time_needed).encode(ExternalEncoding), input_name='time_needed'), namespace_))
        if self.report_created is not None:
            showIndent(outfile, level)
            outfile.write('<%sreport_created>%s</%sreport_created>\n' % (namespace_, self.gds_format_string(quote_xml(self.report_created).encode(ExternalEncoding), input_name='report_created'), namespace_))
        if self.termination_reason is not None:
            showIndent(outfile, level)
            outfile.write('<%stermination_reason>%s</%stermination_reason>\n' % (namespace_, self.gds_format_string(quote_xml(self.termination_reason).encode(ExternalEncoding), input_name='termination_reason'), namespace_))
        if self.ttanalyze_version:
            self.ttanalyze_version.export(outfile, level, namespace_, name_='ttanalyze_version', )
    def hasContent_(self):
        if (
            self.time_needed is not None or
            self.report_created is not None or
            self.termination_reason is not None or
            self.ttanalyze_version is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='configuration'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.time_needed is not None:
            showIndent(outfile, level)
            outfile.write('time_needed=%s,\n' % quote_python(self.time_needed).encode(ExternalEncoding))
        if self.report_created is not None:
            showIndent(outfile, level)
            outfile.write('report_created=%s,\n' % quote_python(self.report_created).encode(ExternalEncoding))
        if self.termination_reason is not None:
            showIndent(outfile, level)
            outfile.write('termination_reason=%s,\n' % quote_python(self.termination_reason).encode(ExternalEncoding))
        if self.ttanalyze_version is not None:
            showIndent(outfile, level)
            outfile.write('ttanalyze_version=model_.ttanalyze_version(\n')
            self.ttanalyze_version.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'time_needed':
            time_needed_ = child_.text
            self.time_needed = time_needed_
        elif nodeName_ == 'report_created':
            report_created_ = child_.text
            self.report_created = report_created_
        elif nodeName_ == 'termination_reason':
            termination_reason_ = child_.text
            self.termination_reason = termination_reason_
        elif nodeName_ == 'ttanalyze_version': 
            obj_ = ttanalyze_version.factory()
            obj_.build(child_)
            self.set_ttanalyze_version(obj_)
# end class configuration


class ttanalyze_version(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, prog_version=None, svn_revision=None, build_date=None):
        self.prog_version = prog_version
        self.svn_revision = svn_revision
        self.build_date = build_date
    def factory(*args_, **kwargs_):
        if ttanalyze_version.subclass:
            return ttanalyze_version.subclass(*args_, **kwargs_)
        else:
            return ttanalyze_version(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_prog_version(self): return self.prog_version
    def set_prog_version(self, prog_version): self.prog_version = prog_version
    def get_svn_revision(self): return self.svn_revision
    def set_svn_revision(self, svn_revision): self.svn_revision = svn_revision
    def get_build_date(self): return self.build_date
    def set_build_date(self, build_date): self.build_date = build_date
    def export(self, outfile, level, namespace_='', name_='ttanalyze_version', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ttanalyze_version')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ttanalyze_version'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ttanalyze_version'):
        if self.prog_version is not None:
            showIndent(outfile, level)
            outfile.write('<%sprog_version>%s</%sprog_version>\n' % (namespace_, self.gds_format_string(quote_xml(self.prog_version).encode(ExternalEncoding), input_name='prog_version'), namespace_))
        if self.svn_revision is not None:
            showIndent(outfile, level)
            outfile.write('<%ssvn_revision>%s</%ssvn_revision>\n' % (namespace_, self.gds_format_string(quote_xml(self.svn_revision).encode(ExternalEncoding), input_name='svn_revision'), namespace_))
        if self.build_date is not None:
            showIndent(outfile, level)
            outfile.write('<%sbuild_date>%s</%sbuild_date>\n' % (namespace_, self.gds_format_string(quote_xml(self.build_date).encode(ExternalEncoding), input_name='build_date'), namespace_))
    def hasContent_(self):
        if (
            self.prog_version is not None or
            self.svn_revision is not None or
            self.build_date is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ttanalyze_version'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.prog_version is not None:
            showIndent(outfile, level)
            outfile.write('prog_version=%s,\n' % quote_python(self.prog_version).encode(ExternalEncoding))
        if self.svn_revision is not None:
            showIndent(outfile, level)
            outfile.write('svn_revision=%s,\n' % quote_python(self.svn_revision).encode(ExternalEncoding))
        if self.build_date is not None:
            showIndent(outfile, level)
            outfile.write('build_date=%s,\n' % quote_python(self.build_date).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'prog_version':
            prog_version_ = child_.text
            self.prog_version = prog_version_
        elif nodeName_ == 'svn_revision':
            svn_revision_ = child_.text
            self.svn_revision = svn_revision_
        elif nodeName_ == 'build_date':
            build_date_ = child_.text
            self.build_date = build_date_
# end class ttanalyze_version


class program_options(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, analyze=None, console_output=None, debug=None, disassemble=None, download_modified_files=None, fake_processes=None, host_address=None, kill_popups=None, qemu_ip=None, report_only_after_ep=None, report_only_hlf=None, show_qemu=None, tap_adapter_name=None, timeout=None, upload=None):
        self.analyze = analyze
        self.console_output = console_output
        self.debug = debug
        self.disassemble = disassemble
        self.download_modified_files = download_modified_files
        self.fake_processes = fake_processes
        self.host_address = host_address
        self.kill_popups = kill_popups
        self.qemu_ip = qemu_ip
        self.report_only_after_ep = report_only_after_ep
        self.report_only_hlf = report_only_hlf
        self.show_qemu = show_qemu
        self.tap_adapter_name = tap_adapter_name
        self.timeout = timeout
        self.upload = upload
    def factory(*args_, **kwargs_):
        if program_options.subclass:
            return program_options.subclass(*args_, **kwargs_)
        else:
            return program_options(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_analyze(self): return self.analyze
    def set_analyze(self, analyze): self.analyze = analyze
    def get_console_output(self): return self.console_output
    def set_console_output(self, console_output): self.console_output = console_output
    def get_debug(self): return self.debug
    def set_debug(self, debug): self.debug = debug
    def get_disassemble(self): return self.disassemble
    def set_disassemble(self, disassemble): self.disassemble = disassemble
    def get_download_modified_files(self): return self.download_modified_files
    def set_download_modified_files(self, download_modified_files): self.download_modified_files = download_modified_files
    def get_fake_processes(self): return self.fake_processes
    def set_fake_processes(self, fake_processes): self.fake_processes = fake_processes
    def get_host_address(self): return self.host_address
    def set_host_address(self, host_address): self.host_address = host_address
    def get_kill_popups(self): return self.kill_popups
    def set_kill_popups(self, kill_popups): self.kill_popups = kill_popups
    def get_qemu_ip(self): return self.qemu_ip
    def set_qemu_ip(self, qemu_ip): self.qemu_ip = qemu_ip
    def get_report_only_after_ep(self): return self.report_only_after_ep
    def set_report_only_after_ep(self, report_only_after_ep): self.report_only_after_ep = report_only_after_ep
    def get_report_only_hlf(self): return self.report_only_hlf
    def set_report_only_hlf(self, report_only_hlf): self.report_only_hlf = report_only_hlf
    def get_show_qemu(self): return self.show_qemu
    def set_show_qemu(self, show_qemu): self.show_qemu = show_qemu
    def get_tap_adapter_name(self): return self.tap_adapter_name
    def set_tap_adapter_name(self, tap_adapter_name): self.tap_adapter_name = tap_adapter_name
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def get_upload(self): return self.upload
    def set_upload(self, upload): self.upload = upload
    def export(self, outfile, level, namespace_='', name_='program_options', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='program_options')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='program_options'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='program_options'):
        if self.analyze is not None:
            showIndent(outfile, level)
            outfile.write('<%sanalyze>%s</%sanalyze>\n' % (namespace_, self.gds_format_string(quote_xml(self.analyze).encode(ExternalEncoding), input_name='analyze'), namespace_))
        if self.console_output is not None:
            showIndent(outfile, level)
            outfile.write('<%sconsole-output>%s</%sconsole-output>\n' % (namespace_, self.gds_format_string(quote_xml(self.console_output).encode(ExternalEncoding), input_name='console-output'), namespace_))
        if self.debug is not None:
            showIndent(outfile, level)
            outfile.write('<%sdebug>%s</%sdebug>\n' % (namespace_, self.gds_format_string(quote_xml(self.debug).encode(ExternalEncoding), input_name='debug'), namespace_))
        if self.disassemble is not None:
            showIndent(outfile, level)
            outfile.write('<%sdisassemble>%s</%sdisassemble>\n' % (namespace_, self.gds_format_string(quote_xml(self.disassemble).encode(ExternalEncoding), input_name='disassemble'), namespace_))
        if self.download_modified_files is not None:
            showIndent(outfile, level)
            outfile.write('<%sdownload-modified-files>%s</%sdownload-modified-files>\n' % (namespace_, self.gds_format_string(quote_xml(self.download_modified_files).encode(ExternalEncoding), input_name='download-modified-files'), namespace_))
        if self.fake_processes is not None:
            showIndent(outfile, level)
            outfile.write('<%sfake-processes>%s</%sfake-processes>\n' % (namespace_, self.gds_format_string(quote_xml(self.fake_processes).encode(ExternalEncoding), input_name='fake-processes'), namespace_))
        if self.host_address is not None:
            showIndent(outfile, level)
            outfile.write('<%shost-address>%s</%shost-address>\n' % (namespace_, self.gds_format_string(quote_xml(self.host_address).encode(ExternalEncoding), input_name='host-address'), namespace_))
        if self.kill_popups is not None:
            showIndent(outfile, level)
            outfile.write('<%skill-popups>%s</%skill-popups>\n' % (namespace_, self.gds_format_string(quote_xml(self.kill_popups).encode(ExternalEncoding), input_name='kill-popups'), namespace_))
        if self.qemu_ip is not None:
            showIndent(outfile, level)
            outfile.write('<%sqemu-ip>%s</%sqemu-ip>\n' % (namespace_, self.gds_format_string(quote_xml(self.qemu_ip).encode(ExternalEncoding), input_name='qemu-ip'), namespace_))
        if self.report_only_after_ep is not None:
            showIndent(outfile, level)
            outfile.write('<%sreport-only-after-ep>%s</%sreport-only-after-ep>\n' % (namespace_, self.gds_format_string(quote_xml(self.report_only_after_ep).encode(ExternalEncoding), input_name='report-only-after-ep'), namespace_))
        if self.report_only_hlf is not None:
            showIndent(outfile, level)
            outfile.write('<%sreport-only-hlf>%s</%sreport-only-hlf>\n' % (namespace_, self.gds_format_string(quote_xml(self.report_only_hlf).encode(ExternalEncoding), input_name='report-only-hlf'), namespace_))
        if self.show_qemu is not None:
            showIndent(outfile, level)
            outfile.write('<%sshow-qemu>%s</%sshow-qemu>\n' % (namespace_, self.gds_format_string(quote_xml(self.show_qemu).encode(ExternalEncoding), input_name='show-qemu'), namespace_))
        if self.tap_adapter_name is not None:
            showIndent(outfile, level)
            outfile.write('<%stap-adapter-name>%s</%stap-adapter-name>\n' % (namespace_, self.gds_format_string(quote_xml(self.tap_adapter_name).encode(ExternalEncoding), input_name='tap-adapter-name'), namespace_))
        if self.timeout is not None:
            showIndent(outfile, level)
            outfile.write('<%stimeout>%s</%stimeout>\n' % (namespace_, self.gds_format_string(quote_xml(self.timeout).encode(ExternalEncoding), input_name='timeout'), namespace_))
        if self.upload is not None:
            showIndent(outfile, level)
            outfile.write('<%supload>%s</%supload>\n' % (namespace_, self.gds_format_string(quote_xml(self.upload).encode(ExternalEncoding), input_name='upload'), namespace_))
    def hasContent_(self):
        if (
            self.analyze is not None or
            self.console_output is not None or
            self.debug is not None or
            self.disassemble is not None or
            self.download_modified_files is not None or
            self.fake_processes is not None or
            self.host_address is not None or
            self.kill_popups is not None or
            self.qemu_ip is not None or
            self.report_only_after_ep is not None or
            self.report_only_hlf is not None or
            self.show_qemu is not None or
            self.tap_adapter_name is not None or
            self.timeout is not None or
            self.upload is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='program_options'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.analyze is not None:
            showIndent(outfile, level)
            outfile.write('analyze=%s,\n' % quote_python(self.analyze).encode(ExternalEncoding))
        if self.console_output is not None:
            showIndent(outfile, level)
            outfile.write('console_output=%s,\n' % quote_python(self.console_output).encode(ExternalEncoding))
        if self.debug is not None:
            showIndent(outfile, level)
            outfile.write('debug=%s,\n' % quote_python(self.debug).encode(ExternalEncoding))
        if self.disassemble is not None:
            showIndent(outfile, level)
            outfile.write('disassemble=%s,\n' % quote_python(self.disassemble).encode(ExternalEncoding))
        if self.download_modified_files is not None:
            showIndent(outfile, level)
            outfile.write('download_modified_files=%s,\n' % quote_python(self.download_modified_files).encode(ExternalEncoding))
        if self.fake_processes is not None:
            showIndent(outfile, level)
            outfile.write('fake_processes=%s,\n' % quote_python(self.fake_processes).encode(ExternalEncoding))
        if self.host_address is not None:
            showIndent(outfile, level)
            outfile.write('host_address=%s,\n' % quote_python(self.host_address).encode(ExternalEncoding))
        if self.kill_popups is not None:
            showIndent(outfile, level)
            outfile.write('kill_popups=%s,\n' % quote_python(self.kill_popups).encode(ExternalEncoding))
        if self.qemu_ip is not None:
            showIndent(outfile, level)
            outfile.write('qemu_ip=%s,\n' % quote_python(self.qemu_ip).encode(ExternalEncoding))
        if self.report_only_after_ep is not None:
            showIndent(outfile, level)
            outfile.write('report_only_after_ep=%s,\n' % quote_python(self.report_only_after_ep).encode(ExternalEncoding))
        if self.report_only_hlf is not None:
            showIndent(outfile, level)
            outfile.write('report_only_hlf=%s,\n' % quote_python(self.report_only_hlf).encode(ExternalEncoding))
        if self.show_qemu is not None:
            showIndent(outfile, level)
            outfile.write('show_qemu=%s,\n' % quote_python(self.show_qemu).encode(ExternalEncoding))
        if self.tap_adapter_name is not None:
            showIndent(outfile, level)
            outfile.write('tap_adapter_name=%s,\n' % quote_python(self.tap_adapter_name).encode(ExternalEncoding))
        if self.timeout is not None:
            showIndent(outfile, level)
            outfile.write('timeout=%s,\n' % quote_python(self.timeout).encode(ExternalEncoding))
        if self.upload is not None:
            showIndent(outfile, level)
            outfile.write('upload=%s,\n' % quote_python(self.upload).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'analyze':
            analyze_ = child_.text
            self.analyze = analyze_
        elif nodeName_ == 'console-output':
            console_output_ = child_.text
            self.console_output = console_output_
        elif nodeName_ == 'debug':
            debug_ = child_.text
            self.debug = debug_
        elif nodeName_ == 'disassemble':
            disassemble_ = child_.text
            self.disassemble = disassemble_
        elif nodeName_ == 'download-modified-files':
            download_modified_files_ = child_.text
            self.download_modified_files = download_modified_files_
        elif nodeName_ == 'fake-processes':
            fake_processes_ = child_.text
            self.fake_processes = fake_processes_
        elif nodeName_ == 'host-address':
            host_address_ = child_.text
            self.host_address = host_address_
        elif nodeName_ == 'kill-popups':
            kill_popups_ = child_.text
            self.kill_popups = kill_popups_
        elif nodeName_ == 'qemu-ip':
            qemu_ip_ = child_.text
            self.qemu_ip = qemu_ip_
        elif nodeName_ == 'report-only-after-ep':
            report_only_after_ep_ = child_.text
            self.report_only_after_ep = report_only_after_ep_
        elif nodeName_ == 'report-only-hlf':
            report_only_hlf_ = child_.text
            self.report_only_hlf = report_only_hlf_
        elif nodeName_ == 'show-qemu':
            show_qemu_ = child_.text
            self.show_qemu = show_qemu_
        elif nodeName_ == 'tap-adapter-name':
            tap_adapter_name_ = child_.text
            self.tap_adapter_name = tap_adapter_name_
        elif nodeName_ == 'timeout':
            timeout_ = child_.text
            self.timeout = timeout_
        elif nodeName_ == 'upload':
            upload_ = child_.text
            self.upload = upload_
# end class program_options


class summary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, auto_start=None, internet_settings=None, bho=None, win_dir_copy=None, av_kill=None, com_object=None, dlf=None, ircbot=None, spambot=None, addressscan=None, portscan=None):
        self.auto_start = auto_start
        self.internet_settings = internet_settings
        self.bho = bho
        self.win_dir_copy = win_dir_copy
        self.av_kill = av_kill
        self.com_object = com_object
        self.dlf = dlf
        self.ircbot = ircbot
        self.spambot = spambot
        self.addressscan = addressscan
        self.portscan = portscan
    def factory(*args_, **kwargs_):
        if summary.subclass:
            return summary.subclass(*args_, **kwargs_)
        else:
            return summary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_auto_start(self): return self.auto_start
    def set_auto_start(self, auto_start): self.auto_start = auto_start
    def get_internet_settings(self): return self.internet_settings
    def set_internet_settings(self, internet_settings): self.internet_settings = internet_settings
    def get_bho(self): return self.bho
    def set_bho(self, bho): self.bho = bho
    def get_win_dir_copy(self): return self.win_dir_copy
    def set_win_dir_copy(self, win_dir_copy): self.win_dir_copy = win_dir_copy
    def get_av_kill(self): return self.av_kill
    def set_av_kill(self, av_kill): self.av_kill = av_kill
    def get_com_object(self): return self.com_object
    def set_com_object(self, com_object): self.com_object = com_object
    def get_dlf(self): return self.dlf
    def set_dlf(self, dlf): self.dlf = dlf
    def get_ircbot(self): return self.ircbot
    def set_ircbot(self, ircbot): self.ircbot = ircbot
    def get_spambot(self): return self.spambot
    def set_spambot(self, spambot): self.spambot = spambot
    def get_addressscan(self): return self.addressscan
    def set_addressscan(self, addressscan): self.addressscan = addressscan
    def get_portscan(self): return self.portscan
    def set_portscan(self, portscan): self.portscan = portscan
    def export(self, outfile, level, namespace_='', name_='summary', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='summary')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='summary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='summary'):
        if self.auto_start is not None:
            showIndent(outfile, level)
            outfile.write('<%sauto_start>%s</%sauto_start>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.auto_start)), input_name='auto_start'), namespace_))
        if self.internet_settings is not None:
            showIndent(outfile, level)
            outfile.write('<%sinternet_settings>%s</%sinternet_settings>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.internet_settings)), input_name='internet_settings'), namespace_))
        if self.bho is not None:
            showIndent(outfile, level)
            outfile.write('<%sbho>%s</%sbho>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.bho)), input_name='bho'), namespace_))
        if self.win_dir_copy is not None:
            showIndent(outfile, level)
            outfile.write('<%swin_dir_copy>%s</%swin_dir_copy>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.win_dir_copy)), input_name='win_dir_copy'), namespace_))
        if self.av_kill is not None:
            showIndent(outfile, level)
            outfile.write('<%sav_kill>%s</%sav_kill>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.av_kill)), input_name='av_kill'), namespace_))
        if self.com_object is not None:
            showIndent(outfile, level)
            outfile.write('<%scom_object>%s</%scom_object>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.com_object)), input_name='com_object'), namespace_))
        if self.dlf is not None:
            showIndent(outfile, level)
            outfile.write('<%sdlf>%s</%sdlf>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.dlf)), input_name='dlf'), namespace_))
        if self.ircbot is not None:
            showIndent(outfile, level)
            outfile.write('<%sircbot>%s</%sircbot>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.ircbot)), input_name='ircbot'), namespace_))
        if self.spambot is not None:
            showIndent(outfile, level)
            outfile.write('<%sspambot>%s</%sspambot>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.spambot)), input_name='spambot'), namespace_))
        if self.addressscan is not None:
            showIndent(outfile, level)
            outfile.write('<%saddressscan>%s</%saddressscan>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.addressscan)), input_name='addressscan'), namespace_))
        if self.portscan is not None:
            showIndent(outfile, level)
            outfile.write('<%sportscan>%s</%sportscan>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.portscan)), input_name='portscan'), namespace_))
    def hasContent_(self):
        if (
            self.auto_start is not None or
            self.internet_settings is not None or
            self.bho is not None or
            self.win_dir_copy is not None or
            self.av_kill is not None or
            self.com_object is not None or
            self.dlf is not None or
            self.ircbot is not None or
            self.spambot is not None or
            self.addressscan is not None or
            self.portscan is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='summary'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.auto_start is not None:
            showIndent(outfile, level)
            outfile.write('auto_start=%s,\n' % self.auto_start)
        if self.internet_settings is not None:
            showIndent(outfile, level)
            outfile.write('internet_settings=%s,\n' % self.internet_settings)
        if self.bho is not None:
            showIndent(outfile, level)
            outfile.write('bho=%s,\n' % self.bho)
        if self.win_dir_copy is not None:
            showIndent(outfile, level)
            outfile.write('win_dir_copy=%s,\n' % self.win_dir_copy)
        if self.av_kill is not None:
            showIndent(outfile, level)
            outfile.write('av_kill=%s,\n' % self.av_kill)
        if self.com_object is not None:
            showIndent(outfile, level)
            outfile.write('com_object=%s,\n' % self.com_object)
        if self.dlf is not None:
            showIndent(outfile, level)
            outfile.write('dlf=%s,\n' % self.dlf)
        if self.ircbot is not None:
            showIndent(outfile, level)
            outfile.write('ircbot=%s,\n' % self.ircbot)
        if self.spambot is not None:
            showIndent(outfile, level)
            outfile.write('spambot=%s,\n' % self.spambot)
        if self.addressscan is not None:
            showIndent(outfile, level)
            outfile.write('addressscan=%s,\n' % self.addressscan)
        if self.portscan is not None:
            showIndent(outfile, level)
            outfile.write('portscan=%s,\n' % self.portscan)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'auto_start':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.auto_start = ival_
        elif nodeName_ == 'internet_settings':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.internet_settings = ival_
        elif nodeName_ == 'bho':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.bho = ival_
        elif nodeName_ == 'win_dir_copy':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.win_dir_copy = ival_
        elif nodeName_ == 'av_kill':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.av_kill = ival_
        elif nodeName_ == 'com_object':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.com_object = ival_
        elif nodeName_ == 'dlf':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.dlf = ival_
        elif nodeName_ == 'ircbot':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.ircbot = ival_
        elif nodeName_ == 'spambot':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.spambot = ival_
        elif nodeName_ == 'addressscan':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.addressscan = ival_
        elif nodeName_ == 'portscan':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.portscan = ival_
# end class summary


class analysis_subject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, general=None, dll_dependencies=None, peid=None, sigbuster=None, ikarus_scanner=None, program_output=None, popups=None, activities=None, anubis_evasion=None):
        self.general = general
        self.dll_dependencies = dll_dependencies
        self.peid = peid
        self.sigbuster = sigbuster
        self.ikarus_scanner = ikarus_scanner
        self.program_output = program_output
        self.popups = popups
        self.activities = activities
        self.anubis_evasion = anubis_evasion
    def factory(*args_, **kwargs_):
        if analysis_subject.subclass:
            return analysis_subject.subclass(*args_, **kwargs_)
        else:
            return analysis_subject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_general(self): return self.general
    def set_general(self, general): self.general = general
    def get_dll_dependencies(self): return self.dll_dependencies
    def set_dll_dependencies(self, dll_dependencies): self.dll_dependencies = dll_dependencies
    def get_peid(self): return self.peid
    def set_peid(self, peid): self.peid = peid
    def get_sigbuster(self): return self.sigbuster
    def set_sigbuster(self, sigbuster): self.sigbuster = sigbuster
    def get_ikarus_scanner(self): return self.ikarus_scanner
    def set_ikarus_scanner(self, ikarus_scanner): self.ikarus_scanner = ikarus_scanner
    def get_program_output(self): return self.program_output
    def set_program_output(self, program_output): self.program_output = program_output
    def get_popups(self): return self.popups
    def set_popups(self, popups): self.popups = popups
    def get_activities(self): return self.activities
    def set_activities(self, activities): self.activities = activities
    def get_anubis_evasion(self): return self.anubis_evasion
    def set_anubis_evasion(self, anubis_evasion): self.anubis_evasion = anubis_evasion
    def export(self, outfile, level, namespace_='', name_='analysis_subject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='analysis_subject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='analysis_subject'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='analysis_subject'):
        if self.general:
            self.general.export(outfile, level, namespace_, name_='general', )
        if self.dll_dependencies:
            self.dll_dependencies.export(outfile, level, namespace_, name_='dll_dependencies')
        if self.peid is not None:
            showIndent(outfile, level)
            outfile.write('<%speid>%s</%speid>\n' % (namespace_, self.gds_format_string(quote_xml(self.peid).encode(ExternalEncoding), input_name='peid'), namespace_))
        if self.sigbuster is not None:
            showIndent(outfile, level)
            outfile.write('<%ssigbuster>%s</%ssigbuster>\n' % (namespace_, self.gds_format_string(quote_xml(self.sigbuster).encode(ExternalEncoding), input_name='sigbuster'), namespace_))
        if self.ikarus_scanner:
            self.ikarus_scanner.export(outfile, level, namespace_, name_='ikarus_scanner')
        if self.program_output:
            self.program_output.export(outfile, level, namespace_, name_='program_output')
        if self.popups:
            self.popups.export(outfile, level, namespace_, name_='popups')
        if self.activities:
            self.activities.export(outfile, level, namespace_, name_='activities')
        if self.anubis_evasion:
            self.anubis_evasion.export(outfile, level, namespace_, name_='anubis_evasion')
    def hasContent_(self):
        if (
            self.general is not None or
            self.dll_dependencies is not None or
            self.peid is not None or
            self.sigbuster is not None or
            self.ikarus_scanner is not None or
            self.program_output is not None or
            self.popups is not None or
            self.activities is not None or
            self.anubis_evasion is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='analysis_subject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.general is not None:
            showIndent(outfile, level)
            outfile.write('general=model_.general(\n')
            self.general.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dll_dependencies is not None:
            showIndent(outfile, level)
            outfile.write('dll_dependencies=model_.dll_dependencies(\n')
            self.dll_dependencies.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.peid is not None:
            showIndent(outfile, level)
            outfile.write('peid=%s,\n' % quote_python(self.peid).encode(ExternalEncoding))
        if self.sigbuster is not None:
            showIndent(outfile, level)
            outfile.write('sigbuster=%s,\n' % quote_python(self.sigbuster).encode(ExternalEncoding))
        if self.ikarus_scanner is not None:
            showIndent(outfile, level)
            outfile.write('ikarus_scanner=model_.ikarus_scanner(\n')
            self.ikarus_scanner.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.program_output is not None:
            showIndent(outfile, level)
            outfile.write('program_output=model_.program_output(\n')
            self.program_output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.popups is not None:
            showIndent(outfile, level)
            outfile.write('popups=model_.popups(\n')
            self.popups.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.activities is not None:
            showIndent(outfile, level)
            outfile.write('activities=model_.activities(\n')
            self.activities.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.anubis_evasion is not None:
            showIndent(outfile, level)
            outfile.write('anubis_evasion=model_.anubis_evasion(\n')
            self.anubis_evasion.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'general': 
            obj_ = general.factory()
            obj_.build(child_)
            self.set_general(obj_)
        elif nodeName_ == 'dll_dependencies': 
            obj_ = dll_dependencies.factory()
            obj_.build(child_)
            self.set_dll_dependencies(obj_)
        elif nodeName_ == 'peid':
            peid_ = child_.text
            self.peid = peid_
        elif nodeName_ == 'sigbuster':
            sigbuster_ = child_.text
            self.sigbuster = sigbuster_
        elif nodeName_ == 'ikarus_scanner': 
            obj_ = ikarus_scanner.factory()
            obj_.build(child_)
            self.set_ikarus_scanner(obj_)
        elif nodeName_ == 'program_output': 
            obj_ = program_output.factory()
            obj_.build(child_)
            self.set_program_output(obj_)
        elif nodeName_ == 'popups': 
            obj_ = popups.factory()
            obj_.build(child_)
            self.set_popups(obj_)
        elif nodeName_ == 'activities': 
            obj_ = activities.factory()
            obj_.build(child_)
            self.set_activities(obj_)
        elif nodeName_ == 'anubis_evasion': 
            obj_ = anubis_evasion.factory()
            obj_.build(child_)
            self.set_anubis_evasion(obj_)
# end class analysis_subject


class tracked_dll(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, general=None, dll_dependencies=None, peid=None, sigbuster=None, ikarus_scanner=None, program_output=None, popups=None, activities=None):
        self.general = general
        self.dll_dependencies = dll_dependencies
        self.peid = peid
        self.sigbuster = sigbuster
        self.ikarus_scanner = ikarus_scanner
        self.program_output = program_output
        self.popups = popups
        self.activities = activities
    def factory(*args_, **kwargs_):
        if tracked_dll.subclass:
            return tracked_dll.subclass(*args_, **kwargs_)
        else:
            return tracked_dll(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_general(self): return self.general
    def set_general(self, general): self.general = general
    def get_dll_dependencies(self): return self.dll_dependencies
    def set_dll_dependencies(self, dll_dependencies): self.dll_dependencies = dll_dependencies
    def get_peid(self): return self.peid
    def set_peid(self, peid): self.peid = peid
    def get_sigbuster(self): return self.sigbuster
    def set_sigbuster(self, sigbuster): self.sigbuster = sigbuster
    def get_ikarus_scanner(self): return self.ikarus_scanner
    def set_ikarus_scanner(self, ikarus_scanner): self.ikarus_scanner = ikarus_scanner
    def get_program_output(self): return self.program_output
    def set_program_output(self, program_output): self.program_output = program_output
    def get_popups(self): return self.popups
    def set_popups(self, popups): self.popups = popups
    def get_activities(self): return self.activities
    def set_activities(self, activities): self.activities = activities
    def export(self, outfile, level, namespace_='', name_='tracked_dll', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='tracked_dll')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='tracked_dll'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tracked_dll'):
        if self.general:
            self.general.export(outfile, level, namespace_, name_='general', )
        if self.dll_dependencies:
            self.dll_dependencies.export(outfile, level, namespace_, name_='dll_dependencies')
        if self.peid is not None:
            showIndent(outfile, level)
            outfile.write('<%speid>%s</%speid>\n' % (namespace_, self.gds_format_string(quote_xml(self.peid).encode(ExternalEncoding), input_name='peid'), namespace_))
        if self.sigbuster is not None:
            showIndent(outfile, level)
            outfile.write('<%ssigbuster>%s</%ssigbuster>\n' % (namespace_, self.gds_format_string(quote_xml(self.sigbuster).encode(ExternalEncoding), input_name='sigbuster'), namespace_))
        if self.ikarus_scanner:
            self.ikarus_scanner.export(outfile, level, namespace_, name_='ikarus_scanner')
        if self.program_output:
            self.program_output.export(outfile, level, namespace_, name_='program_output')
        if self.popups:
            self.popups.export(outfile, level, namespace_, name_='popups')
        if self.activities:
            self.activities.export(outfile, level, namespace_, name_='activities')
    def hasContent_(self):
        if (
            self.general is not None or
            self.dll_dependencies is not None or
            self.peid is not None or
            self.sigbuster is not None or
            self.ikarus_scanner is not None or
            self.program_output is not None or
            self.popups is not None or
            self.activities is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='tracked_dll'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.general is not None:
            showIndent(outfile, level)
            outfile.write('general=model_.general(\n')
            self.general.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dll_dependencies is not None:
            showIndent(outfile, level)
            outfile.write('dll_dependencies=model_.dll_dependencies(\n')
            self.dll_dependencies.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.peid is not None:
            showIndent(outfile, level)
            outfile.write('peid=%s,\n' % quote_python(self.peid).encode(ExternalEncoding))
        if self.sigbuster is not None:
            showIndent(outfile, level)
            outfile.write('sigbuster=%s,\n' % quote_python(self.sigbuster).encode(ExternalEncoding))
        if self.ikarus_scanner is not None:
            showIndent(outfile, level)
            outfile.write('ikarus_scanner=model_.ikarus_scanner(\n')
            self.ikarus_scanner.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.program_output is not None:
            showIndent(outfile, level)
            outfile.write('program_output=model_.program_output(\n')
            self.program_output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.popups is not None:
            showIndent(outfile, level)
            outfile.write('popups=model_.popups(\n')
            self.popups.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.activities is not None:
            showIndent(outfile, level)
            outfile.write('activities=model_.activities(\n')
            self.activities.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'general': 
            obj_ = general.factory()
            obj_.build(child_)
            self.set_general(obj_)
        elif nodeName_ == 'dll_dependencies': 
            obj_ = dll_dependencies.factory()
            obj_.build(child_)
            self.set_dll_dependencies(obj_)
        elif nodeName_ == 'peid':
            peid_ = child_.text
            self.peid = peid_
        elif nodeName_ == 'sigbuster':
            sigbuster_ = child_.text
            self.sigbuster = sigbuster_
        elif nodeName_ == 'ikarus_scanner': 
            obj_ = ikarus_scanner.factory()
            obj_.build(child_)
            self.set_ikarus_scanner(obj_)
        elif nodeName_ == 'program_output': 
            obj_ = program_output.factory()
            obj_.build(child_)
            self.set_program_output(obj_)
        elif nodeName_ == 'popups': 
            obj_ = popups.factory()
            obj_.build(child_)
            self.set_popups(obj_)
        elif nodeName_ == 'activities': 
            obj_ = activities.factory()
            obj_.build(child_)
            self.set_activities(obj_)
# end class tracked_dll


class general(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, parent_id=None, analysis_reason=None, submission_fn=None, virtual_fn=None, virtual_path=None, md5=None, sha1=None, crc32=None, file_size=None, arguments=None, status=None, exit_code=None):
        self.id = id
        self.parent_id = parent_id
        self.analysis_reason = analysis_reason
        self.submission_fn = submission_fn
        self.virtual_fn = virtual_fn
        self.virtual_path = virtual_path
        self.md5 = md5
        self.sha1 = sha1
        self.crc32 = crc32
        self.file_size = file_size
        self.arguments = arguments
        self.status = status
        self.exit_code = exit_code
    def factory(*args_, **kwargs_):
        if general.subclass:
            return general.subclass(*args_, **kwargs_)
        else:
            return general(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_parent_id(self): return self.parent_id
    def set_parent_id(self, parent_id): self.parent_id = parent_id
    def get_analysis_reason(self): return self.analysis_reason
    def set_analysis_reason(self, analysis_reason): self.analysis_reason = analysis_reason
    def get_submission_fn(self): return self.submission_fn
    def set_submission_fn(self, submission_fn): self.submission_fn = submission_fn
    def get_virtual_fn(self): return self.virtual_fn
    def set_virtual_fn(self, virtual_fn): self.virtual_fn = virtual_fn
    def get_virtual_path(self): return self.virtual_path
    def set_virtual_path(self, virtual_path): self.virtual_path = virtual_path
    def get_md5(self): return self.md5
    def set_md5(self, md5): self.md5 = md5
    def get_sha1(self): return self.sha1
    def set_sha1(self, sha1): self.sha1 = sha1
    def get_crc32(self): return self.crc32
    def set_crc32(self, crc32): self.crc32 = crc32
    def get_file_size(self): return self.file_size
    def set_file_size(self, file_size): self.file_size = file_size
    def get_arguments(self): return self.arguments
    def set_arguments(self, arguments): self.arguments = arguments
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_exit_code(self): return self.exit_code
    def set_exit_code(self, exit_code): self.exit_code = exit_code
    def export(self, outfile, level, namespace_='', name_='general', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='general')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='general'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='general'):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('<%sid>%s</%sid>\n' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_))
        if self.parent_id is not None:
            showIndent(outfile, level)
            outfile.write('<%sparent_id>%s</%sparent_id>\n' % (namespace_, self.gds_format_integer(self.parent_id, input_name='parent_id'), namespace_))
        if self.analysis_reason is not None:
            showIndent(outfile, level)
            outfile.write('<%sanalysis_reason>%s</%sanalysis_reason>\n' % (namespace_, self.gds_format_string(quote_xml(self.analysis_reason).encode(ExternalEncoding), input_name='analysis_reason'), namespace_))
        if self.submission_fn is not None:
            showIndent(outfile, level)
            outfile.write('<%ssubmission_fn>%s</%ssubmission_fn>\n' % (namespace_, self.gds_format_string(quote_xml(self.submission_fn).encode(ExternalEncoding), input_name='submission_fn'), namespace_))
        if self.virtual_fn is not None:
            showIndent(outfile, level)
            outfile.write('<%svirtual_fn>%s</%svirtual_fn>\n' % (namespace_, self.gds_format_string(quote_xml(self.virtual_fn).encode(ExternalEncoding), input_name='virtual_fn'), namespace_))
        if self.virtual_path is not None:
            showIndent(outfile, level)
            outfile.write('<%svirtual_path>%s</%svirtual_path>\n' % (namespace_, self.gds_format_string(quote_xml(self.virtual_path).encode(ExternalEncoding), input_name='virtual_path'), namespace_))
        if self.md5 is not None:
            showIndent(outfile, level)
            outfile.write('<%smd5>%s</%smd5>\n' % (namespace_, self.gds_format_string(quote_xml(self.md5).encode(ExternalEncoding), input_name='md5'), namespace_))
        if self.sha1 is not None:
            showIndent(outfile, level)
            outfile.write('<%ssha1>%s</%ssha1>\n' % (namespace_, self.gds_format_string(quote_xml(self.sha1).encode(ExternalEncoding), input_name='sha1'), namespace_))
        if self.crc32 is not None:
            showIndent(outfile, level)
            outfile.write('<%scrc32>%s</%scrc32>\n' % (namespace_, self.gds_format_string(quote_xml(self.crc32).encode(ExternalEncoding), input_name='crc32'), namespace_))
        if self.file_size is not None:
            showIndent(outfile, level)
            outfile.write('<%sfile_size>%s</%sfile_size>\n' % (namespace_, self.gds_format_string(quote_xml(self.file_size).encode(ExternalEncoding), input_name='file_size'), namespace_))
        if self.arguments is not None:
            showIndent(outfile, level)
            outfile.write('<%sarguments>%s</%sarguments>\n' % (namespace_, self.gds_format_string(quote_xml(self.arguments).encode(ExternalEncoding), input_name='arguments'), namespace_))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('<%sstatus>%s</%sstatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.status).encode(ExternalEncoding), input_name='status'), namespace_))
        if self.exit_code is not None:
            showIndent(outfile, level)
            outfile.write('<%sexit_code>%s</%sexit_code>\n' % (namespace_, self.gds_format_integer(self.exit_code, input_name='exit_code'), namespace_))
    def hasContent_(self):
        if (
            self.id is not None or
            self.parent_id is not None or
            self.analysis_reason is not None or
            self.submission_fn is not None or
            self.virtual_fn is not None or
            self.virtual_path is not None or
            self.md5 is not None or
            self.sha1 is not None or
            self.crc32 is not None or
            self.file_size is not None or
            self.arguments is not None or
            self.status is not None or
            self.exit_code is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='general'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.parent_id is not None:
            showIndent(outfile, level)
            outfile.write('parent_id=%d,\n' % self.parent_id)
        if self.analysis_reason is not None:
            showIndent(outfile, level)
            outfile.write('analysis_reason=%s,\n' % quote_python(self.analysis_reason).encode(ExternalEncoding))
        if self.submission_fn is not None:
            showIndent(outfile, level)
            outfile.write('submission_fn=%s,\n' % quote_python(self.submission_fn).encode(ExternalEncoding))
        if self.virtual_fn is not None:
            showIndent(outfile, level)
            outfile.write('virtual_fn=%s,\n' % quote_python(self.virtual_fn).encode(ExternalEncoding))
        if self.virtual_path is not None:
            showIndent(outfile, level)
            outfile.write('virtual_path=%s,\n' % quote_python(self.virtual_path).encode(ExternalEncoding))
        if self.md5 is not None:
            showIndent(outfile, level)
            outfile.write('md5=%s,\n' % quote_python(self.md5).encode(ExternalEncoding))
        if self.sha1 is not None:
            showIndent(outfile, level)
            outfile.write('sha1=%s,\n' % quote_python(self.sha1).encode(ExternalEncoding))
        if self.crc32 is not None:
            showIndent(outfile, level)
            outfile.write('crc32=%s,\n' % quote_python(self.crc32).encode(ExternalEncoding))
        if self.file_size is not None:
            showIndent(outfile, level)
            outfile.write('file_size=%s,\n' % quote_python(self.file_size).encode(ExternalEncoding))
        if self.arguments is not None:
            showIndent(outfile, level)
            outfile.write('arguments=%s,\n' % quote_python(self.arguments).encode(ExternalEncoding))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % quote_python(self.status).encode(ExternalEncoding))
        if self.exit_code is not None:
            showIndent(outfile, level)
            outfile.write('exit_code=%d,\n' % self.exit_code)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.id = ival_
        elif nodeName_ == 'parent_id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.parent_id = ival_
        elif nodeName_ == 'analysis_reason':
            analysis_reason_ = child_.text
            self.analysis_reason = analysis_reason_
        elif nodeName_ == 'submission_fn':
            submission_fn_ = child_.text
            self.submission_fn = submission_fn_
        elif nodeName_ == 'virtual_fn':
            virtual_fn_ = child_.text
            self.virtual_fn = virtual_fn_
        elif nodeName_ == 'virtual_path':
            virtual_path_ = child_.text
            self.virtual_path = virtual_path_
        elif nodeName_ == 'md5':
            md5_ = child_.text
            self.md5 = md5_
        elif nodeName_ == 'sha1':
            sha1_ = child_.text
            self.sha1 = sha1_
        elif nodeName_ == 'crc32':
            crc32_ = child_.text
            self.crc32 = crc32_
        elif nodeName_ == 'file_size':
            file_size_ = child_.text
            self.file_size = file_size_
        elif nodeName_ == 'arguments':
            arguments_ = child_.text
            self.arguments = arguments_
        elif nodeName_ == 'status':
            status_ = child_.text
            self.status = status_
        elif nodeName_ == 'exit_code':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.exit_code = ival_
# end class general


class dll_dependencies(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, loaded_dll=None):
        if loaded_dll is None:
            self.loaded_dll = []
        else:
            self.loaded_dll = loaded_dll
    def factory(*args_, **kwargs_):
        if dll_dependencies.subclass:
            return dll_dependencies.subclass(*args_, **kwargs_)
        else:
            return dll_dependencies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_loaded_dll(self): return self.loaded_dll
    def set_loaded_dll(self, loaded_dll): self.loaded_dll = loaded_dll
    def add_loaded_dll(self, value): self.loaded_dll.append(value)
    def insert_loaded_dll(self, index, value): self.loaded_dll[index] = value
    def export(self, outfile, level, namespace_='', name_='dll_dependencies', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dll_dependencies')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='dll_dependencies'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dll_dependencies'):
        for loaded_dll_ in self.loaded_dll:
            loaded_dll_.export(outfile, level, namespace_, name_='loaded_dll')
    def hasContent_(self):
        if (
            self.loaded_dll
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dll_dependencies'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('loaded_dll=[\n')
        level += 1
        for loaded_dll_ in self.loaded_dll:
            showIndent(outfile, level)
            outfile.write('model_.loaded_dll(\n')
            loaded_dll_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'loaded_dll': 
            obj_ = loaded_dll.factory()
            obj_.build(child_)
            self.loaded_dll.append(obj_)
# end class dll_dependencies


class loaded_dll(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, base_name=None, is_load_time_dependency=None, full_name=None, load_time=None, base_address=None, size=None, valueOf_=None):
        self.base_name = _cast(None, base_name)
        self.is_load_time_dependency = _cast(None, is_load_time_dependency)
        self.full_name = _cast(None, full_name)
        self.load_time = _cast(int, load_time)
        self.base_address = _cast(None, base_address)
        self.size = _cast(None, size)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if loaded_dll.subclass:
            return loaded_dll.subclass(*args_, **kwargs_)
        else:
            return loaded_dll(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_base_name(self): return self.base_name
    def set_base_name(self, base_name): self.base_name = base_name
    def get_is_load_time_dependency(self): return self.is_load_time_dependency
    def set_is_load_time_dependency(self, is_load_time_dependency): self.is_load_time_dependency = is_load_time_dependency
    def validate_is_load_time_dependency(self, value):
        # Validate type is_load_time_dependency, a restriction on xs:integer.
        pass
    def get_full_name(self): return self.full_name
    def set_full_name(self, full_name): self.full_name = full_name
    def get_load_time(self): return self.load_time
    def set_load_time(self, load_time): self.load_time = load_time
    def get_base_address(self): return self.base_address
    def set_base_address(self, base_address): self.base_address = base_address
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='loaded_dll', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='loaded_dll')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='loaded_dll'):
        outfile.write(' base_name=%s' % (self.gds_format_string(quote_attrib(self.base_name).encode(ExternalEncoding), input_name='base_name'), ))
        outfile.write(' is_load_time_dependency=%s' % (quote_attrib(self.is_load_time_dependency), ))
        outfile.write(' full_name=%s' % (self.gds_format_string(quote_attrib(self.full_name).encode(ExternalEncoding), input_name='full_name'), ))
        outfile.write(' load_time="%s"' % self.gds_format_integer(self.load_time, input_name='load_time'))
        outfile.write(' base_address=%s' % (quote_attrib(self.base_address), ))
        outfile.write(' size=%s' % (quote_attrib(self.size), ))
    def exportChildren(self, outfile, level, namespace_='', name_='loaded_dll'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='loaded_dll'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.base_name is not None:
            showIndent(outfile, level)
            outfile.write('base_name = "%s",\n' % (self.base_name,))
        if self.is_load_time_dependency is not None:
            showIndent(outfile, level)
            outfile.write('is_load_time_dependency = %d,\n' % (self.is_load_time_dependency,))
        if self.full_name is not None:
            showIndent(outfile, level)
            outfile.write('full_name = "%s",\n' % (self.full_name,))
        if self.load_time is not None:
            showIndent(outfile, level)
            outfile.write('load_time = %d,\n' % (self.load_time,))
        if self.base_address is not None:
            showIndent(outfile, level)
            outfile.write('base_address = %s,\n' % (self.base_address,))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size = %s,\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('base_name')
        if value is not None:
            already_processed.append('base_name')
            self.base_name = value
        value = attrs.get('is_load_time_dependency')
        if value is not None:
            already_processed.append('is_load_time_dependency')
            self.is_load_time_dependency = value
            self.validate_is_load_time_dependency(self.is_load_time_dependency)    # validate type is_load_time_dependency
        value = attrs.get('full_name')
        if value is not None:
            already_processed.append('full_name')
            self.full_name = value
        value = attrs.get('load_time')
        if value is not None:
            already_processed.append('load_time')
            try:
                self.load_time = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('base_address')
        if value is not None:
            already_processed.append('base_address')
            self.base_address = value
        value = attrs.get('size')
        if value is not None:
            already_processed.append('size')
            self.size = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class loaded_dll


class ikarus_scanner(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sig=None):
        if sig is None:
            self.sig = []
        else:
            self.sig = sig
    def factory(*args_, **kwargs_):
        if ikarus_scanner.subclass:
            return ikarus_scanner.subclass(*args_, **kwargs_)
        else:
            return ikarus_scanner(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sig(self): return self.sig
    def set_sig(self, sig): self.sig = sig
    def add_sig(self, value): self.sig.append(value)
    def insert_sig(self, index, value): self.sig[index] = value
    def export(self, outfile, level, namespace_='', name_='ikarus_scanner', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ikarus_scanner')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ikarus_scanner'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ikarus_scanner'):
        for sig_ in self.sig:
            sig_.export(outfile, level, namespace_, name_='sig')
    def hasContent_(self):
        if (
            self.sig
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ikarus_scanner'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sig=[\n')
        level += 1
        for sig_ in self.sig:
            showIndent(outfile, level)
            outfile.write('model_.sig(\n')
            sig_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'sig': 
            obj_ = sig.factory()
            obj_.build(child_)
            self.sig.append(obj_)
# end class ikarus_scanner


class sig(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, valueOf_=None):
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if sig.subclass:
            return sig.subclass(*args_, **kwargs_)
        else:
            return sig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='sig', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sig')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='sig'):
        outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sig'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sig'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class sig


class program_output(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, stdout=None, stderr=None):
        self.stdout = stdout
        self.stderr = stderr
    def factory(*args_, **kwargs_):
        if program_output.subclass:
            return program_output.subclass(*args_, **kwargs_)
        else:
            return program_output(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stdout(self): return self.stdout
    def set_stdout(self, stdout): self.stdout = stdout
    def get_stderr(self): return self.stderr
    def set_stderr(self, stderr): self.stderr = stderr
    def export(self, outfile, level, namespace_='', name_='program_output', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='program_output')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='program_output'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='program_output'):
        if self.stdout is not None:
            showIndent(outfile, level)
            outfile.write('<%sstdout>%s</%sstdout>\n' % (namespace_, self.gds_format_string(quote_xml(self.stdout).encode(ExternalEncoding), input_name='stdout'), namespace_))
        if self.stderr is not None:
            showIndent(outfile, level)
            outfile.write('<%sstderr>%s</%sstderr>\n' % (namespace_, self.gds_format_string(quote_xml(self.stderr).encode(ExternalEncoding), input_name='stderr'), namespace_))
    def hasContent_(self):
        if (
            self.stdout is not None or
            self.stderr is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='program_output'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.stdout is not None:
            showIndent(outfile, level)
            outfile.write('stdout=%s,\n' % quote_python(self.stdout).encode(ExternalEncoding))
        if self.stderr is not None:
            showIndent(outfile, level)
            outfile.write('stderr=%s,\n' % quote_python(self.stderr).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'stdout':
            stdout_ = child_.text
            self.stdout = stdout_
        elif nodeName_ == 'stderr':
            stderr_ = child_.text
            self.stderr = stderr_
# end class program_output


class activities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, file_activities=None, registry_activities=None, service_activities=None, process_activities=None, network_activities=None, misc_activities=None):
        if file_activities is None:
            self.file_activities = []
        else:
            self.file_activities = file_activities
        if registry_activities is None:
            self.registry_activities = []
        else:
            self.registry_activities = registry_activities
        if service_activities is None:
            self.service_activities = []
        else:
            self.service_activities = service_activities
        if process_activities is None:
            self.process_activities = []
        else:
            self.process_activities = process_activities
        if network_activities is None:
            self.network_activities = []
        else:
            self.network_activities = network_activities
        if misc_activities is None:
            self.misc_activities = []
        else:
            self.misc_activities = misc_activities
    def factory(*args_, **kwargs_):
        if activities.subclass:
            return activities.subclass(*args_, **kwargs_)
        else:
            return activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_file_activities(self): return self.file_activities
    def set_file_activities(self, file_activities): self.file_activities = file_activities
    def add_file_activities(self, value): self.file_activities.append(value)
    def insert_file_activities(self, index, value): self.file_activities[index] = value
    def get_registry_activities(self): return self.registry_activities
    def set_registry_activities(self, registry_activities): self.registry_activities = registry_activities
    def add_registry_activities(self, value): self.registry_activities.append(value)
    def insert_registry_activities(self, index, value): self.registry_activities[index] = value
    def get_service_activities(self): return self.service_activities
    def set_service_activities(self, service_activities): self.service_activities = service_activities
    def add_service_activities(self, value): self.service_activities.append(value)
    def insert_service_activities(self, index, value): self.service_activities[index] = value
    def get_process_activities(self): return self.process_activities
    def set_process_activities(self, process_activities): self.process_activities = process_activities
    def add_process_activities(self, value): self.process_activities.append(value)
    def insert_process_activities(self, index, value): self.process_activities[index] = value
    def get_network_activities(self): return self.network_activities
    def set_network_activities(self, network_activities): self.network_activities = network_activities
    def add_network_activities(self, value): self.network_activities.append(value)
    def insert_network_activities(self, index, value): self.network_activities[index] = value
    def get_misc_activities(self): return self.misc_activities
    def set_misc_activities(self, misc_activities): self.misc_activities = misc_activities
    def add_misc_activities(self, value): self.misc_activities.append(value)
    def insert_misc_activities(self, index, value): self.misc_activities[index] = value
    def export(self, outfile, level, namespace_='', name_='activities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='activities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='activities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='activities'):
        for file_activities_ in self.file_activities:
            file_activities_.export(outfile, level, namespace_, name_='file_activities')
        for registry_activities_ in self.registry_activities:
            registry_activities_.export(outfile, level, namespace_, name_='registry_activities')
        for service_activities_ in self.service_activities:
            service_activities_.export(outfile, level, namespace_, name_='service_activities')
        for process_activities_ in self.process_activities:
            process_activities_.export(outfile, level, namespace_, name_='process_activities')
        for network_activities_ in self.network_activities:
            network_activities_.export(outfile, level, namespace_, name_='network_activities')
        for misc_activities_ in self.misc_activities:
            misc_activities_.export(outfile, level, namespace_, name_='misc_activities')
    def hasContent_(self):
        if (
            self.file_activities or
            self.registry_activities or
            self.service_activities or
            self.process_activities or
            self.network_activities or
            self.misc_activities
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='activities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('file_activities=[\n')
        level += 1
        for file_activities_ in self.file_activities:
            showIndent(outfile, level)
            outfile.write('model_.file_activities(\n')
            file_activities_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('registry_activities=[\n')
        level += 1
        for registry_activities_ in self.registry_activities:
            showIndent(outfile, level)
            outfile.write('model_.registry_activities(\n')
            registry_activities_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('service_activities=[\n')
        level += 1
        for service_activities_ in self.service_activities:
            showIndent(outfile, level)
            outfile.write('model_.service_activities(\n')
            service_activities_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('process_activities=[\n')
        level += 1
        for process_activities_ in self.process_activities:
            showIndent(outfile, level)
            outfile.write('model_.process_activities(\n')
            process_activities_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network_activities=[\n')
        level += 1
        for network_activities_ in self.network_activities:
            showIndent(outfile, level)
            outfile.write('model_.network_activities(\n')
            network_activities_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('misc_activities=[\n')
        level += 1
        for misc_activities_ in self.misc_activities:
            showIndent(outfile, level)
            outfile.write('model_.misc_activities(\n')
            misc_activities_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'file_activities': 
            obj_ = file_activities.factory()
            obj_.build(child_)
            self.file_activities.append(obj_)
        elif nodeName_ == 'registry_activities': 
            obj_ = registry_activities.factory()
            obj_.build(child_)
            self.registry_activities.append(obj_)
        elif nodeName_ == 'service_activities': 
            obj_ = service_activities.factory()
            obj_.build(child_)
            self.service_activities.append(obj_)
        elif nodeName_ == 'process_activities': 
            obj_ = process_activities.factory()
            obj_.build(child_)
            self.process_activities.append(obj_)
        elif nodeName_ == 'network_activities': 
            obj_ = network_activities.factory()
            obj_.build(child_)
            self.network_activities.append(obj_)
        elif nodeName_ == 'misc_activities': 
            obj_ = misc_activities.factory()
            obj_.build(child_)
            self.misc_activities.append(obj_)
# end class activities


class file_activities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, file_deleted=None, file_created=None, file_read=None, file_modified=None, directory_created=None, directory_removed=None, file_renamed=None, link_created=None, fs_control_communication=None, device_control_communication=None, section_object_created=None, directory_monitored=None):
        if file_deleted is None:
            self.file_deleted = []
        else:
            self.file_deleted = file_deleted
        if file_created is None:
            self.file_created = []
        else:
            self.file_created = file_created
        if file_read is None:
            self.file_read = []
        else:
            self.file_read = file_read
        if file_modified is None:
            self.file_modified = []
        else:
            self.file_modified = file_modified
        if directory_created is None:
            self.directory_created = []
        else:
            self.directory_created = directory_created
        if directory_removed is None:
            self.directory_removed = []
        else:
            self.directory_removed = directory_removed
        if file_renamed is None:
            self.file_renamed = []
        else:
            self.file_renamed = file_renamed
        if link_created is None:
            self.link_created = []
        else:
            self.link_created = link_created
        if fs_control_communication is None:
            self.fs_control_communication = []
        else:
            self.fs_control_communication = fs_control_communication
        if device_control_communication is None:
            self.device_control_communication = []
        else:
            self.device_control_communication = device_control_communication
        if section_object_created is None:
            self.section_object_created = []
        else:
            self.section_object_created = section_object_created
        if directory_monitored is None:
            self.directory_monitored = []
        else:
            self.directory_monitored = directory_monitored
    def factory(*args_, **kwargs_):
        if file_activities.subclass:
            return file_activities.subclass(*args_, **kwargs_)
        else:
            return file_activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_file_deleted(self): return self.file_deleted
    def set_file_deleted(self, file_deleted): self.file_deleted = file_deleted
    def add_file_deleted(self, value): self.file_deleted.append(value)
    def insert_file_deleted(self, index, value): self.file_deleted[index] = value
    def get_file_created(self): return self.file_created
    def set_file_created(self, file_created): self.file_created = file_created
    def add_file_created(self, value): self.file_created.append(value)
    def insert_file_created(self, index, value): self.file_created[index] = value
    def get_file_read(self): return self.file_read
    def set_file_read(self, file_read): self.file_read = file_read
    def add_file_read(self, value): self.file_read.append(value)
    def insert_file_read(self, index, value): self.file_read[index] = value
    def get_file_modified(self): return self.file_modified
    def set_file_modified(self, file_modified): self.file_modified = file_modified
    def add_file_modified(self, value): self.file_modified.append(value)
    def insert_file_modified(self, index, value): self.file_modified[index] = value
    def get_directory_created(self): return self.directory_created
    def set_directory_created(self, directory_created): self.directory_created = directory_created
    def add_directory_created(self, value): self.directory_created.append(value)
    def insert_directory_created(self, index, value): self.directory_created[index] = value
    def get_directory_removed(self): return self.directory_removed
    def set_directory_removed(self, directory_removed): self.directory_removed = directory_removed
    def add_directory_removed(self, value): self.directory_removed.append(value)
    def insert_directory_removed(self, index, value): self.directory_removed[index] = value
    def get_file_renamed(self): return self.file_renamed
    def set_file_renamed(self, file_renamed): self.file_renamed = file_renamed
    def add_file_renamed(self, value): self.file_renamed.append(value)
    def insert_file_renamed(self, index, value): self.file_renamed[index] = value
    def get_link_created(self): return self.link_created
    def set_link_created(self, link_created): self.link_created = link_created
    def add_link_created(self, value): self.link_created.append(value)
    def insert_link_created(self, index, value): self.link_created[index] = value
    def get_fs_control_communication(self): return self.fs_control_communication
    def set_fs_control_communication(self, fs_control_communication): self.fs_control_communication = fs_control_communication
    def add_fs_control_communication(self, value): self.fs_control_communication.append(value)
    def insert_fs_control_communication(self, index, value): self.fs_control_communication[index] = value
    def get_device_control_communication(self): return self.device_control_communication
    def set_device_control_communication(self, device_control_communication): self.device_control_communication = device_control_communication
    def add_device_control_communication(self, value): self.device_control_communication.append(value)
    def insert_device_control_communication(self, index, value): self.device_control_communication[index] = value
    def get_section_object_created(self): return self.section_object_created
    def set_section_object_created(self, section_object_created): self.section_object_created = section_object_created
    def add_section_object_created(self, value): self.section_object_created.append(value)
    def insert_section_object_created(self, index, value): self.section_object_created[index] = value
    def get_directory_monitored(self): return self.directory_monitored
    def set_directory_monitored(self, directory_monitored): self.directory_monitored = directory_monitored
    def add_directory_monitored(self, value): self.directory_monitored.append(value)
    def insert_directory_monitored(self, index, value): self.directory_monitored[index] = value
    def export(self, outfile, level, namespace_='', name_='file_activities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='file_activities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='file_activities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='file_activities'):
        for file_deleted_ in self.file_deleted:
            file_deleted_.export(outfile, level, namespace_, name_='file_deleted')
        for file_created_ in self.file_created:
            file_created_.export(outfile, level, namespace_, name_='file_created')
        for file_read_ in self.file_read:
            file_read_.export(outfile, level, namespace_, name_='file_read')
        for file_modified_ in self.file_modified:
            file_modified_.export(outfile, level, namespace_, name_='file_modified')
        for directory_created_ in self.directory_created:
            directory_created_.export(outfile, level, namespace_, name_='directory_created')
        for directory_removed_ in self.directory_removed:
            directory_removed_.export(outfile, level, namespace_, name_='directory_removed')
        for file_renamed_ in self.file_renamed:
            file_renamed_.export(outfile, level, namespace_, name_='file_renamed')
        for link_created_ in self.link_created:
            link_created_.export(outfile, level, namespace_, name_='link_created')
        for fs_control_communication_ in self.fs_control_communication:
            fs_control_communication_.export(outfile, level, namespace_, name_='fs_control_communication')
        for device_control_communication_ in self.device_control_communication:
            device_control_communication_.export(outfile, level, namespace_, name_='device_control_communication')
        for section_object_created_ in self.section_object_created:
            section_object_created_.export(outfile, level, namespace_, name_='section_object_created')
        for directory_monitored_ in self.directory_monitored:
            directory_monitored_.export(outfile, level, namespace_, name_='directory_monitored')
    def hasContent_(self):
        if (
            self.file_deleted or
            self.file_created or
            self.file_read or
            self.file_modified or
            self.directory_created or
            self.directory_removed or
            self.file_renamed or
            self.link_created or
            self.fs_control_communication or
            self.device_control_communication or
            self.section_object_created or
            self.directory_monitored
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file_activities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('file_deleted=[\n')
        level += 1
        for file_deleted_ in self.file_deleted:
            showIndent(outfile, level)
            outfile.write('model_.file_deleted(\n')
            file_deleted_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('file_created=[\n')
        level += 1
        for file_created_ in self.file_created:
            showIndent(outfile, level)
            outfile.write('model_.file_created(\n')
            file_created_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('file_read=[\n')
        level += 1
        for file_read_ in self.file_read:
            showIndent(outfile, level)
            outfile.write('model_.file_read(\n')
            file_read_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('file_modified=[\n')
        level += 1
        for file_modified_ in self.file_modified:
            showIndent(outfile, level)
            outfile.write('model_.file_modified(\n')
            file_modified_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('directory_created=[\n')
        level += 1
        for directory_created_ in self.directory_created:
            showIndent(outfile, level)
            outfile.write('model_.directory_created(\n')
            directory_created_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('directory_removed=[\n')
        level += 1
        for directory_removed_ in self.directory_removed:
            showIndent(outfile, level)
            outfile.write('model_.directory_removed(\n')
            directory_removed_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('file_renamed=[\n')
        level += 1
        for file_renamed_ in self.file_renamed:
            showIndent(outfile, level)
            outfile.write('model_.file_renamed(\n')
            file_renamed_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('link_created=[\n')
        level += 1
        for link_created_ in self.link_created:
            showIndent(outfile, level)
            outfile.write('model_.link_created(\n')
            link_created_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('fs_control_communication=[\n')
        level += 1
        for fs_control_communication_ in self.fs_control_communication:
            showIndent(outfile, level)
            outfile.write('model_.fs_control_communication(\n')
            fs_control_communication_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('device_control_communication=[\n')
        level += 1
        for device_control_communication_ in self.device_control_communication:
            showIndent(outfile, level)
            outfile.write('model_.device_control_communication(\n')
            device_control_communication_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('section_object_created=[\n')
        level += 1
        for section_object_created_ in self.section_object_created:
            showIndent(outfile, level)
            outfile.write('model_.section_object_created(\n')
            section_object_created_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('directory_monitored=[\n')
        level += 1
        for directory_monitored_ in self.directory_monitored:
            showIndent(outfile, level)
            outfile.write('model_.directory_monitored(\n')
            directory_monitored_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'file_deleted': 
            obj_ = file_deleted.factory()
            obj_.build(child_)
            self.file_deleted.append(obj_)
        elif nodeName_ == 'file_created': 
            obj_ = file_created.factory()
            obj_.build(child_)
            self.file_created.append(obj_)
        elif nodeName_ == 'file_read': 
            obj_ = file_read.factory()
            obj_.build(child_)
            self.file_read.append(obj_)
        elif nodeName_ == 'file_modified': 
            obj_ = file_modified.factory()
            obj_.build(child_)
            self.file_modified.append(obj_)
        elif nodeName_ == 'directory_created': 
            obj_ = directory_created.factory()
            obj_.build(child_)
            self.directory_created.append(obj_)
        elif nodeName_ == 'directory_removed': 
            obj_ = directory_removed.factory()
            obj_.build(child_)
            self.directory_removed.append(obj_)
        elif nodeName_ == 'file_renamed': 
            obj_ = file_renamed.factory()
            obj_.build(child_)
            self.file_renamed.append(obj_)
        elif nodeName_ == 'link_created': 
            obj_ = link_created.factory()
            obj_.build(child_)
            self.link_created.append(obj_)
        elif nodeName_ == 'fs_control_communication': 
            obj_ = fs_control_communication.factory()
            obj_.build(child_)
            self.fs_control_communication.append(obj_)
        elif nodeName_ == 'device_control_communication': 
            obj_ = device_control_communication.factory()
            obj_.build(child_)
            self.device_control_communication.append(obj_)
        elif nodeName_ == 'section_object_created': 
            obj_ = section_object_created.factory()
            obj_.build(child_)
            self.section_object_created.append(obj_)
        elif nodeName_ == 'directory_monitored': 
            obj_ = directory_monitored.factory()
            obj_.build(child_)
            self.directory_monitored.append(obj_)
# end class file_activities


class file_deleted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, valueOf_=None):
        self.description = _cast(None, description)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if file_deleted.subclass:
            return file_deleted.subclass(*args_, **kwargs_)
        else:
            return file_deleted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='file_deleted', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='file_deleted')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='file_deleted'):
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='file_deleted'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file_deleted'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class file_deleted


class file_created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, valueOf_=None):
        self.description = _cast(None, description)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if file_created.subclass:
            return file_created.subclass(*args_, **kwargs_)
        else:
            return file_created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='file_created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='file_created')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='file_created'):
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='file_created'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file_created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class file_created


class file_read(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if file_read.subclass:
            return file_read.subclass(*args_, **kwargs_)
        else:
            return file_read(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='file_read', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='file_read')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='file_read'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='file_read'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file_read'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class file_read


class file_modified(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, valueOf_=None):
        self.description = _cast(None, description)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if file_modified.subclass:
            return file_modified.subclass(*args_, **kwargs_)
        else:
            return file_modified(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='file_modified', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='file_modified')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='file_modified'):
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='file_modified'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file_modified'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class file_modified


class directory_created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if directory_created.subclass:
            return directory_created.subclass(*args_, **kwargs_)
        else:
            return directory_created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='directory_created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='directory_created')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='directory_created'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='directory_created'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='directory_created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class directory_created


class directory_removed(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, valueOf_=None):
        self.description = _cast(None, description)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if directory_removed.subclass:
            return directory_removed.subclass(*args_, **kwargs_)
        else:
            return directory_removed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='directory_removed', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='directory_removed')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='directory_removed'):
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='directory_removed'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='directory_removed'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class directory_removed


class file_renamed(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, new_name=None, description=None, old_name=None, valueOf_=None):
        self.new_name = _cast(None, new_name)
        self.description = _cast(None, description)
        self.old_name = _cast(None, old_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if file_renamed.subclass:
            return file_renamed.subclass(*args_, **kwargs_)
        else:
            return file_renamed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_new_name(self): return self.new_name
    def set_new_name(self, new_name): self.new_name = new_name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_old_name(self): return self.old_name
    def set_old_name(self, old_name): self.old_name = old_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='file_renamed', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='file_renamed')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='file_renamed'):
        outfile.write(' new_name=%s' % (self.gds_format_string(quote_attrib(self.new_name).encode(ExternalEncoding), input_name='new_name'), ))
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' old_name=%s' % (self.gds_format_string(quote_attrib(self.old_name).encode(ExternalEncoding), input_name='old_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='file_renamed'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file_renamed'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.new_name is not None:
            showIndent(outfile, level)
            outfile.write('new_name = "%s",\n' % (self.new_name,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.old_name is not None:
            showIndent(outfile, level)
            outfile.write('old_name = "%s",\n' % (self.old_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('new_name')
        if value is not None:
            already_processed.append('new_name')
            self.new_name = value
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('old_name')
        if value is not None:
            already_processed.append('old_name')
            self.old_name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class file_renamed


class link_created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, link_name=None, existing_file=None, valueOf_=None):
        self.link_name = _cast(None, link_name)
        self.existing_file = _cast(None, existing_file)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if link_created.subclass:
            return link_created.subclass(*args_, **kwargs_)
        else:
            return link_created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_link_name(self): return self.link_name
    def set_link_name(self, link_name): self.link_name = link_name
    def get_existing_file(self): return self.existing_file
    def set_existing_file(self, existing_file): self.existing_file = existing_file
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='link_created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='link_created')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='link_created'):
        outfile.write(' link_name=%s' % (self.gds_format_string(quote_attrib(self.link_name).encode(ExternalEncoding), input_name='link_name'), ))
        outfile.write(' existing_file=%s' % (self.gds_format_string(quote_attrib(self.existing_file).encode(ExternalEncoding), input_name='existing_file'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='link_created'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='link_created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.link_name is not None:
            showIndent(outfile, level)
            outfile.write('link_name = "%s",\n' % (self.link_name,))
        if self.existing_file is not None:
            showIndent(outfile, level)
            outfile.write('existing_file = "%s",\n' % (self.existing_file,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('link_name')
        if value is not None:
            already_processed.append('link_name')
            self.link_name = value
        value = attrs.get('existing_file')
        if value is not None:
            already_processed.append('existing_file')
            self.existing_file = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class link_created


class fs_control_communication(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, control_code=None, file=None, valueOf_=None):
        self.count = _cast(int, count)
        self.control_code = _cast(None, control_code)
        self.file = _cast(None, file)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if fs_control_communication.subclass:
            return fs_control_communication.subclass(*args_, **kwargs_)
        else:
            return fs_control_communication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_control_code(self): return self.control_code
    def set_control_code(self, control_code): self.control_code = control_code
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='fs_control_communication', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fs_control_communication')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='fs_control_communication'):
        outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        outfile.write(' control_code=%s' % (quote_attrib(self.control_code), ))
        outfile.write(' file=%s' % (self.gds_format_string(quote_attrib(self.file).encode(ExternalEncoding), input_name='file'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='fs_control_communication'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fs_control_communication'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.count is not None:
            showIndent(outfile, level)
            outfile.write('count = %d,\n' % (self.count,))
        if self.control_code is not None:
            showIndent(outfile, level)
            outfile.write('control_code = %s,\n' % (self.control_code,))
        if self.file is not None:
            showIndent(outfile, level)
            outfile.write('file = "%s",\n' % (self.file,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('count')
        if value is not None:
            already_processed.append('count')
            try:
                self.count = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('control_code')
        if value is not None:
            already_processed.append('control_code')
            self.control_code = value
        value = attrs.get('file')
        if value is not None:
            already_processed.append('file')
            self.file = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class fs_control_communication


class device_control_communication(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, control_code=None, file=None, valueOf_=None):
        self.count = _cast(int, count)
        self.control_code = _cast(None, control_code)
        self.file = _cast(None, file)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if device_control_communication.subclass:
            return device_control_communication.subclass(*args_, **kwargs_)
        else:
            return device_control_communication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_control_code(self): return self.control_code
    def set_control_code(self, control_code): self.control_code = control_code
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='device_control_communication', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='device_control_communication')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='device_control_communication'):
        outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        outfile.write(' control_code=%s' % (self.gds_format_string(quote_attrib(self.control_code).encode(ExternalEncoding), input_name='control_code'), ))
        outfile.write(' file=%s' % (self.gds_format_string(quote_attrib(self.file).encode(ExternalEncoding), input_name='file'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='device_control_communication'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='device_control_communication'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.count is not None:
            showIndent(outfile, level)
            outfile.write('count = %d,\n' % (self.count,))
        if self.control_code is not None:
            showIndent(outfile, level)
            outfile.write('control_code = "%s",\n' % (self.control_code,))
        if self.file is not None:
            showIndent(outfile, level)
            outfile.write('file = "%s",\n' % (self.file,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('count')
        if value is not None:
            already_processed.append('count')
            try:
                self.count = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('control_code')
        if value is not None:
            already_processed.append('control_code')
            self.control_code = value
        value = attrs.get('file')
        if value is not None:
            already_processed.append('file')
            self.file = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class device_control_communication


class section_object_created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, file_name=None, section_name=None, valueOf_=None):
        self.file_name = _cast(None, file_name)
        self.section_name = _cast(None, section_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if section_object_created.subclass:
            return section_object_created.subclass(*args_, **kwargs_)
        else:
            return section_object_created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_file_name(self): return self.file_name
    def set_file_name(self, file_name): self.file_name = file_name
    def get_section_name(self): return self.section_name
    def set_section_name(self, section_name): self.section_name = section_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='section_object_created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='section_object_created')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='section_object_created'):
        outfile.write(' file_name=%s' % (self.gds_format_string(quote_attrib(self.file_name).encode(ExternalEncoding), input_name='file_name'), ))
        outfile.write(' section_name=%s' % (self.gds_format_string(quote_attrib(self.section_name).encode(ExternalEncoding), input_name='section_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='section_object_created'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='section_object_created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.file_name is not None:
            showIndent(outfile, level)
            outfile.write('file_name = "%s",\n' % (self.file_name,))
        if self.section_name is not None:
            showIndent(outfile, level)
            outfile.write('section_name = "%s",\n' % (self.section_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('file_name')
        if value is not None:
            already_processed.append('file_name')
            self.file_name = value
        value = attrs.get('section_name')
        if value is not None:
            already_processed.append('section_name')
            self.section_name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class section_object_created


class directory_monitored(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, directory=None, watch_subtree=None, notify_filter=None, valueOf_=None):
        self.count = _cast(None, count)
        self.directory = _cast(None, directory)
        self.watch_subtree = _cast(None, watch_subtree)
        self.notify_filter = _cast(None, notify_filter)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if directory_monitored.subclass:
            return directory_monitored.subclass(*args_, **kwargs_)
        else:
            return directory_monitored(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_directory(self): return self.directory
    def set_directory(self, directory): self.directory = directory
    def get_watch_subtree(self): return self.watch_subtree
    def set_watch_subtree(self, watch_subtree): self.watch_subtree = watch_subtree
    def get_notify_filter(self): return self.notify_filter
    def set_notify_filter(self, notify_filter): self.notify_filter = notify_filter
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='directory_monitored', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='directory_monitored')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='directory_monitored'):
        outfile.write(' count=%s' % (self.gds_format_string(quote_attrib(self.count).encode(ExternalEncoding), input_name='count'), ))
        outfile.write(' directory=%s' % (self.gds_format_string(quote_attrib(self.directory).encode(ExternalEncoding), input_name='directory'), ))
        outfile.write(' watch_subtree=%s' % (self.gds_format_string(quote_attrib(self.watch_subtree).encode(ExternalEncoding), input_name='watch_subtree'), ))
        outfile.write(' notify_filter=%s' % (self.gds_format_string(quote_attrib(self.notify_filter).encode(ExternalEncoding), input_name='notify_filter'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='directory_monitored'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='directory_monitored'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.count is not None:
            showIndent(outfile, level)
            outfile.write('count = "%s",\n' % (self.count,))
        if self.directory is not None:
            showIndent(outfile, level)
            outfile.write('directory = "%s",\n' % (self.directory,))
        if self.watch_subtree is not None:
            showIndent(outfile, level)
            outfile.write('watch_subtree = "%s",\n' % (self.watch_subtree,))
        if self.notify_filter is not None:
            showIndent(outfile, level)
            outfile.write('notify_filter = "%s",\n' % (self.notify_filter,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('count')
        if value is not None:
            already_processed.append('count')
            self.count = value
        value = attrs.get('directory')
        if value is not None:
            already_processed.append('directory')
            self.directory = value
        value = attrs.get('watch_subtree')
        if value is not None:
            already_processed.append('watch_subtree')
            self.watch_subtree = value
        value = attrs.get('notify_filter')
        if value is not None:
            already_processed.append('notify_filter')
            self.notify_filter = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class directory_monitored


class registry_activities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reg_key_created=None, reg_key_created_or_opened=None, reg_key_deleted=None, reg_value_deleted=None, reg_value_modified=None, reg_value_read=None, reg_key_monitored=None):
        if reg_key_created is None:
            self.reg_key_created = []
        else:
            self.reg_key_created = reg_key_created
        if reg_key_created_or_opened is None:
            self.reg_key_created_or_opened = []
        else:
            self.reg_key_created_or_opened = reg_key_created_or_opened
        if reg_key_deleted is None:
            self.reg_key_deleted = []
        else:
            self.reg_key_deleted = reg_key_deleted
        if reg_value_deleted is None:
            self.reg_value_deleted = []
        else:
            self.reg_value_deleted = reg_value_deleted
        if reg_value_modified is None:
            self.reg_value_modified = []
        else:
            self.reg_value_modified = reg_value_modified
        if reg_value_read is None:
            self.reg_value_read = []
        else:
            self.reg_value_read = reg_value_read
        if reg_key_monitored is None:
            self.reg_key_monitored = []
        else:
            self.reg_key_monitored = reg_key_monitored
    def factory(*args_, **kwargs_):
        if registry_activities.subclass:
            return registry_activities.subclass(*args_, **kwargs_)
        else:
            return registry_activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reg_key_created(self): return self.reg_key_created
    def set_reg_key_created(self, reg_key_created): self.reg_key_created = reg_key_created
    def add_reg_key_created(self, value): self.reg_key_created.append(value)
    def insert_reg_key_created(self, index, value): self.reg_key_created[index] = value
    def get_reg_key_created_or_opened(self): return self.reg_key_created_or_opened
    def set_reg_key_created_or_opened(self, reg_key_created_or_opened): self.reg_key_created_or_opened = reg_key_created_or_opened
    def add_reg_key_created_or_opened(self, value): self.reg_key_created_or_opened.append(value)
    def insert_reg_key_created_or_opened(self, index, value): self.reg_key_created_or_opened[index] = value
    def get_reg_key_deleted(self): return self.reg_key_deleted
    def set_reg_key_deleted(self, reg_key_deleted): self.reg_key_deleted = reg_key_deleted
    def add_reg_key_deleted(self, value): self.reg_key_deleted.append(value)
    def insert_reg_key_deleted(self, index, value): self.reg_key_deleted[index] = value
    def get_reg_value_deleted(self): return self.reg_value_deleted
    def set_reg_value_deleted(self, reg_value_deleted): self.reg_value_deleted = reg_value_deleted
    def add_reg_value_deleted(self, value): self.reg_value_deleted.append(value)
    def insert_reg_value_deleted(self, index, value): self.reg_value_deleted[index] = value
    def get_reg_value_modified(self): return self.reg_value_modified
    def set_reg_value_modified(self, reg_value_modified): self.reg_value_modified = reg_value_modified
    def add_reg_value_modified(self, value): self.reg_value_modified.append(value)
    def insert_reg_value_modified(self, index, value): self.reg_value_modified[index] = value
    def get_reg_value_read(self): return self.reg_value_read
    def set_reg_value_read(self, reg_value_read): self.reg_value_read = reg_value_read
    def add_reg_value_read(self, value): self.reg_value_read.append(value)
    def insert_reg_value_read(self, index, value): self.reg_value_read[index] = value
    def get_reg_key_monitored(self): return self.reg_key_monitored
    def set_reg_key_monitored(self, reg_key_monitored): self.reg_key_monitored = reg_key_monitored
    def add_reg_key_monitored(self, value): self.reg_key_monitored.append(value)
    def insert_reg_key_monitored(self, index, value): self.reg_key_monitored[index] = value
    def export(self, outfile, level, namespace_='', name_='registry_activities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='registry_activities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='registry_activities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='registry_activities'):
        for reg_key_created_ in self.reg_key_created:
            reg_key_created_.export(outfile, level, namespace_, name_='reg_key_created')
        for reg_key_created_or_opened_ in self.reg_key_created_or_opened:
            reg_key_created_or_opened_.export(outfile, level, namespace_, name_='reg_key_created_or_opened')
        for reg_key_deleted_ in self.reg_key_deleted:
            reg_key_deleted_.export(outfile, level, namespace_, name_='reg_key_deleted')
        for reg_value_deleted_ in self.reg_value_deleted:
            reg_value_deleted_.export(outfile, level, namespace_, name_='reg_value_deleted')
        for reg_value_modified_ in self.reg_value_modified:
            reg_value_modified_.export(outfile, level, namespace_, name_='reg_value_modified')
        for reg_value_read_ in self.reg_value_read:
            reg_value_read_.export(outfile, level, namespace_, name_='reg_value_read')
        for reg_key_monitored_ in self.reg_key_monitored:
            reg_key_monitored_.export(outfile, level, namespace_, name_='reg_key_monitored')
    def hasContent_(self):
        if (
            self.reg_key_created or
            self.reg_key_created_or_opened or
            self.reg_key_deleted or
            self.reg_value_deleted or
            self.reg_value_modified or
            self.reg_value_read or
            self.reg_key_monitored
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='registry_activities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('reg_key_created=[\n')
        level += 1
        for reg_key_created_ in self.reg_key_created:
            showIndent(outfile, level)
            outfile.write('model_.reg_key_created(\n')
            reg_key_created_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reg_key_created_or_opened=[\n')
        level += 1
        for reg_key_created_or_opened_ in self.reg_key_created_or_opened:
            showIndent(outfile, level)
            outfile.write('model_.reg_key_created_or_opened(\n')
            reg_key_created_or_opened_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reg_key_deleted=[\n')
        level += 1
        for reg_key_deleted_ in self.reg_key_deleted:
            showIndent(outfile, level)
            outfile.write('model_.reg_key_deleted(\n')
            reg_key_deleted_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reg_value_deleted=[\n')
        level += 1
        for reg_value_deleted_ in self.reg_value_deleted:
            showIndent(outfile, level)
            outfile.write('model_.reg_value_deleted(\n')
            reg_value_deleted_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reg_value_modified=[\n')
        level += 1
        for reg_value_modified_ in self.reg_value_modified:
            showIndent(outfile, level)
            outfile.write('model_.reg_value_modified(\n')
            reg_value_modified_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reg_value_read=[\n')
        level += 1
        for reg_value_read_ in self.reg_value_read:
            showIndent(outfile, level)
            outfile.write('model_.reg_value_read(\n')
            reg_value_read_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reg_key_monitored=[\n')
        level += 1
        for reg_key_monitored_ in self.reg_key_monitored:
            showIndent(outfile, level)
            outfile.write('model_.reg_key_monitored(\n')
            reg_key_monitored_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'reg_key_created': 
            obj_ = reg_key_created.factory()
            obj_.build(child_)
            self.reg_key_created.append(obj_)
        elif nodeName_ == 'reg_key_created_or_opened': 
            obj_ = reg_key_created_or_opened.factory()
            obj_.build(child_)
            self.reg_key_created_or_opened.append(obj_)
        elif nodeName_ == 'reg_key_deleted': 
            obj_ = reg_key_deleted.factory()
            obj_.build(child_)
            self.reg_key_deleted.append(obj_)
        elif nodeName_ == 'reg_value_deleted': 
            obj_ = reg_value_deleted.factory()
            obj_.build(child_)
            self.reg_value_deleted.append(obj_)
        elif nodeName_ == 'reg_value_modified': 
            obj_ = reg_value_modified.factory()
            obj_.build(child_)
            self.reg_value_modified.append(obj_)
        elif nodeName_ == 'reg_value_read': 
            obj_ = reg_value_read.factory()
            obj_.build(child_)
            self.reg_value_read.append(obj_)
        elif nodeName_ == 'reg_key_monitored': 
            obj_ = reg_key_monitored.factory()
            obj_.build(child_)
            self.reg_key_monitored.append(obj_)
# end class registry_activities


class reg_key_created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, valueOf_=None):
        self.description = _cast(None, description)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reg_key_created.subclass:
            return reg_key_created.subclass(*args_, **kwargs_)
        else:
            return reg_key_created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='reg_key_created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='reg_key_created')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='reg_key_created'):
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reg_key_created'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='reg_key_created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class reg_key_created


class reg_key_created_or_opened(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reg_key_created_or_opened.subclass:
            return reg_key_created_or_opened.subclass(*args_, **kwargs_)
        else:
            return reg_key_created_or_opened(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='reg_key_created_or_opened', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='reg_key_created_or_opened')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='reg_key_created_or_opened'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reg_key_created_or_opened'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='reg_key_created_or_opened'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class reg_key_created_or_opened


class reg_key_deleted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reg_key_deleted.subclass:
            return reg_key_deleted.subclass(*args_, **kwargs_)
        else:
            return reg_key_deleted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='reg_key_deleted', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='reg_key_deleted')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='reg_key_deleted'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reg_key_deleted'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='reg_key_deleted'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class reg_key_deleted


class reg_value_deleted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value_name=None, key=None, valueOf_=None):
        self.value_name = _cast(None, value_name)
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reg_value_deleted.subclass:
            return reg_value_deleted.subclass(*args_, **kwargs_)
        else:
            return reg_value_deleted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value_name(self): return self.value_name
    def set_value_name(self, value_name): self.value_name = value_name
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='reg_value_deleted', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='reg_value_deleted')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='reg_value_deleted'):
        outfile.write(' value_name=%s' % (self.gds_format_string(quote_attrib(self.value_name).encode(ExternalEncoding), input_name='value_name'), ))
        outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reg_value_deleted'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='reg_value_deleted'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.value_name is not None:
            showIndent(outfile, level)
            outfile.write('value_name = "%s",\n' % (self.value_name,))
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key = "%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('value_name')
        if value is not None:
            already_processed.append('value_name')
            self.value_name = value
        value = attrs.get('key')
        if value is not None:
            already_processed.append('key')
            self.key = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class reg_value_deleted


class reg_value_modified(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, value_name=None, value_data=None, description=None, key=None, valueOf_=None):
        self.count = _cast(int, count)
        self.value_name = _cast(None, value_name)
        self.value_data = _cast(None, value_data)
        self.description = _cast(None, description)
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reg_value_modified.subclass:
            return reg_value_modified.subclass(*args_, **kwargs_)
        else:
            return reg_value_modified(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_value_name(self): return self.value_name
    def set_value_name(self, value_name): self.value_name = value_name
    def get_value_data(self): return self.value_data
    def set_value_data(self, value_data): self.value_data = value_data
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='reg_value_modified', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='reg_value_modified')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='reg_value_modified'):
        outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        outfile.write(' value_name=%s' % (self.gds_format_string(quote_attrib(self.value_name).encode(ExternalEncoding), input_name='value_name'), ))
        outfile.write(' value_data=%s' % (self.gds_format_string(quote_attrib(self.value_data).encode(ExternalEncoding), input_name='value_data'), ))
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reg_value_modified'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='reg_value_modified'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.count is not None:
            showIndent(outfile, level)
            outfile.write('count = %d,\n' % (self.count,))
        if self.value_name is not None:
            showIndent(outfile, level)
            outfile.write('value_name = "%s",\n' % (self.value_name,))
        if self.value_data is not None:
            showIndent(outfile, level)
            outfile.write('value_data = "%s",\n' % (self.value_data,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key = "%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('count')
        if value is not None:
            already_processed.append('count')
            try:
                self.count = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('value_name')
        if value is not None:
            already_processed.append('value_name')
            self.value_name = value
        value = attrs.get('value_data')
        if value is not None:
            already_processed.append('value_data')
            self.value_data = value
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('key')
        if value is not None:
            already_processed.append('key')
            self.key = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class reg_value_modified


class reg_value_read(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, value_name=None, value_data=None, key=None, valueOf_=None):
        self.count = _cast(int, count)
        self.value_name = _cast(None, value_name)
        self.value_data = _cast(None, value_data)
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reg_value_read.subclass:
            return reg_value_read.subclass(*args_, **kwargs_)
        else:
            return reg_value_read(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_value_name(self): return self.value_name
    def set_value_name(self, value_name): self.value_name = value_name
    def get_value_data(self): return self.value_data
    def set_value_data(self, value_data): self.value_data = value_data
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='reg_value_read', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='reg_value_read')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='reg_value_read'):
        outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        outfile.write(' value_name=%s' % (self.gds_format_string(quote_attrib(self.value_name).encode(ExternalEncoding), input_name='value_name'), ))
        outfile.write(' value_data=%s' % (self.gds_format_string(quote_attrib(self.value_data).encode(ExternalEncoding), input_name='value_data'), ))
        outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reg_value_read'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='reg_value_read'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.count is not None:
            showIndent(outfile, level)
            outfile.write('count = %d,\n' % (self.count,))
        if self.value_name is not None:
            showIndent(outfile, level)
            outfile.write('value_name = "%s",\n' % (self.value_name,))
        if self.value_data is not None:
            showIndent(outfile, level)
            outfile.write('value_data = "%s",\n' % (self.value_data,))
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key = "%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('count')
        if value is not None:
            already_processed.append('count')
            try:
                self.count = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('value_name')
        if value is not None:
            already_processed.append('value_name')
            self.value_name = value
        value = attrs.get('value_data')
        if value is not None:
            already_processed.append('value_data')
            self.value_data = value
        value = attrs.get('key')
        if value is not None:
            already_processed.append('key')
            self.key = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class reg_value_read


class reg_key_monitored(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, notify_filter=None, watch_subtree=None, key=None, valueOf_=None):
        self.count = _cast(int, count)
        self.notify_filter = _cast(None, notify_filter)
        self.watch_subtree = _cast(int, watch_subtree)
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reg_key_monitored.subclass:
            return reg_key_monitored.subclass(*args_, **kwargs_)
        else:
            return reg_key_monitored(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_notify_filter(self): return self.notify_filter
    def set_notify_filter(self, notify_filter): self.notify_filter = notify_filter
    def get_watch_subtree(self): return self.watch_subtree
    def set_watch_subtree(self, watch_subtree): self.watch_subtree = watch_subtree
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='reg_key_monitored', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='reg_key_monitored')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='reg_key_monitored'):
        outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        outfile.write(' notify_filter=%s' % (self.gds_format_string(quote_attrib(self.notify_filter).encode(ExternalEncoding), input_name='notify_filter'), ))
        outfile.write(' watch_subtree="%s"' % self.gds_format_integer(self.watch_subtree, input_name='watch_subtree'))
        outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reg_key_monitored'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='reg_key_monitored'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.count is not None:
            showIndent(outfile, level)
            outfile.write('count = %d,\n' % (self.count,))
        if self.notify_filter is not None:
            showIndent(outfile, level)
            outfile.write('notify_filter = "%s",\n' % (self.notify_filter,))
        if self.watch_subtree is not None:
            showIndent(outfile, level)
            outfile.write('watch_subtree = %d,\n' % (self.watch_subtree,))
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key = "%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('count')
        if value is not None:
            already_processed.append('count')
            try:
                self.count = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('notify_filter')
        if value is not None:
            already_processed.append('notify_filter')
            self.notify_filter = value
        value = attrs.get('watch_subtree')
        if value is not None:
            already_processed.append('watch_subtree')
            try:
                self.watch_subtree = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('key')
        if value is not None:
            already_processed.append('key')
            self.key = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class reg_key_monitored


class service_activities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, service_started=None, service_created=None, service_deleted=None, service_changed=None, service_control_code=None):
        if service_started is None:
            self.service_started = []
        else:
            self.service_started = service_started
        if service_created is None:
            self.service_created = []
        else:
            self.service_created = service_created
        if service_deleted is None:
            self.service_deleted = []
        else:
            self.service_deleted = service_deleted
        if service_changed is None:
            self.service_changed = []
        else:
            self.service_changed = service_changed
        if service_control_code is None:
            self.service_control_code = []
        else:
            self.service_control_code = service_control_code
    def factory(*args_, **kwargs_):
        if service_activities.subclass:
            return service_activities.subclass(*args_, **kwargs_)
        else:
            return service_activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service_started(self): return self.service_started
    def set_service_started(self, service_started): self.service_started = service_started
    def add_service_started(self, value): self.service_started.append(value)
    def insert_service_started(self, index, value): self.service_started[index] = value
    def get_service_created(self): return self.service_created
    def set_service_created(self, service_created): self.service_created = service_created
    def add_service_created(self, value): self.service_created.append(value)
    def insert_service_created(self, index, value): self.service_created[index] = value
    def get_service_deleted(self): return self.service_deleted
    def set_service_deleted(self, service_deleted): self.service_deleted = service_deleted
    def add_service_deleted(self, value): self.service_deleted.append(value)
    def insert_service_deleted(self, index, value): self.service_deleted[index] = value
    def get_service_changed(self): return self.service_changed
    def set_service_changed(self, service_changed): self.service_changed = service_changed
    def add_service_changed(self, value): self.service_changed.append(value)
    def insert_service_changed(self, index, value): self.service_changed[index] = value
    def get_service_control_code(self): return self.service_control_code
    def set_service_control_code(self, service_control_code): self.service_control_code = service_control_code
    def add_service_control_code(self, value): self.service_control_code.append(value)
    def insert_service_control_code(self, index, value): self.service_control_code[index] = value
    def export(self, outfile, level, namespace_='', name_='service_activities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='service_activities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='service_activities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='service_activities'):
        for service_started_ in self.service_started:
            service_started_.export(outfile, level, namespace_, name_='service_started')
        for service_created_ in self.service_created:
            service_created_.export(outfile, level, namespace_, name_='service_created')
        for service_deleted_ in self.service_deleted:
            service_deleted_.export(outfile, level, namespace_, name_='service_deleted')
        for service_changed_ in self.service_changed:
            service_changed_.export(outfile, level, namespace_, name_='service_changed')
        for service_control_code_ in self.service_control_code:
            service_control_code_.export(outfile, level, namespace_, name_='service_control_code')
    def hasContent_(self):
        if (
            self.service_started or
            self.service_created or
            self.service_deleted or
            self.service_changed or
            self.service_control_code
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='service_activities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('service_started=[\n')
        level += 1
        for service_started_ in self.service_started:
            showIndent(outfile, level)
            outfile.write('model_.service_started(\n')
            service_started_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('service_created=[\n')
        level += 1
        for service_created_ in self.service_created:
            showIndent(outfile, level)
            outfile.write('model_.service_created(\n')
            service_created_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('service_deleted=[\n')
        level += 1
        for service_deleted_ in self.service_deleted:
            showIndent(outfile, level)
            outfile.write('model_.service_deleted(\n')
            service_deleted_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('service_changed=[\n')
        level += 1
        for service_changed_ in self.service_changed:
            showIndent(outfile, level)
            outfile.write('model_.service_changed(\n')
            service_changed_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('service_control_code=[\n')
        level += 1
        for service_control_code_ in self.service_control_code:
            showIndent(outfile, level)
            outfile.write('model_.service_control_code(\n')
            service_control_code_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'service_started': 
            obj_ = service_started.factory()
            obj_.build(child_)
            self.service_started.append(obj_)
        elif nodeName_ == 'service_created': 
            obj_ = service_created.factory()
            obj_.build(child_)
            self.service_created.append(obj_)
        elif nodeName_ == 'service_deleted': 
            obj_ = service_deleted.factory()
            obj_.build(child_)
            self.service_deleted.append(obj_)
        elif nodeName_ == 'service_changed': 
            obj_ = service_changed.factory()
            obj_.build(child_)
            self.service_changed.append(obj_)
        elif nodeName_ == 'service_control_code': 
            obj_ = service_control_code.factory()
            obj_.build(child_)
            self.service_control_code.append(obj_)
# end class service_activities


class service_started(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if service_started.subclass:
            return service_started.subclass(*args_, **kwargs_)
        else:
            return service_started(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='service_started', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='service_started')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='service_started'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='service_started'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='service_started'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class service_started


class service_created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, path=None, type_=None, name=None, valueOf_=None):
        self.path = _cast(None, path)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if service_created.subclass:
            return service_created.subclass(*args_, **kwargs_)
        else:
            return service_created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='service_created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='service_created')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='service_created'):
        outfile.write(' path=%s' % (self.gds_format_string(quote_attrib(self.path).encode(ExternalEncoding), input_name='path'), ))
        outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='service_created'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='service_created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path = "%s",\n' % (self.path,))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('path')
        if value is not None:
            already_processed.append('path')
            self.path = value
        value = attrs.get('type')
        if value is not None:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class service_created


class service_deleted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if service_deleted.subclass:
            return service_deleted.subclass(*args_, **kwargs_)
        else:
            return service_deleted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='service_deleted', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='service_deleted')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='service_deleted'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='service_deleted'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='service_deleted'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class service_deleted


class service_changed(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if service_changed.subclass:
            return service_changed.subclass(*args_, **kwargs_)
        else:
            return service_changed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='service_changed', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='service_changed')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='service_changed'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='service_changed'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='service_changed'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class service_changed


class service_control_code(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, control_code=None, service=None, valueOf_=None):
        self.control_code = _cast(None, control_code)
        self.service = _cast(None, service)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if service_control_code.subclass:
            return service_control_code.subclass(*args_, **kwargs_)
        else:
            return service_control_code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_control_code(self): return self.control_code
    def set_control_code(self, control_code): self.control_code = control_code
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='service_control_code', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='service_control_code')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='service_control_code'):
        outfile.write(' control_code=%s' % (self.gds_format_string(quote_attrib(self.control_code).encode(ExternalEncoding), input_name='control_code'), ))
        outfile.write(' service=%s' % (self.gds_format_string(quote_attrib(self.service).encode(ExternalEncoding), input_name='service'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='service_control_code'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='service_control_code'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.control_code is not None:
            showIndent(outfile, level)
            outfile.write('control_code = "%s",\n' % (self.control_code,))
        if self.service is not None:
            showIndent(outfile, level)
            outfile.write('service = "%s",\n' % (self.service,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('control_code')
        if value is not None:
            already_processed.append('control_code')
            self.control_code = value
        value = attrs.get('service')
        if value is not None:
            already_processed.append('service')
            self.service = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class service_control_code


class process_activities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, process_created=None, process_killed=None, remote_thread_created=None, thread_information=None, foreign_mem_area_read=None, foreign_mem_area_write=None):
        if process_created is None:
            self.process_created = []
        else:
            self.process_created = process_created
        if process_killed is None:
            self.process_killed = []
        else:
            self.process_killed = process_killed
        if remote_thread_created is None:
            self.remote_thread_created = []
        else:
            self.remote_thread_created = remote_thread_created
        if thread_information is None:
            self.thread_information = []
        else:
            self.thread_information = thread_information
        if foreign_mem_area_read is None:
            self.foreign_mem_area_read = []
        else:
            self.foreign_mem_area_read = foreign_mem_area_read
        if foreign_mem_area_write is None:
            self.foreign_mem_area_write = []
        else:
            self.foreign_mem_area_write = foreign_mem_area_write
    def factory(*args_, **kwargs_):
        if process_activities.subclass:
            return process_activities.subclass(*args_, **kwargs_)
        else:
            return process_activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_process_created(self): return self.process_created
    def set_process_created(self, process_created): self.process_created = process_created
    def add_process_created(self, value): self.process_created.append(value)
    def insert_process_created(self, index, value): self.process_created[index] = value
    def get_process_killed(self): return self.process_killed
    def set_process_killed(self, process_killed): self.process_killed = process_killed
    def add_process_killed(self, value): self.process_killed.append(value)
    def insert_process_killed(self, index, value): self.process_killed[index] = value
    def get_remote_thread_created(self): return self.remote_thread_created
    def set_remote_thread_created(self, remote_thread_created): self.remote_thread_created = remote_thread_created
    def add_remote_thread_created(self, value): self.remote_thread_created.append(value)
    def insert_remote_thread_created(self, index, value): self.remote_thread_created[index] = value
    def get_thread_information(self): return self.thread_information
    def set_thread_information(self, thread_information): self.thread_information = thread_information
    def add_thread_information(self, value): self.thread_information.append(value)
    def insert_thread_information(self, index, value): self.thread_information[index] = value
    def get_foreign_mem_area_read(self): return self.foreign_mem_area_read
    def set_foreign_mem_area_read(self, foreign_mem_area_read): self.foreign_mem_area_read = foreign_mem_area_read
    def add_foreign_mem_area_read(self, value): self.foreign_mem_area_read.append(value)
    def insert_foreign_mem_area_read(self, index, value): self.foreign_mem_area_read[index] = value
    def get_foreign_mem_area_write(self): return self.foreign_mem_area_write
    def set_foreign_mem_area_write(self, foreign_mem_area_write): self.foreign_mem_area_write = foreign_mem_area_write
    def add_foreign_mem_area_write(self, value): self.foreign_mem_area_write.append(value)
    def insert_foreign_mem_area_write(self, index, value): self.foreign_mem_area_write[index] = value
    def export(self, outfile, level, namespace_='', name_='process_activities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='process_activities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='process_activities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='process_activities'):
        for process_created_ in self.process_created:
            process_created_.export(outfile, level, namespace_, name_='process_created')
        for process_killed_ in self.process_killed:
            process_killed_.export(outfile, level, namespace_, name_='process_killed')
        for remote_thread_created_ in self.remote_thread_created:
            remote_thread_created_.export(outfile, level, namespace_, name_='remote_thread_created')
        for thread_information_ in self.thread_information:
            thread_information_.export(outfile, level, namespace_, name_='thread_information')
        for foreign_mem_area_read_ in self.foreign_mem_area_read:
            foreign_mem_area_read_.export(outfile, level, namespace_, name_='foreign_mem_area_read')
        for foreign_mem_area_write_ in self.foreign_mem_area_write:
            foreign_mem_area_write_.export(outfile, level, namespace_, name_='foreign_mem_area_write')
    def hasContent_(self):
        if (
            self.process_created or
            self.process_killed or
            self.remote_thread_created or
            self.thread_information or
            self.foreign_mem_area_read or
            self.foreign_mem_area_write
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='process_activities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('process_created=[\n')
        level += 1
        for process_created_ in self.process_created:
            showIndent(outfile, level)
            outfile.write('model_.process_created(\n')
            process_created_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('process_killed=[\n')
        level += 1
        for process_killed_ in self.process_killed:
            showIndent(outfile, level)
            outfile.write('model_.process_killed(\n')
            process_killed_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('remote_thread_created=[\n')
        level += 1
        for remote_thread_created_ in self.remote_thread_created:
            showIndent(outfile, level)
            outfile.write('model_.remote_thread_created(\n')
            remote_thread_created_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('thread_information=[\n')
        level += 1
        for thread_information_ in self.thread_information:
            showIndent(outfile, level)
            outfile.write('model_.thread_information(\n')
            thread_information_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('foreign_mem_area_read=[\n')
        level += 1
        for foreign_mem_area_read_ in self.foreign_mem_area_read:
            showIndent(outfile, level)
            outfile.write('model_.foreign_mem_area_read(\n')
            foreign_mem_area_read_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('foreign_mem_area_write=[\n')
        level += 1
        for foreign_mem_area_write_ in self.foreign_mem_area_write:
            showIndent(outfile, level)
            outfile.write('model_.foreign_mem_area_write(\n')
            foreign_mem_area_write_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'process_created': 
            obj_ = process_created.factory()
            obj_.build(child_)
            self.process_created.append(obj_)
        elif nodeName_ == 'process_killed': 
            obj_ = process_killed.factory()
            obj_.build(child_)
            self.process_killed.append(obj_)
        elif nodeName_ == 'remote_thread_created': 
            obj_ = remote_thread_created.factory()
            obj_.build(child_)
            self.remote_thread_created.append(obj_)
        elif nodeName_ == 'thread_information': 
            obj_ = thread_information.factory()
            obj_.build(child_)
            self.thread_information.append(obj_)
        elif nodeName_ == 'foreign_mem_area_read': 
            obj_ = foreign_mem_area_read.factory()
            obj_.build(child_)
            self.foreign_mem_area_read.append(obj_)
        elif nodeName_ == 'foreign_mem_area_write': 
            obj_ = foreign_mem_area_write.factory()
            obj_.build(child_)
            self.foreign_mem_area_write.append(obj_)
# end class process_activities


class process_created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, exe_name=None, cmd_line=None, description=None, valueOf_=None):
        self.exe_name = _cast(None, exe_name)
        self.cmd_line = _cast(None, cmd_line)
        self.description = _cast(None, description)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if process_created.subclass:
            return process_created.subclass(*args_, **kwargs_)
        else:
            return process_created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exe_name(self): return self.exe_name
    def set_exe_name(self, exe_name): self.exe_name = exe_name
    def get_cmd_line(self): return self.cmd_line
    def set_cmd_line(self, cmd_line): self.cmd_line = cmd_line
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='process_created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='process_created')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='process_created'):
        outfile.write(' exe_name=%s' % (self.gds_format_string(quote_attrib(self.exe_name).encode(ExternalEncoding), input_name='exe_name'), ))
        outfile.write(' cmd_line=%s' % (self.gds_format_string(quote_attrib(self.cmd_line).encode(ExternalEncoding), input_name='cmd_line'), ))
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
    def exportChildren(self, outfile, level, namespace_='', name_='process_created'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='process_created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.exe_name is not None:
            showIndent(outfile, level)
            outfile.write('exe_name = "%s",\n' % (self.exe_name,))
        if self.cmd_line is not None:
            showIndent(outfile, level)
            outfile.write('cmd_line = "%s",\n' % (self.cmd_line,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('exe_name')
        if value is not None:
            already_processed.append('exe_name')
            self.exe_name = value
        value = attrs.get('cmd_line')
        if value is not None:
            already_processed.append('cmd_line')
            self.cmd_line = value
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class process_created


class process_killed(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, valueOf_=None):
        self.description = _cast(None, description)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if process_killed.subclass:
            return process_killed.subclass(*args_, **kwargs_)
        else:
            return process_killed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='process_killed', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='process_killed')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='process_killed'):
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='process_killed'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='process_killed'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class process_killed


class remote_thread_created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, process=None, valueOf_=None):
        self.process = _cast(None, process)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if remote_thread_created.subclass:
            return remote_thread_created.subclass(*args_, **kwargs_)
        else:
            return remote_thread_created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_process(self): return self.process
    def set_process(self, process): self.process = process
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='remote_thread_created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='remote_thread_created')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='remote_thread_created'):
        outfile.write(' process=%s' % (self.gds_format_string(quote_attrib(self.process).encode(ExternalEncoding), input_name='process'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='remote_thread_created'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='remote_thread_created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.process is not None:
            showIndent(outfile, level)
            outfile.write('process = "%s",\n' % (self.process,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('process')
        if value is not None:
            already_processed.append('process')
            self.process = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class remote_thread_created


class thread_information(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, thread_status=None):
        if thread_status is None:
            self.thread_status = []
        else:
            self.thread_status = thread_status
    def factory(*args_, **kwargs_):
        if thread_information.subclass:
            return thread_information.subclass(*args_, **kwargs_)
        else:
            return thread_information(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thread_status(self): return self.thread_status
    def set_thread_status(self, thread_status): self.thread_status = thread_status
    def add_thread_status(self, value): self.thread_status.append(value)
    def insert_thread_status(self, index, value): self.thread_status[index] = value
    def export(self, outfile, level, namespace_='', name_='thread_information', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='thread_information')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='thread_information'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='thread_information'):
        for thread_status_ in self.thread_status:
            thread_status_.export(outfile, level, namespace_, name_='thread_status')
    def hasContent_(self):
        if (
            self.thread_status
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='thread_information'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('thread_status=[\n')
        level += 1
        for thread_status_ in self.thread_status:
            showIndent(outfile, level)
            outfile.write('model_.thread_status(\n')
            thread_status_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'thread_status': 
            obj_ = thread_status.factory()
            obj_.build(child_)
            self.thread_status.append(obj_)
# end class thread_information


class thread_status(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number_of_threads=None, time=None, valueOf_=None):
        self.number_of_threads = _cast(int, number_of_threads)
        self.time = _cast(int, time)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if thread_status.subclass:
            return thread_status.subclass(*args_, **kwargs_)
        else:
            return thread_status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_number_of_threads(self): return self.number_of_threads
    def set_number_of_threads(self, number_of_threads): self.number_of_threads = number_of_threads
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='thread_status', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='thread_status')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='thread_status'):
        outfile.write(' number_of_threads="%s"' % self.gds_format_integer(self.number_of_threads, input_name='number_of_threads'))
        outfile.write(' time="%s"' % self.gds_format_integer(self.time, input_name='time'))
    def exportChildren(self, outfile, level, namespace_='', name_='thread_status'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='thread_status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.number_of_threads is not None:
            showIndent(outfile, level)
            outfile.write('number_of_threads = %d,\n' % (self.number_of_threads,))
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('time = %d,\n' % (self.time,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('number_of_threads')
        if value is not None:
            already_processed.append('number_of_threads')
            try:
                self.number_of_threads = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('time')
        if value is not None:
            already_processed.append('time')
            try:
                self.time = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class thread_status


class foreign_mem_area_read(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, process=None, valueOf_=None):
        self.process = _cast(None, process)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if foreign_mem_area_read.subclass:
            return foreign_mem_area_read.subclass(*args_, **kwargs_)
        else:
            return foreign_mem_area_read(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_process(self): return self.process
    def set_process(self, process): self.process = process
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='foreign_mem_area_read', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='foreign_mem_area_read')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='foreign_mem_area_read'):
        outfile.write(' process=%s' % (self.gds_format_string(quote_attrib(self.process).encode(ExternalEncoding), input_name='process'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='foreign_mem_area_read'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='foreign_mem_area_read'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.process is not None:
            showIndent(outfile, level)
            outfile.write('process = "%s",\n' % (self.process,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('process')
        if value is not None:
            already_processed.append('process')
            self.process = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class foreign_mem_area_read


class foreign_mem_area_write(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, process=None, valueOf_=None):
        self.process = _cast(None, process)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if foreign_mem_area_write.subclass:
            return foreign_mem_area_write.subclass(*args_, **kwargs_)
        else:
            return foreign_mem_area_write(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_process(self): return self.process
    def set_process(self, process): self.process = process
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='foreign_mem_area_write', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='foreign_mem_area_write')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='foreign_mem_area_write'):
        outfile.write(' process=%s' % (self.gds_format_string(quote_attrib(self.process).encode(ExternalEncoding), input_name='process'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='foreign_mem_area_write'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='foreign_mem_area_write'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.process is not None:
            showIndent(outfile, level)
            outfile.write('process = "%s",\n' % (self.process,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('process')
        if value is not None:
            already_processed.append('process')
            self.process = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class foreign_mem_area_write


class global_network_activities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dns_queries=None, sockets=None, ping_requests=None, icmp_traffic=None, tcp_traffic=None, udp_traffic=None):
        if dns_queries is None:
            self.dns_queries = []
        else:
            self.dns_queries = dns_queries
        if sockets is None:
            self.sockets = []
        else:
            self.sockets = sockets
        if ping_requests is None:
            self.ping_requests = []
        else:
            self.ping_requests = ping_requests
        if icmp_traffic is None:
            self.icmp_traffic = []
        else:
            self.icmp_traffic = icmp_traffic
        if tcp_traffic is None:
            self.tcp_traffic = []
        else:
            self.tcp_traffic = tcp_traffic
        if udp_traffic is None:
            self.udp_traffic = []
        else:
            self.udp_traffic = udp_traffic
    def factory(*args_, **kwargs_):
        if global_network_activities.subclass:
            return global_network_activities.subclass(*args_, **kwargs_)
        else:
            return global_network_activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dns_queries(self): return self.dns_queries
    def set_dns_queries(self, dns_queries): self.dns_queries = dns_queries
    def add_dns_queries(self, value): self.dns_queries.append(value)
    def insert_dns_queries(self, index, value): self.dns_queries[index] = value
    def get_sockets(self): return self.sockets
    def set_sockets(self, sockets): self.sockets = sockets
    def add_sockets(self, value): self.sockets.append(value)
    def insert_sockets(self, index, value): self.sockets[index] = value
    def get_ping_requests(self): return self.ping_requests
    def set_ping_requests(self, ping_requests): self.ping_requests = ping_requests
    def add_ping_requests(self, value): self.ping_requests.append(value)
    def insert_ping_requests(self, index, value): self.ping_requests[index] = value
    def get_icmp_traffic(self): return self.icmp_traffic
    def set_icmp_traffic(self, icmp_traffic): self.icmp_traffic = icmp_traffic
    def add_icmp_traffic(self, value): self.icmp_traffic.append(value)
    def insert_icmp_traffic(self, index, value): self.icmp_traffic[index] = value
    def get_tcp_traffic(self): return self.tcp_traffic
    def set_tcp_traffic(self, tcp_traffic): self.tcp_traffic = tcp_traffic
    def add_tcp_traffic(self, value): self.tcp_traffic.append(value)
    def insert_tcp_traffic(self, index, value): self.tcp_traffic[index] = value
    def get_udp_traffic(self): return self.udp_traffic
    def set_udp_traffic(self, udp_traffic): self.udp_traffic = udp_traffic
    def add_udp_traffic(self, value): self.udp_traffic.append(value)
    def insert_udp_traffic(self, index, value): self.udp_traffic[index] = value
    def export(self, outfile, level, namespace_='', name_='global_network_activities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='global_network_activities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='global_network_activities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='global_network_activities'):
        for dns_queries_ in self.dns_queries:
            dns_queries_.export(outfile, level, namespace_, name_='dns_queries')
        for sockets_ in self.sockets:
            sockets_.export(outfile, level, namespace_, name_='sockets')
        for ping_requests_ in self.ping_requests:
            ping_requests_.export(outfile, level, namespace_, name_='ping_requests')
        for icmp_traffic_ in self.icmp_traffic:
            icmp_traffic_.export(outfile, level, namespace_, name_='icmp_traffic')
        for tcp_traffic_ in self.tcp_traffic:
            tcp_traffic_.export(outfile, level, namespace_, name_='tcp_traffic')
        for udp_traffic_ in self.udp_traffic:
            udp_traffic_.export(outfile, level, namespace_, name_='udp_traffic')
    def hasContent_(self):
        if (
            self.dns_queries or
            self.sockets or
            self.ping_requests or
            self.icmp_traffic or
            self.tcp_traffic or
            self.udp_traffic
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='global_network_activities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('dns_queries=[\n')
        level += 1
        for dns_queries_ in self.dns_queries:
            showIndent(outfile, level)
            outfile.write('model_.dns_queries(\n')
            dns_queries_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('sockets=[\n')
        level += 1
        for sockets_ in self.sockets:
            showIndent(outfile, level)
            outfile.write('model_.sockets(\n')
            sockets_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ping_requests=[\n')
        level += 1
        for ping_requests_ in self.ping_requests:
            showIndent(outfile, level)
            outfile.write('model_.ping_requests(\n')
            ping_requests_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('icmp_traffic=[\n')
        level += 1
        for icmp_traffic_ in self.icmp_traffic:
            showIndent(outfile, level)
            outfile.write('model_.icmp_traffic(\n')
            icmp_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tcp_traffic=[\n')
        level += 1
        for tcp_traffic_ in self.tcp_traffic:
            showIndent(outfile, level)
            outfile.write('model_.tcp_traffic(\n')
            tcp_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('udp_traffic=[\n')
        level += 1
        for udp_traffic_ in self.udp_traffic:
            showIndent(outfile, level)
            outfile.write('model_.udp_traffic(\n')
            udp_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'dns_queries': 
            obj_ = dns_queries.factory()
            obj_.build(child_)
            self.dns_queries.append(obj_)
        elif nodeName_ == 'sockets': 
            obj_ = sockets.factory()
            obj_.build(child_)
            self.sockets.append(obj_)
        elif nodeName_ == 'ping_requests': 
            obj_ = ping_requests.factory()
            obj_.build(child_)
            self.ping_requests.append(obj_)
        elif nodeName_ == 'icmp_traffic': 
            obj_ = icmp_traffic.factory()
            obj_.build(child_)
            self.icmp_traffic.append(obj_)
        elif nodeName_ == 'tcp_traffic': 
            obj_ = tcp_traffic.factory()
            obj_.build(child_)
            self.tcp_traffic.append(obj_)
        elif nodeName_ == 'udp_traffic': 
            obj_ = udp_traffic.factory()
            obj_.build(child_)
            self.udp_traffic.append(obj_)
# end class global_network_activities


class network_activities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dns_queries=None, sockets=None, ping_requests=None, icmp_traffic=None, tcp_traffic=None, udp_traffic=None):
        if dns_queries is None:
            self.dns_queries = []
        else:
            self.dns_queries = dns_queries
        if sockets is None:
            self.sockets = []
        else:
            self.sockets = sockets
        if ping_requests is None:
            self.ping_requests = []
        else:
            self.ping_requests = ping_requests
        if icmp_traffic is None:
            self.icmp_traffic = []
        else:
            self.icmp_traffic = icmp_traffic
        if tcp_traffic is None:
            self.tcp_traffic = []
        else:
            self.tcp_traffic = tcp_traffic
        if udp_traffic is None:
            self.udp_traffic = []
        else:
            self.udp_traffic = udp_traffic
    def factory(*args_, **kwargs_):
        if network_activities.subclass:
            return network_activities.subclass(*args_, **kwargs_)
        else:
            return network_activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dns_queries(self): return self.dns_queries
    def set_dns_queries(self, dns_queries): self.dns_queries = dns_queries
    def add_dns_queries(self, value): self.dns_queries.append(value)
    def insert_dns_queries(self, index, value): self.dns_queries[index] = value
    def get_sockets(self): return self.sockets
    def set_sockets(self, sockets): self.sockets = sockets
    def add_sockets(self, value): self.sockets.append(value)
    def insert_sockets(self, index, value): self.sockets[index] = value
    def get_ping_requests(self): return self.ping_requests
    def set_ping_requests(self, ping_requests): self.ping_requests = ping_requests
    def add_ping_requests(self, value): self.ping_requests.append(value)
    def insert_ping_requests(self, index, value): self.ping_requests[index] = value
    def get_icmp_traffic(self): return self.icmp_traffic
    def set_icmp_traffic(self, icmp_traffic): self.icmp_traffic = icmp_traffic
    def add_icmp_traffic(self, value): self.icmp_traffic.append(value)
    def insert_icmp_traffic(self, index, value): self.icmp_traffic[index] = value
    def get_tcp_traffic(self): return self.tcp_traffic
    def set_tcp_traffic(self, tcp_traffic): self.tcp_traffic = tcp_traffic
    def add_tcp_traffic(self, value): self.tcp_traffic.append(value)
    def insert_tcp_traffic(self, index, value): self.tcp_traffic[index] = value
    def get_udp_traffic(self): return self.udp_traffic
    def set_udp_traffic(self, udp_traffic): self.udp_traffic = udp_traffic
    def add_udp_traffic(self, value): self.udp_traffic.append(value)
    def insert_udp_traffic(self, index, value): self.udp_traffic[index] = value
    def export(self, outfile, level, namespace_='', name_='network_activities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='network_activities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='network_activities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='network_activities'):
        for dns_queries_ in self.dns_queries:
            dns_queries_.export(outfile, level, namespace_, name_='dns_queries')
        for sockets_ in self.sockets:
            sockets_.export(outfile, level, namespace_, name_='sockets')
        for ping_requests_ in self.ping_requests:
            ping_requests_.export(outfile, level, namespace_, name_='ping_requests')
        for icmp_traffic_ in self.icmp_traffic:
            icmp_traffic_.export(outfile, level, namespace_, name_='icmp_traffic')
        for tcp_traffic_ in self.tcp_traffic:
            tcp_traffic_.export(outfile, level, namespace_, name_='tcp_traffic')
        for udp_traffic_ in self.udp_traffic:
            udp_traffic_.export(outfile, level, namespace_, name_='udp_traffic')
    def hasContent_(self):
        if (
            self.dns_queries or
            self.sockets or
            self.ping_requests or
            self.icmp_traffic or
            self.tcp_traffic or
            self.udp_traffic
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='network_activities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('dns_queries=[\n')
        level += 1
        for dns_queries_ in self.dns_queries:
            showIndent(outfile, level)
            outfile.write('model_.dns_queries(\n')
            dns_queries_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('sockets=[\n')
        level += 1
        for sockets_ in self.sockets:
            showIndent(outfile, level)
            outfile.write('model_.sockets(\n')
            sockets_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ping_requests=[\n')
        level += 1
        for ping_requests_ in self.ping_requests:
            showIndent(outfile, level)
            outfile.write('model_.ping_requests(\n')
            ping_requests_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('icmp_traffic=[\n')
        level += 1
        for icmp_traffic_ in self.icmp_traffic:
            showIndent(outfile, level)
            outfile.write('model_.icmp_traffic(\n')
            icmp_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tcp_traffic=[\n')
        level += 1
        for tcp_traffic_ in self.tcp_traffic:
            showIndent(outfile, level)
            outfile.write('model_.tcp_traffic(\n')
            tcp_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('udp_traffic=[\n')
        level += 1
        for udp_traffic_ in self.udp_traffic:
            showIndent(outfile, level)
            outfile.write('model_.udp_traffic(\n')
            udp_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'dns_queries': 
            obj_ = dns_queries.factory()
            obj_.build(child_)
            self.dns_queries.append(obj_)
        elif nodeName_ == 'sockets': 
            obj_ = sockets.factory()
            obj_.build(child_)
            self.sockets.append(obj_)
        elif nodeName_ == 'ping_requests': 
            obj_ = ping_requests.factory()
            obj_.build(child_)
            self.ping_requests.append(obj_)
        elif nodeName_ == 'icmp_traffic': 
            obj_ = icmp_traffic.factory()
            obj_.build(child_)
            self.icmp_traffic.append(obj_)
        elif nodeName_ == 'tcp_traffic': 
            obj_ = tcp_traffic.factory()
            obj_.build(child_)
            self.tcp_traffic.append(obj_)
        elif nodeName_ == 'udp_traffic': 
            obj_ = udp_traffic.factory()
            obj_.build(child_)
            self.udp_traffic.append(obj_)
# end class network_activities


class dns_queries(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dns_query=None):
        if dns_query is None:
            self.dns_query = []
        else:
            self.dns_query = dns_query
    def factory(*args_, **kwargs_):
        if dns_queries.subclass:
            return dns_queries.subclass(*args_, **kwargs_)
        else:
            return dns_queries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dns_query(self): return self.dns_query
    def set_dns_query(self, dns_query): self.dns_query = dns_query
    def add_dns_query(self, value): self.dns_query.append(value)
    def insert_dns_query(self, index, value): self.dns_query[index] = value
    def export(self, outfile, level, namespace_='', name_='dns_queries', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dns_queries')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='dns_queries'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dns_queries'):
        for dns_query_ in self.dns_query:
            dns_query_.export(outfile, level, namespace_, name_='dns_query')
    def hasContent_(self):
        if (
            self.dns_query
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dns_queries'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('dns_query=[\n')
        level += 1
        for dns_query_ in self.dns_query:
            showIndent(outfile, level)
            outfile.write('model_.dns_query(\n')
            dns_query_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'dns_query': 
            obj_ = dns_query.factory()
            obj_.build(child_)
            self.dns_query.append(obj_)
# end class dns_queries


class dns_query(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, protocol=None, name=None, successful=None, src_ip=None, result=None, src_port=None, dest_ip=None, type_=None, dest_port=None, valueOf_=None):
        self.protocol = _cast(None, protocol)
        self.name = _cast(None, name)
        self.successful = _cast(None, successful)
        self.src_ip = _cast(None, src_ip)
        self.result = _cast(None, result)
        self.src_port = _cast(int, src_port)
        self.dest_ip = _cast(None, dest_ip)
        self.type_ = _cast(None, type_)
        self.dest_port = _cast(int, dest_port)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dns_query.subclass:
            return dns_query.subclass(*args_, **kwargs_)
        else:
            return dns_query(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_successful(self): return self.successful
    def set_successful(self, successful): self.successful = successful
    def get_src_ip(self): return self.src_ip
    def set_src_ip(self, src_ip): self.src_ip = src_ip
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_dest_ip(self): return self.dest_ip
    def set_dest_ip(self, dest_ip): self.dest_ip = dest_ip
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_dest_port(self): return self.dest_port
    def set_dest_port(self, dest_port): self.dest_port = dest_port
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='dns_query', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dns_query')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='dns_query'):
        if self.protocol is not None:
            outfile.write(' protocol=%s' % (self.gds_format_string(quote_attrib(self.protocol).encode(ExternalEncoding), input_name='protocol'), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' successful=%s' % (self.gds_format_string(quote_attrib(self.successful).encode(ExternalEncoding), input_name='successful'), ))
        if self.src_ip is not None:
            outfile.write(' src_ip=%s' % (self.gds_format_string(quote_attrib(self.src_ip).encode(ExternalEncoding), input_name='src_ip'), ))
        outfile.write(' result=%s' % (self.gds_format_string(quote_attrib(self.result).encode(ExternalEncoding), input_name='result'), ))
        if self.src_port is not None:
            outfile.write(' src_port="%s"' % self.gds_format_integer(self.src_port, input_name='src_port'))
        if self.dest_ip is not None:
            outfile.write(' dest_ip=%s' % (self.gds_format_string(quote_attrib(self.dest_ip).encode(ExternalEncoding), input_name='dest_ip'), ))
        outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.dest_port is not None:
            outfile.write(' dest_port="%s"' % self.gds_format_integer(self.dest_port, input_name='dest_port'))
    def exportChildren(self, outfile, level, namespace_='', name_='dns_query'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dns_query'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol = "%s",\n' % (self.protocol,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.successful is not None:
            showIndent(outfile, level)
            outfile.write('successful = "%s",\n' % (self.successful,))
        if self.src_ip is not None:
            showIndent(outfile, level)
            outfile.write('src_ip = "%s",\n' % (self.src_ip,))
        if self.result is not None:
            showIndent(outfile, level)
            outfile.write('result = "%s",\n' % (self.result,))
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port = %d,\n' % (self.src_port,))
        if self.dest_ip is not None:
            showIndent(outfile, level)
            outfile.write('dest_ip = "%s",\n' % (self.dest_ip,))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.dest_port is not None:
            showIndent(outfile, level)
            outfile.write('dest_port = %d,\n' % (self.dest_port,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('protocol')
        if value is not None:
            already_processed.append('protocol')
            self.protocol = value
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
        value = attrs.get('successful')
        if value is not None:
            already_processed.append('successful')
            self.successful = value
        value = attrs.get('src_ip')
        if value is not None:
            already_processed.append('src_ip')
            self.src_ip = value
        value = attrs.get('result')
        if value is not None:
            already_processed.append('result')
            self.result = value
        value = attrs.get('src_port')
        if value is not None:
            already_processed.append('src_port')
            try:
                self.src_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('dest_ip')
        if value is not None:
            already_processed.append('dest_ip')
            self.dest_ip = value
        value = attrs.get('type')
        if value is not None:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('dest_port')
        if value is not None:
            already_processed.append('dest_port')
            try:
                self.dest_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class dns_query


class sockets(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, socket=None):
        if socket is None:
            self.socket = []
        else:
            self.socket = socket
    def factory(*args_, **kwargs_):
        if sockets.subclass:
            return sockets.subclass(*args_, **kwargs_)
        else:
            return sockets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_socket(self): return self.socket
    def set_socket(self, socket): self.socket = socket
    def add_socket(self, value): self.socket.append(value)
    def insert_socket(self, index, value): self.socket[index] = value
    def export(self, outfile, level, namespace_='', name_='sockets', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sockets')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='sockets'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sockets'):
        for socket_ in self.socket:
            socket_.export(outfile, level, namespace_, name_='socket')
    def hasContent_(self):
        if (
            self.socket
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sockets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('socket=[\n')
        level += 1
        for socket_ in self.socket:
            showIndent(outfile, level)
            outfile.write('model_.socket(\n')
            socket_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'socket': 
            obj_ = socket.factory()
            obj_.build(child_)
            self.socket.append(obj_)
# end class sockets


class socket(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, is_listening=None, local_ip=None, type_=None, local_port=None, close_time=None, foreign_port=None, create_time=None, foreign_ip=None, created_by_thread=None, valueOf_=None):
        self.is_listening = _cast(int, is_listening)
        self.local_ip = _cast(None, local_ip)
        self.type_ = _cast(None, type_)
        self.local_port = _cast(int, local_port)
        self.close_time = _cast(None, close_time)
        self.foreign_port = _cast(int, foreign_port)
        self.create_time = _cast(None, create_time)
        self.foreign_ip = _cast(None, foreign_ip)
        self.created_by_thread = _cast(int, created_by_thread)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if socket.subclass:
            return socket.subclass(*args_, **kwargs_)
        else:
            return socket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_is_listening(self): return self.is_listening
    def set_is_listening(self, is_listening): self.is_listening = is_listening
    def get_local_ip(self): return self.local_ip
    def set_local_ip(self, local_ip): self.local_ip = local_ip
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_local_port(self): return self.local_port
    def set_local_port(self, local_port): self.local_port = local_port
    def get_close_time(self): return self.close_time
    def set_close_time(self, close_time): self.close_time = close_time
    def get_foreign_port(self): return self.foreign_port
    def set_foreign_port(self, foreign_port): self.foreign_port = foreign_port
    def get_create_time(self): return self.create_time
    def set_create_time(self, create_time): self.create_time = create_time
    def get_foreign_ip(self): return self.foreign_ip
    def set_foreign_ip(self, foreign_ip): self.foreign_ip = foreign_ip
    def get_created_by_thread(self): return self.created_by_thread
    def set_created_by_thread(self, created_by_thread): self.created_by_thread = created_by_thread
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='socket', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='socket')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='socket'):
        outfile.write(' is_listening="%s"' % self.gds_format_integer(self.is_listening, input_name='is_listening'))
        outfile.write(' local_ip=%s' % (self.gds_format_string(quote_attrib(self.local_ip).encode(ExternalEncoding), input_name='local_ip'), ))
        outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        outfile.write(' local_port="%s"' % self.gds_format_integer(self.local_port, input_name='local_port'))
        outfile.write(' close_time=%s' % (self.gds_format_string(quote_attrib(self.close_time).encode(ExternalEncoding), input_name='close_time'), ))
        outfile.write(' foreign_port="%s"' % self.gds_format_integer(self.foreign_port, input_name='foreign_port'))
        outfile.write(' create_time=%s' % (self.gds_format_string(quote_attrib(self.create_time).encode(ExternalEncoding), input_name='create_time'), ))
        outfile.write(' foreign_ip=%s' % (self.gds_format_string(quote_attrib(self.foreign_ip).encode(ExternalEncoding), input_name='foreign_ip'), ))
        outfile.write(' created_by_thread="%s"' % self.gds_format_integer(self.created_by_thread, input_name='created_by_thread'))
    def exportChildren(self, outfile, level, namespace_='', name_='socket'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='socket'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.is_listening is not None:
            showIndent(outfile, level)
            outfile.write('is_listening = %d,\n' % (self.is_listening,))
        if self.local_ip is not None:
            showIndent(outfile, level)
            outfile.write('local_ip = "%s",\n' % (self.local_ip,))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.local_port is not None:
            showIndent(outfile, level)
            outfile.write('local_port = %d,\n' % (self.local_port,))
        if self.close_time is not None:
            showIndent(outfile, level)
            outfile.write('close_time = "%s",\n' % (self.close_time,))
        if self.foreign_port is not None:
            showIndent(outfile, level)
            outfile.write('foreign_port = %d,\n' % (self.foreign_port,))
        if self.create_time is not None:
            showIndent(outfile, level)
            outfile.write('create_time = "%s",\n' % (self.create_time,))
        if self.foreign_ip is not None:
            showIndent(outfile, level)
            outfile.write('foreign_ip = "%s",\n' % (self.foreign_ip,))
        if self.created_by_thread is not None:
            showIndent(outfile, level)
            outfile.write('created_by_thread = %d,\n' % (self.created_by_thread,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('is_listening')
        if value is not None:
            already_processed.append('is_listening')
            try:
                self.is_listening = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('local_ip')
        if value is not None:
            already_processed.append('local_ip')
            self.local_ip = value
        value = attrs.get('type')
        if value is not None:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('local_port')
        if value is not None:
            already_processed.append('local_port')
            try:
                self.local_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('close_time')
        if value is not None:
            already_processed.append('close_time')
            self.close_time = value
        value = attrs.get('foreign_port')
        if value is not None:
            already_processed.append('foreign_port')
            try:
                self.foreign_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('create_time')
        if value is not None:
            already_processed.append('create_time')
            self.create_time = value
        value = attrs.get('foreign_ip')
        if value is not None:
            already_processed.append('foreign_ip')
            self.foreign_ip = value
        value = attrs.get('created_by_thread')
        if value is not None:
            already_processed.append('created_by_thread')
            try:
                self.created_by_thread = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class socket


class ping_requests(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ping_request=None):
        if ping_request is None:
            self.ping_request = []
        else:
            self.ping_request = ping_request
    def factory(*args_, **kwargs_):
        if ping_requests.subclass:
            return ping_requests.subclass(*args_, **kwargs_)
        else:
            return ping_requests(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ping_request(self): return self.ping_request
    def set_ping_request(self, ping_request): self.ping_request = ping_request
    def add_ping_request(self, value): self.ping_request.append(value)
    def insert_ping_request(self, index, value): self.ping_request[index] = value
    def export(self, outfile, level, namespace_='', name_='ping_requests', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ping_requests')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ping_requests'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ping_requests'):
        for ping_request_ in self.ping_request:
            ping_request_.export(outfile, level, namespace_, name_='ping_request')
    def hasContent_(self):
        if (
            self.ping_request
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ping_requests'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ping_request=[\n')
        level += 1
        for ping_request_ in self.ping_request:
            showIndent(outfile, level)
            outfile.write('model_.ping_request(\n')
            ping_request_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'ping_request': 
            obj_ = ping_request.factory()
            obj_.build(child_)
            self.ping_request.append(obj_)
# end class ping_requests


class ping_request(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dest=None, got_reply=None, valueOf_=None):
        self.dest = _cast(None, dest)
        self.got_reply = _cast(int, got_reply)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ping_request.subclass:
            return ping_request.subclass(*args_, **kwargs_)
        else:
            return ping_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dest(self): return self.dest
    def set_dest(self, dest): self.dest = dest
    def get_got_reply(self): return self.got_reply
    def set_got_reply(self, got_reply): self.got_reply = got_reply
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='ping_request', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ping_request')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ping_request'):
        outfile.write(' dest=%s' % (quote_attrib(self.dest), ))
        outfile.write(' got_reply="%s"' % self.gds_format_integer(self.got_reply, input_name='got_reply'))
    def exportChildren(self, outfile, level, namespace_='', name_='ping_request'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ping_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.dest is not None:
            showIndent(outfile, level)
            outfile.write('dest = %s,\n' % (self.dest,))
        if self.got_reply is not None:
            showIndent(outfile, level)
            outfile.write('got_reply = %d,\n' % (self.got_reply,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('dest')
        if value is not None:
            already_processed.append('dest')
            self.dest = value
        value = attrs.get('got_reply')
        if value is not None:
            already_processed.append('got_reply')
            try:
                self.got_reply = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class ping_request


class icmp_traffic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pings=None):
        self.pings = pings
    def factory(*args_, **kwargs_):
        if icmp_traffic.subclass:
            return icmp_traffic.subclass(*args_, **kwargs_)
        else:
            return icmp_traffic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pings(self): return self.pings
    def set_pings(self, pings): self.pings = pings
    def export(self, outfile, level, namespace_='', name_='icmp_traffic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='icmp_traffic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='icmp_traffic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='icmp_traffic'):
        if self.pings:
            self.pings.export(outfile, level, namespace_, name_='pings')
    def hasContent_(self):
        if (
            self.pings is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='icmp_traffic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.pings is not None:
            showIndent(outfile, level)
            outfile.write('pings=model_.pings(\n')
            self.pings.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'pings': 
            obj_ = pings.factory()
            obj_.build(child_)
            self.set_pings(obj_)
# end class icmp_traffic


class pings(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, subnet=None, sent=None, got_reply=None, valueOf_=None):
        self.subnet = _cast(None, subnet)
        self.sent = _cast(int, sent)
        self.got_reply = _cast(int, got_reply)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if pings.subclass:
            return pings.subclass(*args_, **kwargs_)
        else:
            return pings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subnet(self): return self.subnet
    def set_subnet(self, subnet): self.subnet = subnet
    def get_sent(self): return self.sent
    def set_sent(self, sent): self.sent = sent
    def get_got_reply(self): return self.got_reply
    def set_got_reply(self, got_reply): self.got_reply = got_reply
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='pings', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='pings')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='pings'):
        if self.subnet is not None:
            outfile.write(' subnet=%s' % (self.gds_format_string(quote_attrib(self.subnet).encode(ExternalEncoding), input_name='subnet'), ))
        outfile.write(' sent="%s"' % self.gds_format_integer(self.sent, input_name='sent'))
        outfile.write(' got_reply="%s"' % self.gds_format_integer(self.got_reply, input_name='got_reply'))
    def exportChildren(self, outfile, level, namespace_='', name_='pings'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pings'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.subnet is not None:
            showIndent(outfile, level)
            outfile.write('subnet = "%s",\n' % (self.subnet,))
        if self.sent is not None:
            showIndent(outfile, level)
            outfile.write('sent = %d,\n' % (self.sent,))
        if self.got_reply is not None:
            showIndent(outfile, level)
            outfile.write('got_reply = %d,\n' % (self.got_reply,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('subnet')
        if value is not None:
            already_processed.append('subnet')
            self.subnet = value
        value = attrs.get('sent')
        if value is not None:
            already_processed.append('sent')
            try:
                self.sent = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('got_reply')
        if value is not None:
            already_processed.append('got_reply')
            try:
                self.got_reply = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class pings


class tcp_traffic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, http_traffic=None, irc_traffic=None, smtp_traffic=None, ftp_traffic=None, scans=None, unknown_tcp_traffic=None, connection_attempts=None):
        if http_traffic is None:
            self.http_traffic = []
        else:
            self.http_traffic = http_traffic
        if irc_traffic is None:
            self.irc_traffic = []
        else:
            self.irc_traffic = irc_traffic
        if smtp_traffic is None:
            self.smtp_traffic = []
        else:
            self.smtp_traffic = smtp_traffic
        if ftp_traffic is None:
            self.ftp_traffic = []
        else:
            self.ftp_traffic = ftp_traffic
        if scans is None:
            self.scans = []
        else:
            self.scans = scans
        if unknown_tcp_traffic is None:
            self.unknown_tcp_traffic = []
        else:
            self.unknown_tcp_traffic = unknown_tcp_traffic
        if connection_attempts is None:
            self.connection_attempts = []
        else:
            self.connection_attempts = connection_attempts
    def factory(*args_, **kwargs_):
        if tcp_traffic.subclass:
            return tcp_traffic.subclass(*args_, **kwargs_)
        else:
            return tcp_traffic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_http_traffic(self): return self.http_traffic
    def set_http_traffic(self, http_traffic): self.http_traffic = http_traffic
    def add_http_traffic(self, value): self.http_traffic.append(value)
    def insert_http_traffic(self, index, value): self.http_traffic[index] = value
    def get_irc_traffic(self): return self.irc_traffic
    def set_irc_traffic(self, irc_traffic): self.irc_traffic = irc_traffic
    def add_irc_traffic(self, value): self.irc_traffic.append(value)
    def insert_irc_traffic(self, index, value): self.irc_traffic[index] = value
    def get_smtp_traffic(self): return self.smtp_traffic
    def set_smtp_traffic(self, smtp_traffic): self.smtp_traffic = smtp_traffic
    def add_smtp_traffic(self, value): self.smtp_traffic.append(value)
    def insert_smtp_traffic(self, index, value): self.smtp_traffic[index] = value
    def get_ftp_traffic(self): return self.ftp_traffic
    def set_ftp_traffic(self, ftp_traffic): self.ftp_traffic = ftp_traffic
    def add_ftp_traffic(self, value): self.ftp_traffic.append(value)
    def insert_ftp_traffic(self, index, value): self.ftp_traffic[index] = value
    def get_scans(self): return self.scans
    def set_scans(self, scans): self.scans = scans
    def add_scans(self, value): self.scans.append(value)
    def insert_scans(self, index, value): self.scans[index] = value
    def get_unknown_tcp_traffic(self): return self.unknown_tcp_traffic
    def set_unknown_tcp_traffic(self, unknown_tcp_traffic): self.unknown_tcp_traffic = unknown_tcp_traffic
    def add_unknown_tcp_traffic(self, value): self.unknown_tcp_traffic.append(value)
    def insert_unknown_tcp_traffic(self, index, value): self.unknown_tcp_traffic[index] = value
    def get_connection_attempts(self): return self.connection_attempts
    def set_connection_attempts(self, connection_attempts): self.connection_attempts = connection_attempts
    def add_connection_attempts(self, value): self.connection_attempts.append(value)
    def insert_connection_attempts(self, index, value): self.connection_attempts[index] = value
    def export(self, outfile, level, namespace_='', name_='tcp_traffic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='tcp_traffic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='tcp_traffic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tcp_traffic'):
        for http_traffic_ in self.http_traffic:
            http_traffic_.export(outfile, level, namespace_, name_='http_traffic')
        for irc_traffic_ in self.irc_traffic:
            irc_traffic_.export(outfile, level, namespace_, name_='irc_traffic')
        for smtp_traffic_ in self.smtp_traffic:
            smtp_traffic_.export(outfile, level, namespace_, name_='smtp_traffic')
        for ftp_traffic_ in self.ftp_traffic:
            ftp_traffic_.export(outfile, level, namespace_, name_='ftp_traffic')
        for scans_ in self.scans:
            scans_.export(outfile, level, namespace_, name_='scans')
        for unknown_tcp_traffic_ in self.unknown_tcp_traffic:
            unknown_tcp_traffic_.export(outfile, level, namespace_, name_='unknown_tcp_traffic')
        for connection_attempts_ in self.connection_attempts:
            connection_attempts_.export(outfile, level, namespace_, name_='connection_attempts')
    def hasContent_(self):
        if (
            self.http_traffic or
            self.irc_traffic or
            self.smtp_traffic or
            self.ftp_traffic or
            self.scans or
            self.unknown_tcp_traffic or
            self.connection_attempts
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='tcp_traffic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('http_traffic=[\n')
        level += 1
        for http_traffic_ in self.http_traffic:
            showIndent(outfile, level)
            outfile.write('model_.http_traffic(\n')
            http_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('irc_traffic=[\n')
        level += 1
        for irc_traffic_ in self.irc_traffic:
            showIndent(outfile, level)
            outfile.write('model_.irc_traffic(\n')
            irc_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('smtp_traffic=[\n')
        level += 1
        for smtp_traffic_ in self.smtp_traffic:
            showIndent(outfile, level)
            outfile.write('model_.smtp_traffic(\n')
            smtp_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ftp_traffic=[\n')
        level += 1
        for ftp_traffic_ in self.ftp_traffic:
            showIndent(outfile, level)
            outfile.write('model_.ftp_traffic(\n')
            ftp_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('scans=[\n')
        level += 1
        for scans_ in self.scans:
            showIndent(outfile, level)
            outfile.write('model_.scans(\n')
            scans_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('unknown_tcp_traffic=[\n')
        level += 1
        for unknown_tcp_traffic_ in self.unknown_tcp_traffic:
            showIndent(outfile, level)
            outfile.write('model_.unknown_tcp_traffic(\n')
            unknown_tcp_traffic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connection_attempts=[\n')
        level += 1
        for connection_attempts_ in self.connection_attempts:
            showIndent(outfile, level)
            outfile.write('model_.connection_attempts(\n')
            connection_attempts_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'http_traffic': 
            obj_ = http_traffic.factory()
            obj_.build(child_)
            self.http_traffic.append(obj_)
        elif nodeName_ == 'irc_traffic': 
            obj_ = irc_traffic.factory()
            obj_.build(child_)
            self.irc_traffic.append(obj_)
        elif nodeName_ == 'smtp_traffic': 
            obj_ = smtp_traffic.factory()
            obj_.build(child_)
            self.smtp_traffic.append(obj_)
        elif nodeName_ == 'ftp_traffic': 
            obj_ = ftp_traffic.factory()
            obj_.build(child_)
            self.ftp_traffic.append(obj_)
        elif nodeName_ == 'scans': 
            obj_ = scans.factory()
            obj_.build(child_)
            self.scans.append(obj_)
        elif nodeName_ == 'unknown_tcp_traffic': 
            obj_ = unknown_tcp_traffic.factory()
            obj_.build(child_)
            self.unknown_tcp_traffic.append(obj_)
        elif nodeName_ == 'connection_attempts': 
            obj_ = connection_attempts.factory()
            obj_.build(child_)
            self.connection_attempts.append(obj_)
# end class tcp_traffic


class http_traffic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, http_conversation=None):
        if http_conversation is None:
            self.http_conversation = []
        else:
            self.http_conversation = http_conversation
    def factory(*args_, **kwargs_):
        if http_traffic.subclass:
            return http_traffic.subclass(*args_, **kwargs_)
        else:
            return http_traffic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_http_conversation(self): return self.http_conversation
    def set_http_conversation(self, http_conversation): self.http_conversation = http_conversation
    def add_http_conversation(self, value): self.http_conversation.append(value)
    def insert_http_conversation(self, index, value): self.http_conversation[index] = value
    def export(self, outfile, level, namespace_='', name_='http_traffic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='http_traffic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='http_traffic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='http_traffic'):
        for http_conversation_ in self.http_conversation:
            http_conversation_.export(outfile, level, namespace_, name_='http_conversation')
    def hasContent_(self):
        if (
            self.http_conversation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='http_traffic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('http_conversation=[\n')
        level += 1
        for http_conversation_ in self.http_conversation:
            showIndent(outfile, level)
            outfile.write('model_.http_conversation(\n')
            http_conversation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'http_conversation': 
            obj_ = http_conversation.factory()
            obj_.build(child_)
            self.http_conversation.append(obj_)
# end class http_traffic


class http_conversation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src_port=None, description=None, hostname=None, src_ip=None, dest_ip=None, dest_port=None, http_request=None):
        self.src_port = _cast(int, src_port)
        self.description = _cast(None, description)
        self.hostname = _cast(None, hostname)
        self.src_ip = _cast(None, src_ip)
        self.dest_ip = _cast(None, dest_ip)
        self.dest_port = _cast(int, dest_port)
        if http_request is None:
            self.http_request = []
        else:
            self.http_request = http_request
    def factory(*args_, **kwargs_):
        if http_conversation.subclass:
            return http_conversation.subclass(*args_, **kwargs_)
        else:
            return http_conversation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_http_request(self): return self.http_request
    def set_http_request(self, http_request): self.http_request = http_request
    def add_http_request(self, value): self.http_request.append(value)
    def insert_http_request(self, index, value): self.http_request[index] = value
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_hostname(self): return self.hostname
    def set_hostname(self, hostname): self.hostname = hostname
    def get_src_ip(self): return self.src_ip
    def set_src_ip(self, src_ip): self.src_ip = src_ip
    def get_dest_ip(self): return self.dest_ip
    def set_dest_ip(self, dest_ip): self.dest_ip = dest_ip
    def get_dest_port(self): return self.dest_port
    def set_dest_port(self, dest_port): self.dest_port = dest_port
    def export(self, outfile, level, namespace_='', name_='http_conversation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='http_conversation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='http_conversation'):
        outfile.write(' src_port="%s"' % self.gds_format_integer(self.src_port, input_name='src_port'))
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' hostname=%s' % (self.gds_format_string(quote_attrib(self.hostname).encode(ExternalEncoding), input_name='hostname'), ))
        outfile.write(' src_ip=%s' % (quote_attrib(self.src_ip), ))
        outfile.write(' dest_ip=%s' % (quote_attrib(self.dest_ip), ))
        outfile.write(' dest_port="%s"' % self.gds_format_integer(self.dest_port, input_name='dest_port'))
    def exportChildren(self, outfile, level, namespace_='', name_='http_conversation'):
        for http_request_ in self.http_request:
            http_request_.export(outfile, level, namespace_, name_='http_request')
    def hasContent_(self):
        if (
            self.http_request
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='http_conversation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port = %d,\n' % (self.src_port,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.hostname is not None:
            showIndent(outfile, level)
            outfile.write('hostname = "%s",\n' % (self.hostname,))
        if self.src_ip is not None:
            showIndent(outfile, level)
            outfile.write('src_ip = %s,\n' % (self.src_ip,))
        if self.dest_ip is not None:
            showIndent(outfile, level)
            outfile.write('dest_ip = %s,\n' % (self.dest_ip,))
        if self.dest_port is not None:
            showIndent(outfile, level)
            outfile.write('dest_port = %d,\n' % (self.dest_port,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('http_request=[\n')
        level += 1
        for http_request_ in self.http_request:
            showIndent(outfile, level)
            outfile.write('model_.http_request(\n')
            http_request_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src_port')
        if value is not None:
            already_processed.append('src_port')
            try:
                self.src_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('hostname')
        if value is not None:
            already_processed.append('hostname')
            self.hostname = value
        value = attrs.get('src_ip')
        if value is not None:
            already_processed.append('src_ip')
            self.src_ip = value
        value = attrs.get('dest_ip')
        if value is not None:
            already_processed.append('dest_ip')
            self.dest_ip = value
        value = attrs.get('dest_port')
        if value is not None:
            already_processed.append('dest_port')
            try:
                self.dest_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'http_request': 
            obj_ = http_request.factory()
            obj_.build(child_)
            self.http_request.append(obj_)
# end class http_conversation


class http_request(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, request=None, response=None, valueOf_=None):
        self.request = _cast(None, request)
        self.response = _cast(None, response)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if http_request.subclass:
            return http_request.subclass(*args_, **kwargs_)
        else:
            return http_request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_request(self): return self.request
    def set_request(self, request): self.request = request
    def get_response(self): return self.response
    def set_response(self, response): self.response = response
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='http_request', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='http_request')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='http_request'):
        outfile.write(' request=%s' % (self.gds_format_string(quote_attrib(self.request).encode(ExternalEncoding), input_name='request'), ))
        outfile.write(' response=%s' % (self.gds_format_string(quote_attrib(self.response).encode(ExternalEncoding), input_name='response'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='http_request'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='http_request'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.request is not None:
            showIndent(outfile, level)
            outfile.write('request = "%s",\n' % (self.request,))
        if self.response is not None:
            showIndent(outfile, level)
            outfile.write('response = "%s",\n' % (self.response,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('request')
        if value is not None:
            already_processed.append('request')
            self.request = value
        value = attrs.get('response')
        if value is not None:
            already_processed.append('response')
            self.response = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class http_request


class irc_traffic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, irc_conversation=None):
        self.description = _cast(None, description)
        if irc_conversation is None:
            self.irc_conversation = []
        else:
            self.irc_conversation = irc_conversation
    def factory(*args_, **kwargs_):
        if irc_traffic.subclass:
            return irc_traffic.subclass(*args_, **kwargs_)
        else:
            return irc_traffic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_irc_conversation(self): return self.irc_conversation
    def set_irc_conversation(self, irc_conversation): self.irc_conversation = irc_conversation
    def add_irc_conversation(self, value): self.irc_conversation.append(value)
    def insert_irc_conversation(self, index, value): self.irc_conversation[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='irc_traffic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='irc_traffic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='irc_traffic'):
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
    def exportChildren(self, outfile, level, namespace_='', name_='irc_traffic'):
        for irc_conversation_ in self.irc_conversation:
            irc_conversation_.export(outfile, level, namespace_, name_='irc_conversation')
    def hasContent_(self):
        if (
            self.irc_conversation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='irc_traffic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('irc_conversation=[\n')
        level += 1
        for irc_conversation_ in self.irc_conversation:
            showIndent(outfile, level)
            outfile.write('model_.irc_conversation(\n')
            irc_conversation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'irc_conversation': 
            obj_ = irc_conversation.factory()
            obj_.build(child_)
            self.irc_conversation.append(obj_)
# end class irc_traffic


class irc_conversation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src_port=None, src_ip=None, nick=None, user=None, dest_ip=None, server_pass=None, dest_port=None, channel=None, privmsg_to_channel=None, privmsg_to_user=None, channel_topic=None):
        self.src_port = _cast(int, src_port)
        self.src_ip = _cast(None, src_ip)
        self.nick = _cast(None, nick)
        self.user = _cast(None, user)
        self.dest_ip = _cast(None, dest_ip)
        self.server_pass = _cast(None, server_pass)
        self.dest_port = _cast(int, dest_port)
        if channel is None:
            self.channel = []
        else:
            self.channel = channel
        if privmsg_to_channel is None:
            self.privmsg_to_channel = []
        else:
            self.privmsg_to_channel = privmsg_to_channel
        if privmsg_to_user is None:
            self.privmsg_to_user = []
        else:
            self.privmsg_to_user = privmsg_to_user
        if channel_topic is None:
            self.channel_topic = []
        else:
            self.channel_topic = channel_topic
    def factory(*args_, **kwargs_):
        if irc_conversation.subclass:
            return irc_conversation.subclass(*args_, **kwargs_)
        else:
            return irc_conversation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_channel(self): return self.channel
    def set_channel(self, channel): self.channel = channel
    def add_channel(self, value): self.channel.append(value)
    def insert_channel(self, index, value): self.channel[index] = value
    def get_privmsg_to_channel(self): return self.privmsg_to_channel
    def set_privmsg_to_channel(self, privmsg_to_channel): self.privmsg_to_channel = privmsg_to_channel
    def add_privmsg_to_channel(self, value): self.privmsg_to_channel.append(value)
    def insert_privmsg_to_channel(self, index, value): self.privmsg_to_channel[index] = value
    def get_privmsg_to_user(self): return self.privmsg_to_user
    def set_privmsg_to_user(self, privmsg_to_user): self.privmsg_to_user = privmsg_to_user
    def add_privmsg_to_user(self, value): self.privmsg_to_user.append(value)
    def insert_privmsg_to_user(self, index, value): self.privmsg_to_user[index] = value
    def get_channel_topic(self): return self.channel_topic
    def set_channel_topic(self, channel_topic): self.channel_topic = channel_topic
    def add_channel_topic(self, value): self.channel_topic.append(value)
    def insert_channel_topic(self, index, value): self.channel_topic[index] = value
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_src_ip(self): return self.src_ip
    def set_src_ip(self, src_ip): self.src_ip = src_ip
    def get_nick(self): return self.nick
    def set_nick(self, nick): self.nick = nick
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def get_dest_ip(self): return self.dest_ip
    def set_dest_ip(self, dest_ip): self.dest_ip = dest_ip
    def get_server_pass(self): return self.server_pass
    def set_server_pass(self, server_pass): self.server_pass = server_pass
    def get_dest_port(self): return self.dest_port
    def set_dest_port(self, dest_port): self.dest_port = dest_port
    def export(self, outfile, level, namespace_='', name_='irc_conversation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='irc_conversation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='irc_conversation'):
        outfile.write(' src_port="%s"' % self.gds_format_integer(self.src_port, input_name='src_port'))
        outfile.write(' src_ip=%s' % (quote_attrib(self.src_ip), ))
        outfile.write(' nick=%s' % (self.gds_format_string(quote_attrib(self.nick).encode(ExternalEncoding), input_name='nick'), ))
        outfile.write(' user=%s' % (self.gds_format_string(quote_attrib(self.user).encode(ExternalEncoding), input_name='user'), ))
        outfile.write(' dest_ip=%s' % (quote_attrib(self.dest_ip), ))
        outfile.write(' server_pass=%s' % (self.gds_format_string(quote_attrib(self.server_pass).encode(ExternalEncoding), input_name='server_pass'), ))
        outfile.write(' dest_port="%s"' % self.gds_format_integer(self.dest_port, input_name='dest_port'))
    def exportChildren(self, outfile, level, namespace_='', name_='irc_conversation'):
        for channel_ in self.channel:
            channel_.export(outfile, level, namespace_, name_='channel')
        for privmsg_to_channel_ in self.privmsg_to_channel:
            privmsg_to_channel_.export(outfile, level, namespace_, name_='privmsg_to_channel')
        for privmsg_to_user_ in self.privmsg_to_user:
            privmsg_to_user_.export(outfile, level, namespace_, name_='privmsg_to_user')
        for channel_topic_ in self.channel_topic:
            channel_topic_.export(outfile, level, namespace_, name_='channel_topic')
    def hasContent_(self):
        if (
            self.channel or
            self.privmsg_to_channel or
            self.privmsg_to_user or
            self.channel_topic
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='irc_conversation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port = %d,\n' % (self.src_port,))
        if self.src_ip is not None:
            showIndent(outfile, level)
            outfile.write('src_ip = %s,\n' % (self.src_ip,))
        if self.nick is not None:
            showIndent(outfile, level)
            outfile.write('nick = "%s",\n' % (self.nick,))
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user = "%s",\n' % (self.user,))
        if self.dest_ip is not None:
            showIndent(outfile, level)
            outfile.write('dest_ip = %s,\n' % (self.dest_ip,))
        if self.server_pass is not None:
            showIndent(outfile, level)
            outfile.write('server_pass = "%s",\n' % (self.server_pass,))
        if self.dest_port is not None:
            showIndent(outfile, level)
            outfile.write('dest_port = %d,\n' % (self.dest_port,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('channel=[\n')
        level += 1
        for channel_ in self.channel:
            showIndent(outfile, level)
            outfile.write('model_.channel(\n')
            channel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('privmsg_to_channel=[\n')
        level += 1
        for privmsg_to_channel_ in self.privmsg_to_channel:
            showIndent(outfile, level)
            outfile.write('model_.privmsg_to_channel(\n')
            privmsg_to_channel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('privmsg_to_user=[\n')
        level += 1
        for privmsg_to_user_ in self.privmsg_to_user:
            showIndent(outfile, level)
            outfile.write('model_.privmsg_to_user(\n')
            privmsg_to_user_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('channel_topic=[\n')
        level += 1
        for channel_topic_ in self.channel_topic:
            showIndent(outfile, level)
            outfile.write('model_.channel_topic(\n')
            channel_topic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src_port')
        if value is not None:
            already_processed.append('src_port')
            try:
                self.src_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('src_ip')
        if value is not None:
            already_processed.append('src_ip')
            self.src_ip = value
        value = attrs.get('nick')
        if value is not None:
            already_processed.append('nick')
            self.nick = value
        value = attrs.get('user')
        if value is not None:
            already_processed.append('user')
            self.user = value
        value = attrs.get('dest_ip')
        if value is not None:
            already_processed.append('dest_ip')
            self.dest_ip = value
        value = attrs.get('server_pass')
        if value is not None:
            already_processed.append('server_pass')
            self.server_pass = value
        value = attrs.get('dest_port')
        if value is not None:
            already_processed.append('dest_port')
            try:
                self.dest_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'channel': 
            obj_ = channel.factory()
            obj_.build(child_)
            self.channel.append(obj_)
        elif nodeName_ == 'privmsg_to_channel': 
            obj_ = privmsg_to_channel.factory()
            obj_.build(child_)
            self.privmsg_to_channel.append(obj_)
        elif nodeName_ == 'privmsg_to_user': 
            obj_ = privmsg_to_user.factory()
            obj_.build(child_)
            self.privmsg_to_user.append(obj_)
        elif nodeName_ == 'channel_topic': 
            obj_ = channel_topic.factory()
            obj_.build(child_)
            self.channel_topic.append(obj_)
# end class irc_conversation


class channel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, joined_channel=None, password=None, valueOf_=None):
        self.joined_channel = _cast(None, joined_channel)
        self.password = _cast(None, password)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if channel.subclass:
            return channel.subclass(*args_, **kwargs_)
        else:
            return channel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_joined_channel(self): return self.joined_channel
    def set_joined_channel(self, joined_channel): self.joined_channel = joined_channel
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='channel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='channel')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='channel'):
        outfile.write(' joined_channel=%s' % (self.gds_format_string(quote_attrib(self.joined_channel).encode(ExternalEncoding), input_name='joined_channel'), ))
        outfile.write(' password=%s' % (self.gds_format_string(quote_attrib(self.password).encode(ExternalEncoding), input_name='password'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='channel'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='channel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.joined_channel is not None:
            showIndent(outfile, level)
            outfile.write('joined_channel = "%s",\n' % (self.joined_channel,))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password = "%s",\n' % (self.password,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('joined_channel')
        if value is not None:
            already_processed.append('joined_channel')
            self.joined_channel = value
        value = attrs.get('password')
        if value is not None:
            already_processed.append('password')
            self.password = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class channel


class privmsg_to_channel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, priv_msg=None, channel=None, valueOf_=None):
        self.priv_msg = _cast(None, priv_msg)
        self.channel = _cast(None, channel)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if privmsg_to_channel.subclass:
            return privmsg_to_channel.subclass(*args_, **kwargs_)
        else:
            return privmsg_to_channel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_priv_msg(self): return self.priv_msg
    def set_priv_msg(self, priv_msg): self.priv_msg = priv_msg
    def get_channel(self): return self.channel
    def set_channel(self, channel): self.channel = channel
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='privmsg_to_channel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='privmsg_to_channel')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='privmsg_to_channel'):
        outfile.write(' priv_msg=%s' % (self.gds_format_string(quote_attrib(self.priv_msg).encode(ExternalEncoding), input_name='priv_msg'), ))
        outfile.write(' channel=%s' % (self.gds_format_string(quote_attrib(self.channel).encode(ExternalEncoding), input_name='channel'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='privmsg_to_channel'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='privmsg_to_channel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.priv_msg is not None:
            showIndent(outfile, level)
            outfile.write('priv_msg = "%s",\n' % (self.priv_msg,))
        if self.channel is not None:
            showIndent(outfile, level)
            outfile.write('channel = "%s",\n' % (self.channel,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('priv_msg')
        if value is not None:
            already_processed.append('priv_msg')
            self.priv_msg = value
        value = attrs.get('channel')
        if value is not None:
            already_processed.append('channel')
            self.channel = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class privmsg_to_channel


class privmsg_to_user(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, priv_msg=None, user=None, valueOf_=None):
        self.priv_msg = _cast(None, priv_msg)
        self.user = _cast(None, user)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if privmsg_to_user.subclass:
            return privmsg_to_user.subclass(*args_, **kwargs_)
        else:
            return privmsg_to_user(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_priv_msg(self): return self.priv_msg
    def set_priv_msg(self, priv_msg): self.priv_msg = priv_msg
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='privmsg_to_user', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='privmsg_to_user')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='privmsg_to_user'):
        outfile.write(' priv_msg=%s' % (self.gds_format_string(quote_attrib(self.priv_msg).encode(ExternalEncoding), input_name='priv_msg'), ))
        outfile.write(' user=%s' % (self.gds_format_string(quote_attrib(self.user).encode(ExternalEncoding), input_name='user'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='privmsg_to_user'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='privmsg_to_user'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.priv_msg is not None:
            showIndent(outfile, level)
            outfile.write('priv_msg = "%s",\n' % (self.priv_msg,))
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user = "%s",\n' % (self.user,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('priv_msg')
        if value is not None:
            already_processed.append('priv_msg')
            self.priv_msg = value
        value = attrs.get('user')
        if value is not None:
            already_processed.append('user')
            self.user = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class privmsg_to_user


class channel_topic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, topic=None, channel=None, valueOf_=None):
        self.topic = _cast(None, topic)
        self.channel = _cast(None, channel)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if channel_topic.subclass:
            return channel_topic.subclass(*args_, **kwargs_)
        else:
            return channel_topic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topic(self): return self.topic
    def set_topic(self, topic): self.topic = topic
    def get_channel(self): return self.channel
    def set_channel(self, channel): self.channel = channel
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='channel_topic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='channel_topic')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='channel_topic'):
        outfile.write(' topic=%s' % (self.gds_format_string(quote_attrib(self.topic).encode(ExternalEncoding), input_name='topic'), ))
        outfile.write(' channel=%s' % (self.gds_format_string(quote_attrib(self.channel).encode(ExternalEncoding), input_name='channel'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='channel_topic'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='channel_topic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.topic is not None:
            showIndent(outfile, level)
            outfile.write('topic = "%s",\n' % (self.topic,))
        if self.channel is not None:
            showIndent(outfile, level)
            outfile.write('channel = "%s",\n' % (self.channel,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('topic')
        if value is not None:
            already_processed.append('topic')
            self.topic = value
        value = attrs.get('channel')
        if value is not None:
            already_processed.append('channel')
            self.channel = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class channel_topic


class smtp_traffic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, smtp_conversation=None):
        if smtp_conversation is None:
            self.smtp_conversation = []
        else:
            self.smtp_conversation = smtp_conversation
    def factory(*args_, **kwargs_):
        if smtp_traffic.subclass:
            return smtp_traffic.subclass(*args_, **kwargs_)
        else:
            return smtp_traffic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_smtp_conversation(self): return self.smtp_conversation
    def set_smtp_conversation(self, smtp_conversation): self.smtp_conversation = smtp_conversation
    def add_smtp_conversation(self, value): self.smtp_conversation.append(value)
    def insert_smtp_conversation(self, index, value): self.smtp_conversation[index] = value
    def export(self, outfile, level, namespace_='', name_='smtp_traffic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='smtp_traffic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='smtp_traffic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='smtp_traffic'):
        for smtp_conversation_ in self.smtp_conversation:
            smtp_conversation_.export(outfile, level, namespace_, name_='smtp_conversation')
    def hasContent_(self):
        if (
            self.smtp_conversation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='smtp_traffic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('smtp_conversation=[\n')
        level += 1
        for smtp_conversation_ in self.smtp_conversation:
            showIndent(outfile, level)
            outfile.write('model_.smtp_conversation(\n')
            smtp_conversation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'smtp_conversation': 
            obj_ = smtp_conversation.factory()
            obj_.build(child_)
            self.smtp_conversation.append(obj_)
# end class smtp_traffic


class smtp_conversation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src_ip=None, sender=None, src_port=None, description=None, subject=None, content=None, server_reply=None, dest_ip=None, recipient=None, dest_port=None, attached_files=None):
        self.src_ip = _cast(None, src_ip)
        self.sender = _cast(None, sender)
        self.src_port = _cast(int, src_port)
        self.description = _cast(None, description)
        self.subject = _cast(None, subject)
        self.content = _cast(None, content)
        self.server_reply = _cast(None, server_reply)
        self.dest_ip = _cast(None, dest_ip)
        self.recipient = _cast(None, recipient)
        self.dest_port = _cast(int, dest_port)
        if attached_files is None:
            self.attached_files = []
        else:
            self.attached_files = attached_files
    def factory(*args_, **kwargs_):
        if smtp_conversation.subclass:
            return smtp_conversation.subclass(*args_, **kwargs_)
        else:
            return smtp_conversation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attached_files(self): return self.attached_files
    def set_attached_files(self, attached_files): self.attached_files = attached_files
    def add_attached_files(self, value): self.attached_files.append(value)
    def insert_attached_files(self, index, value): self.attached_files[index] = value
    def get_src_ip(self): return self.src_ip
    def set_src_ip(self, src_ip): self.src_ip = src_ip
    def get_sender(self): return self.sender
    def set_sender(self, sender): self.sender = sender
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_server_reply(self): return self.server_reply
    def set_server_reply(self, server_reply): self.server_reply = server_reply
    def get_dest_ip(self): return self.dest_ip
    def set_dest_ip(self, dest_ip): self.dest_ip = dest_ip
    def get_recipient(self): return self.recipient
    def set_recipient(self, recipient): self.recipient = recipient
    def get_dest_port(self): return self.dest_port
    def set_dest_port(self, dest_port): self.dest_port = dest_port
    def export(self, outfile, level, namespace_='', name_='smtp_conversation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='smtp_conversation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='smtp_conversation'):
        outfile.write(' src_ip=%s' % (quote_attrib(self.src_ip), ))
        outfile.write(' sender=%s' % (self.gds_format_string(quote_attrib(self.sender).encode(ExternalEncoding), input_name='sender'), ))
        outfile.write(' src_port="%s"' % self.gds_format_integer(self.src_port, input_name='src_port'))
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' subject=%s' % (self.gds_format_string(quote_attrib(self.subject).encode(ExternalEncoding), input_name='subject'), ))
        outfile.write(' content=%s' % (self.gds_format_string(quote_attrib(self.content).encode(ExternalEncoding), input_name='content'), ))
        outfile.write(' server_reply=%s' % (self.gds_format_string(quote_attrib(self.server_reply).encode(ExternalEncoding), input_name='server_reply'), ))
        outfile.write(' dest_ip=%s' % (quote_attrib(self.dest_ip), ))
        outfile.write(' recipient=%s' % (self.gds_format_string(quote_attrib(self.recipient).encode(ExternalEncoding), input_name='recipient'), ))
        outfile.write(' dest_port="%s"' % self.gds_format_integer(self.dest_port, input_name='dest_port'))
    def exportChildren(self, outfile, level, namespace_='', name_='smtp_conversation'):
        for attached_files_ in self.attached_files:
            attached_files_.export(outfile, level, namespace_, name_='attached_files')
    def hasContent_(self):
        if (
            self.attached_files
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='smtp_conversation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src_ip is not None:
            showIndent(outfile, level)
            outfile.write('src_ip = %s,\n' % (self.src_ip,))
        if self.sender is not None:
            showIndent(outfile, level)
            outfile.write('sender = "%s",\n' % (self.sender,))
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port = %d,\n' % (self.src_port,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.subject is not None:
            showIndent(outfile, level)
            outfile.write('subject = "%s",\n' % (self.subject,))
        if self.content is not None:
            showIndent(outfile, level)
            outfile.write('content = "%s",\n' % (self.content,))
        if self.server_reply is not None:
            showIndent(outfile, level)
            outfile.write('server_reply = "%s",\n' % (self.server_reply,))
        if self.dest_ip is not None:
            showIndent(outfile, level)
            outfile.write('dest_ip = %s,\n' % (self.dest_ip,))
        if self.recipient is not None:
            showIndent(outfile, level)
            outfile.write('recipient = "%s",\n' % (self.recipient,))
        if self.dest_port is not None:
            showIndent(outfile, level)
            outfile.write('dest_port = %d,\n' % (self.dest_port,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attached_files=[\n')
        level += 1
        for attached_files_ in self.attached_files:
            showIndent(outfile, level)
            outfile.write('model_.attached_files(\n')
            attached_files_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src_ip')
        if value is not None:
            already_processed.append('src_ip')
            self.src_ip = value
        value = attrs.get('sender')
        if value is not None:
            already_processed.append('sender')
            self.sender = value
        value = attrs.get('src_port')
        if value is not None:
            already_processed.append('src_port')
            try:
                self.src_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('subject')
        if value is not None:
            already_processed.append('subject')
            self.subject = value
        value = attrs.get('content')
        if value is not None:
            already_processed.append('content')
            self.content = value
        value = attrs.get('server_reply')
        if value is not None:
            already_processed.append('server_reply')
            self.server_reply = value
        value = attrs.get('dest_ip')
        if value is not None:
            already_processed.append('dest_ip')
            self.dest_ip = value
        value = attrs.get('recipient')
        if value is not None:
            already_processed.append('recipient')
            self.recipient = value
        value = attrs.get('dest_port')
        if value is not None:
            already_processed.append('dest_port')
            try:
                self.dest_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'attached_files': 
            obj_ = attached_files.factory()
            obj_.build(child_)
            self.attached_files.append(obj_)
# end class smtp_conversation


class attached_files(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content_type=None, file=None, valueOf_=None):
        self.content_type = _cast(None, content_type)
        self.file = _cast(None, file)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if attached_files.subclass:
            return attached_files.subclass(*args_, **kwargs_)
        else:
            return attached_files(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='attached_files', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='attached_files')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='attached_files'):
        outfile.write(' content_type=%s' % (self.gds_format_string(quote_attrib(self.content_type).encode(ExternalEncoding), input_name='content_type'), ))
        outfile.write(' file=%s' % (self.gds_format_string(quote_attrib(self.file).encode(ExternalEncoding), input_name='file'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='attached_files'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='attached_files'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.content_type is not None:
            showIndent(outfile, level)
            outfile.write('content_type = "%s",\n' % (self.content_type,))
        if self.file is not None:
            showIndent(outfile, level)
            outfile.write('file = "%s",\n' % (self.file,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('content_type')
        if value is not None:
            already_processed.append('content_type')
            self.content_type = value
        value = attrs.get('file')
        if value is not None:
            already_processed.append('file')
            self.file = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class attached_files


class ftp_traffic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ftp_conversation=None):
        if ftp_conversation is None:
            self.ftp_conversation = []
        else:
            self.ftp_conversation = ftp_conversation
    def factory(*args_, **kwargs_):
        if ftp_traffic.subclass:
            return ftp_traffic.subclass(*args_, **kwargs_)
        else:
            return ftp_traffic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ftp_conversation(self): return self.ftp_conversation
    def set_ftp_conversation(self, ftp_conversation): self.ftp_conversation = ftp_conversation
    def add_ftp_conversation(self, value): self.ftp_conversation.append(value)
    def insert_ftp_conversation(self, index, value): self.ftp_conversation[index] = value
    def export(self, outfile, level, namespace_='', name_='ftp_traffic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ftp_traffic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ftp_traffic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ftp_traffic'):
        for ftp_conversation_ in self.ftp_conversation:
            ftp_conversation_.export(outfile, level, namespace_, name_='ftp_conversation')
    def hasContent_(self):
        if (
            self.ftp_conversation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ftp_traffic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ftp_conversation=[\n')
        level += 1
        for ftp_conversation_ in self.ftp_conversation:
            showIndent(outfile, level)
            outfile.write('model_.ftp_conversation(\n')
            ftp_conversation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'ftp_conversation': 
            obj_ = ftp_conversation.factory()
            obj_.build(child_)
            self.ftp_conversation.append(obj_)
# end class ftp_traffic


class ftp_conversation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src_port=None, src_ip=None, user=None, password=None, dest_ip=None, dest_port=None, valueOf_=None):
        self.src_port = _cast(int, src_port)
        self.src_ip = _cast(None, src_ip)
        self.user = _cast(None, user)
        self.password = _cast(None, password)
        self.dest_ip = _cast(None, dest_ip)
        self.dest_port = _cast(int, dest_port)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ftp_conversation.subclass:
            return ftp_conversation.subclass(*args_, **kwargs_)
        else:
            return ftp_conversation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_src_ip(self): return self.src_ip
    def set_src_ip(self, src_ip): self.src_ip = src_ip
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_dest_ip(self): return self.dest_ip
    def set_dest_ip(self, dest_ip): self.dest_ip = dest_ip
    def get_dest_port(self): return self.dest_port
    def set_dest_port(self, dest_port): self.dest_port = dest_port
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='ftp_conversation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ftp_conversation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ftp_conversation'):
        outfile.write(' src_port="%s"' % self.gds_format_integer(self.src_port, input_name='src_port'))
        outfile.write(' src_ip=%s' % (quote_attrib(self.src_ip), ))
        outfile.write(' user=%s' % (self.gds_format_string(quote_attrib(self.user).encode(ExternalEncoding), input_name='user'), ))
        outfile.write(' password=%s' % (self.gds_format_string(quote_attrib(self.password).encode(ExternalEncoding), input_name='password'), ))
        outfile.write(' dest_ip=%s' % (quote_attrib(self.dest_ip), ))
        outfile.write(' dest_port="%s"' % self.gds_format_integer(self.dest_port, input_name='dest_port'))
    def exportChildren(self, outfile, level, namespace_='', name_='ftp_conversation'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ftp_conversation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port = %d,\n' % (self.src_port,))
        if self.src_ip is not None:
            showIndent(outfile, level)
            outfile.write('src_ip = %s,\n' % (self.src_ip,))
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user = "%s",\n' % (self.user,))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password = "%s",\n' % (self.password,))
        if self.dest_ip is not None:
            showIndent(outfile, level)
            outfile.write('dest_ip = %s,\n' % (self.dest_ip,))
        if self.dest_port is not None:
            showIndent(outfile, level)
            outfile.write('dest_port = %d,\n' % (self.dest_port,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src_port')
        if value is not None:
            already_processed.append('src_port')
            try:
                self.src_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('src_ip')
        if value is not None:
            already_processed.append('src_ip')
            self.src_ip = value
        value = attrs.get('user')
        if value is not None:
            already_processed.append('user')
            self.user = value
        value = attrs.get('password')
        if value is not None:
            already_processed.append('password')
            self.password = value
        value = attrs.get('dest_ip')
        if value is not None:
            already_processed.append('dest_ip')
            self.dest_ip = value
        value = attrs.get('dest_port')
        if value is not None:
            already_processed.append('dest_port')
            try:
                self.dest_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class ftp_conversation


class scans(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, address_scan=None, port_scan=None):
        if address_scan is None:
            self.address_scan = []
        else:
            self.address_scan = address_scan
        if port_scan is None:
            self.port_scan = []
        else:
            self.port_scan = port_scan
    def factory(*args_, **kwargs_):
        if scans.subclass:
            return scans.subclass(*args_, **kwargs_)
        else:
            return scans(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address_scan(self): return self.address_scan
    def set_address_scan(self, address_scan): self.address_scan = address_scan
    def add_address_scan(self, value): self.address_scan.append(value)
    def insert_address_scan(self, index, value): self.address_scan[index] = value
    def get_port_scan(self): return self.port_scan
    def set_port_scan(self, port_scan): self.port_scan = port_scan
    def add_port_scan(self, value): self.port_scan.append(value)
    def insert_port_scan(self, index, value): self.port_scan[index] = value
    def export(self, outfile, level, namespace_='', name_='scans', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='scans')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='scans'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='scans'):
        for address_scan_ in self.address_scan:
            address_scan_.export(outfile, level, namespace_, name_='address_scan')
        for port_scan_ in self.port_scan:
            port_scan_.export(outfile, level, namespace_, name_='port_scan')
    def hasContent_(self):
        if (
            self.address_scan or
            self.port_scan
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='scans'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('address_scan=[\n')
        level += 1
        for address_scan_ in self.address_scan:
            showIndent(outfile, level)
            outfile.write('model_.address_scan(\n')
            address_scan_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('port_scan=[\n')
        level += 1
        for port_scan_ in self.port_scan:
            showIndent(outfile, level)
            outfile.write('model_.port_scan(\n')
            port_scan_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'address_scan': 
            obj_ = address_scan.factory()
            obj_.build(child_)
            self.address_scan.append(obj_)
        elif nodeName_ == 'port_scan': 
            obj_ = port_scan.factory()
            obj_.build(child_)
            self.port_scan.append(obj_)
# end class scans


class address_scan(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, subnet=None, description=None, a_count=None, remote_port=None, valueOf_=None):
        self.subnet = _cast(None, subnet)
        self.description = _cast(None, description)
        self.a_count = _cast(int, a_count)
        self.remote_port = _cast(int, remote_port)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if address_scan.subclass:
            return address_scan.subclass(*args_, **kwargs_)
        else:
            return address_scan(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subnet(self): return self.subnet
    def set_subnet(self, subnet): self.subnet = subnet
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_a_count(self): return self.a_count
    def set_a_count(self, a_count): self.a_count = a_count
    def get_remote_port(self): return self.remote_port
    def set_remote_port(self, remote_port): self.remote_port = remote_port
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='address_scan', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='address_scan')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='address_scan'):
        outfile.write(' subnet=%s' % (self.gds_format_string(quote_attrib(self.subnet).encode(ExternalEncoding), input_name='subnet'), ))
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' a_count="%s"' % self.gds_format_integer(self.a_count, input_name='a_count'))
        outfile.write(' remote_port="%s"' % self.gds_format_integer(self.remote_port, input_name='remote_port'))
    def exportChildren(self, outfile, level, namespace_='', name_='address_scan'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='address_scan'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.subnet is not None:
            showIndent(outfile, level)
            outfile.write('subnet = "%s",\n' % (self.subnet,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.a_count is not None:
            showIndent(outfile, level)
            outfile.write('a_count = %d,\n' % (self.a_count,))
        if self.remote_port is not None:
            showIndent(outfile, level)
            outfile.write('remote_port = %d,\n' % (self.remote_port,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('subnet')
        if value is not None:
            already_processed.append('subnet')
            self.subnet = value
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('a_count')
        if value is not None:
            already_processed.append('a_count')
            try:
                self.a_count = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('remote_port')
        if value is not None:
            already_processed.append('remote_port')
            try:
                self.remote_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class address_scan


class port_scan(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, p_count=None, description=None, remote_ip=None, valueOf_=None):
        self.p_count = _cast(int, p_count)
        self.description = _cast(None, description)
        self.remote_ip = _cast(None, remote_ip)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if port_scan.subclass:
            return port_scan.subclass(*args_, **kwargs_)
        else:
            return port_scan(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_p_count(self): return self.p_count
    def set_p_count(self, p_count): self.p_count = p_count
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_description(self, value):
        # Validate type description, a restriction on xs:string.
        pass
    def get_remote_ip(self): return self.remote_ip
    def set_remote_ip(self, remote_ip): self.remote_ip = remote_ip
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='port_scan', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='port_scan')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='port_scan'):
        outfile.write(' p_count="%s"' % self.gds_format_integer(self.p_count, input_name='p_count'))
        if self.description is not None:
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        outfile.write(' remote_ip=%s' % (quote_attrib(self.remote_ip), ))
    def exportChildren(self, outfile, level, namespace_='', name_='port_scan'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='port_scan'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.p_count is not None:
            showIndent(outfile, level)
            outfile.write('p_count = %d,\n' % (self.p_count,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.remote_ip is not None:
            showIndent(outfile, level)
            outfile.write('remote_ip = %s,\n' % (self.remote_ip,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('p_count')
        if value is not None:
            already_processed.append('p_count')
            try:
                self.p_count = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
            self.validate_description(self.description)    # validate type description
        value = attrs.get('remote_ip')
        if value is not None:
            already_processed.append('remote_ip')
            self.remote_ip = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class port_scan


class unknown_tcp_traffic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tcp_conversation=None):
        if tcp_conversation is None:
            self.tcp_conversation = []
        else:
            self.tcp_conversation = tcp_conversation
    def factory(*args_, **kwargs_):
        if unknown_tcp_traffic.subclass:
            return unknown_tcp_traffic.subclass(*args_, **kwargs_)
        else:
            return unknown_tcp_traffic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tcp_conversation(self): return self.tcp_conversation
    def set_tcp_conversation(self, tcp_conversation): self.tcp_conversation = tcp_conversation
    def add_tcp_conversation(self, value): self.tcp_conversation.append(value)
    def insert_tcp_conversation(self, index, value): self.tcp_conversation[index] = value
    def export(self, outfile, level, namespace_='', name_='unknown_tcp_traffic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='unknown_tcp_traffic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='unknown_tcp_traffic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='unknown_tcp_traffic'):
        for tcp_conversation_ in self.tcp_conversation:
            tcp_conversation_.export(outfile, level, namespace_, name_='tcp_conversation')
    def hasContent_(self):
        if (
            self.tcp_conversation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='unknown_tcp_traffic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tcp_conversation=[\n')
        level += 1
        for tcp_conversation_ in self.tcp_conversation:
            showIndent(outfile, level)
            outfile.write('model_.tcp_conversation(\n')
            tcp_conversation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'tcp_conversation': 
            obj_ = tcp_conversation.factory()
            obj_.build(child_)
            self.tcp_conversation.append(obj_)
# end class unknown_tcp_traffic


class tcp_conversation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, org_bytes_sent=None, src_port=None, src_ip=None, res_bytes_sent=None, state=None, dest_ip=None, dest_port=None, data=None):
        self.org_bytes_sent = _cast(int, org_bytes_sent)
        self.src_port = _cast(int, src_port)
        self.src_ip = _cast(None, src_ip)
        self.res_bytes_sent = _cast(int, res_bytes_sent)
        self.state = _cast(None, state)
        self.dest_ip = _cast(None, dest_ip)
        self.dest_port = _cast(int, dest_port)
        if data is None:
            self.data = []
        else:
            self.data = data
    def factory(*args_, **kwargs_):
        if tcp_conversation.subclass:
            return tcp_conversation.subclass(*args_, **kwargs_)
        else:
            return tcp_conversation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_org_bytes_sent(self): return self.org_bytes_sent
    def set_org_bytes_sent(self, org_bytes_sent): self.org_bytes_sent = org_bytes_sent
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_src_ip(self): return self.src_ip
    def set_src_ip(self, src_ip): self.src_ip = src_ip
    def get_res_bytes_sent(self): return self.res_bytes_sent
    def set_res_bytes_sent(self, res_bytes_sent): self.res_bytes_sent = res_bytes_sent
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_dest_ip(self): return self.dest_ip
    def set_dest_ip(self, dest_ip): self.dest_ip = dest_ip
    def get_dest_port(self): return self.dest_port
    def set_dest_port(self, dest_port): self.dest_port = dest_port
    def export(self, outfile, level, namespace_='', name_='tcp_conversation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='tcp_conversation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='tcp_conversation'):
        outfile.write(' org_bytes_sent="%s"' % self.gds_format_integer(self.org_bytes_sent, input_name='org_bytes_sent'))
        outfile.write(' src_port="%s"' % self.gds_format_integer(self.src_port, input_name='src_port'))
        outfile.write(' src_ip=%s' % (quote_attrib(self.src_ip), ))
        outfile.write(' res_bytes_sent="%s"' % self.gds_format_integer(self.res_bytes_sent, input_name='res_bytes_sent'))
        outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
        outfile.write(' dest_ip=%s' % (quote_attrib(self.dest_ip), ))
        outfile.write(' dest_port="%s"' % self.gds_format_integer(self.dest_port, input_name='dest_port'))
    def exportChildren(self, outfile, level, namespace_='', name_='tcp_conversation'):
        for data_ in self.data:
            data_.export(outfile, level, namespace_, name_='data')
    def hasContent_(self):
        if (
            self.data
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='tcp_conversation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.org_bytes_sent is not None:
            showIndent(outfile, level)
            outfile.write('org_bytes_sent = %d,\n' % (self.org_bytes_sent,))
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port = %d,\n' % (self.src_port,))
        if self.src_ip is not None:
            showIndent(outfile, level)
            outfile.write('src_ip = %s,\n' % (self.src_ip,))
        if self.res_bytes_sent is not None:
            showIndent(outfile, level)
            outfile.write('res_bytes_sent = %d,\n' % (self.res_bytes_sent,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
        if self.dest_ip is not None:
            showIndent(outfile, level)
            outfile.write('dest_ip = %s,\n' % (self.dest_ip,))
        if self.dest_port is not None:
            showIndent(outfile, level)
            outfile.write('dest_port = %d,\n' % (self.dest_port,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('model_.data(\n')
            data_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('org_bytes_sent')
        if value is not None:
            already_processed.append('org_bytes_sent')
            try:
                self.org_bytes_sent = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('src_port')
        if value is not None:
            already_processed.append('src_port')
            try:
                self.src_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('src_ip')
        if value is not None:
            already_processed.append('src_ip')
            self.src_ip = value
        value = attrs.get('res_bytes_sent')
        if value is not None:
            already_processed.append('res_bytes_sent')
            try:
                self.res_bytes_sent = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
        value = attrs.get('dest_ip')
        if value is not None:
            already_processed.append('dest_ip')
            self.dest_ip = value
        value = attrs.get('dest_port')
        if value is not None:
            already_processed.append('dest_port')
            try:
                self.dest_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'data': 
            obj_ = data.factory()
            obj_.build(child_)
            self.data.append(obj_)
# end class tcp_conversation


class data(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, direction=None, seq=None, valueOf_=None):
        self.direction = _cast(None, direction)
        self.seq = _cast(int, seq)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if data.subclass:
            return data.subclass(*args_, **kwargs_)
        else:
            return data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='data', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='data')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='data'):
        outfile.write(' direction=%s' % (quote_attrib(self.direction), ))
        outfile.write(' seq="%s"' % self.gds_format_integer(self.seq, input_name='seq'))
    def exportChildren(self, outfile, level, namespace_='', name_='data'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='data'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction = "%s",\n' % (self.direction,))
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('seq = %d,\n' % (self.seq,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('direction')
        if value is not None:
            already_processed.append('direction')
            self.direction = value
        value = attrs.get('seq')
        if value is not None:
            already_processed.append('seq')
            try:
                self.seq = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class data


class connection_attempts(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connection_attempt=None):
        if connection_attempt is None:
            self.connection_attempt = []
        else:
            self.connection_attempt = connection_attempt
    def factory(*args_, **kwargs_):
        if connection_attempts.subclass:
            return connection_attempts.subclass(*args_, **kwargs_)
        else:
            return connection_attempts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connection_attempt(self): return self.connection_attempt
    def set_connection_attempt(self, connection_attempt): self.connection_attempt = connection_attempt
    def add_connection_attempt(self, value): self.connection_attempt.append(value)
    def insert_connection_attempt(self, index, value): self.connection_attempt[index] = value
    def export(self, outfile, level, namespace_='', name_='connection_attempts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='connection_attempts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='connection_attempts'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='connection_attempts'):
        for connection_attempt_ in self.connection_attempt:
            connection_attempt_.export(outfile, level, namespace_, name_='connection_attempt')
    def hasContent_(self):
        if (
            self.connection_attempt
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connection_attempts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('connection_attempt=[\n')
        level += 1
        for connection_attempt_ in self.connection_attempt:
            showIndent(outfile, level)
            outfile.write('model_.connection_attempt(\n')
            connection_attempt_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'connection_attempt': 
            obj_ = connection_attempt.factory()
            obj_.build(child_)
            self.connection_attempt.append(obj_)
# end class connection_attempts


class connection_attempt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src_ip=None, state=None, dest_port=None, src_port=None, dest_ip=None, valueOf_=None):
        self.src_ip = _cast(None, src_ip)
        self.state = _cast(None, state)
        self.dest_port = _cast(int, dest_port)
        self.src_port = _cast(int, src_port)
        self.dest_ip = _cast(None, dest_ip)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if connection_attempt.subclass:
            return connection_attempt.subclass(*args_, **kwargs_)
        else:
            return connection_attempt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_src_ip(self): return self.src_ip
    def set_src_ip(self, src_ip): self.src_ip = src_ip
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_dest_port(self): return self.dest_port
    def set_dest_port(self, dest_port): self.dest_port = dest_port
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_dest_ip(self): return self.dest_ip
    def set_dest_ip(self, dest_ip): self.dest_ip = dest_ip
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='connection_attempt', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='connection_attempt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='connection_attempt'):
        outfile.write(' src_ip=%s' % (quote_attrib(self.src_ip), ))
        outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
        outfile.write(' dest_port="%s"' % self.gds_format_integer(self.dest_port, input_name='dest_port'))
        outfile.write(' src_port="%s"' % self.gds_format_integer(self.src_port, input_name='src_port'))
        outfile.write(' dest_ip=%s' % (quote_attrib(self.dest_ip), ))
    def exportChildren(self, outfile, level, namespace_='', name_='connection_attempt'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connection_attempt'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src_ip is not None:
            showIndent(outfile, level)
            outfile.write('src_ip = %s,\n' % (self.src_ip,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
        if self.dest_port is not None:
            showIndent(outfile, level)
            outfile.write('dest_port = %d,\n' % (self.dest_port,))
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port = %d,\n' % (self.src_port,))
        if self.dest_ip is not None:
            showIndent(outfile, level)
            outfile.write('dest_ip = %s,\n' % (self.dest_ip,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src_ip')
        if value is not None:
            already_processed.append('src_ip')
            self.src_ip = value
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
        value = attrs.get('dest_port')
        if value is not None:
            already_processed.append('dest_port')
            try:
                self.dest_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('src_port')
        if value is not None:
            already_processed.append('src_port')
            try:
                self.src_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('dest_ip')
        if value is not None:
            already_processed.append('dest_ip')
            self.dest_ip = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class connection_attempt


class udp_traffic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unknown_udp_traffic=None, scans=None):
        self.unknown_udp_traffic = unknown_udp_traffic
        self.scans = scans
    def factory(*args_, **kwargs_):
        if udp_traffic.subclass:
            return udp_traffic.subclass(*args_, **kwargs_)
        else:
            return udp_traffic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unknown_udp_traffic(self): return self.unknown_udp_traffic
    def set_unknown_udp_traffic(self, unknown_udp_traffic): self.unknown_udp_traffic = unknown_udp_traffic
    def get_scans(self): return self.scans
    def set_scans(self, scans): self.scans = scans
    def export(self, outfile, level, namespace_='', name_='udp_traffic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='udp_traffic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='udp_traffic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='udp_traffic'):
        if self.unknown_udp_traffic:
            self.unknown_udp_traffic.export(outfile, level, namespace_, name_='unknown_udp_traffic')
        if self.scans:
            self.scans.export(outfile, level, namespace_, name_='scans')
    def hasContent_(self):
        if (
            self.unknown_udp_traffic is not None or
            self.scans is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='udp_traffic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.unknown_udp_traffic is not None:
            showIndent(outfile, level)
            outfile.write('unknown_udp_traffic=model_.unknown_udp_traffic(\n')
            self.unknown_udp_traffic.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scans is not None:
            showIndent(outfile, level)
            outfile.write('scans=model_.scans(\n')
            self.scans.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'unknown_udp_traffic': 
            obj_ = unknown_udp_traffic.factory()
            obj_.build(child_)
            self.set_unknown_udp_traffic(obj_)
        elif nodeName_ == 'scans': 
            obj_ = scans.factory()
            obj_.build(child_)
            self.set_scans(obj_)
# end class udp_traffic


class unknown_udp_traffic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, udp_conversation=None):
        if udp_conversation is None:
            self.udp_conversation = []
        else:
            self.udp_conversation = udp_conversation
    def factory(*args_, **kwargs_):
        if unknown_udp_traffic.subclass:
            return unknown_udp_traffic.subclass(*args_, **kwargs_)
        else:
            return unknown_udp_traffic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_udp_conversation(self): return self.udp_conversation
    def set_udp_conversation(self, udp_conversation): self.udp_conversation = udp_conversation
    def add_udp_conversation(self, value): self.udp_conversation.append(value)
    def insert_udp_conversation(self, index, value): self.udp_conversation[index] = value
    def export(self, outfile, level, namespace_='', name_='unknown_udp_traffic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='unknown_udp_traffic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='unknown_udp_traffic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='unknown_udp_traffic'):
        for udp_conversation_ in self.udp_conversation:
            udp_conversation_.export(outfile, level, namespace_, name_='udp_conversation')
    def hasContent_(self):
        if (
            self.udp_conversation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='unknown_udp_traffic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('udp_conversation=[\n')
        level += 1
        for udp_conversation_ in self.udp_conversation:
            showIndent(outfile, level)
            outfile.write('model_.udp_conversation(\n')
            udp_conversation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'udp_conversation': 
            obj_ = udp_conversation.factory()
            obj_.build(child_)
            self.udp_conversation.append(obj_)
# end class unknown_udp_traffic


class udp_conversation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, org_bytes_sent=None, src_port=None, src_ip=None, res_bytes_sent=None, state=None, dest_ip=None, dest_port=None, data=None):
        self.org_bytes_sent = _cast(int, org_bytes_sent)
        self.src_port = _cast(int, src_port)
        self.src_ip = _cast(None, src_ip)
        self.res_bytes_sent = _cast(int, res_bytes_sent)
        self.state = _cast(None, state)
        self.dest_ip = _cast(None, dest_ip)
        self.dest_port = _cast(int, dest_port)
        if data is None:
            self.data = []
        else:
            self.data = data
    def factory(*args_, **kwargs_):
        if udp_conversation.subclass:
            return udp_conversation.subclass(*args_, **kwargs_)
        else:
            return udp_conversation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_org_bytes_sent(self): return self.org_bytes_sent
    def set_org_bytes_sent(self, org_bytes_sent): self.org_bytes_sent = org_bytes_sent
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_src_ip(self): return self.src_ip
    def set_src_ip(self, src_ip): self.src_ip = src_ip
    def get_res_bytes_sent(self): return self.res_bytes_sent
    def set_res_bytes_sent(self, res_bytes_sent): self.res_bytes_sent = res_bytes_sent
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_dest_ip(self): return self.dest_ip
    def set_dest_ip(self, dest_ip): self.dest_ip = dest_ip
    def get_dest_port(self): return self.dest_port
    def set_dest_port(self, dest_port): self.dest_port = dest_port
    def export(self, outfile, level, namespace_='', name_='udp_conversation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='udp_conversation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='udp_conversation'):
        outfile.write(' org_bytes_sent="%s"' % self.gds_format_integer(self.org_bytes_sent, input_name='org_bytes_sent'))
        outfile.write(' src_port="%s"' % self.gds_format_integer(self.src_port, input_name='src_port'))
        outfile.write(' src_ip=%s' % (quote_attrib(self.src_ip), ))
        outfile.write(' res_bytes_sent="%s"' % self.gds_format_integer(self.res_bytes_sent, input_name='res_bytes_sent'))
        outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
        outfile.write(' dest_ip=%s' % (quote_attrib(self.dest_ip), ))
        outfile.write(' dest_port="%s"' % self.gds_format_integer(self.dest_port, input_name='dest_port'))
    def exportChildren(self, outfile, level, namespace_='', name_='udp_conversation'):
        for data_ in self.data:
            data_.export(outfile, level, namespace_, name_='data')
    def hasContent_(self):
        if (
            self.data
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='udp_conversation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.org_bytes_sent is not None:
            showIndent(outfile, level)
            outfile.write('org_bytes_sent = %d,\n' % (self.org_bytes_sent,))
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port = %d,\n' % (self.src_port,))
        if self.src_ip is not None:
            showIndent(outfile, level)
            outfile.write('src_ip = %s,\n' % (self.src_ip,))
        if self.res_bytes_sent is not None:
            showIndent(outfile, level)
            outfile.write('res_bytes_sent = %d,\n' % (self.res_bytes_sent,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
        if self.dest_ip is not None:
            showIndent(outfile, level)
            outfile.write('dest_ip = %s,\n' % (self.dest_ip,))
        if self.dest_port is not None:
            showIndent(outfile, level)
            outfile.write('dest_port = %d,\n' % (self.dest_port,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('model_.data(\n')
            data_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('org_bytes_sent')
        if value is not None:
            already_processed.append('org_bytes_sent')
            try:
                self.org_bytes_sent = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('src_port')
        if value is not None:
            already_processed.append('src_port')
            try:
                self.src_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('src_ip')
        if value is not None:
            already_processed.append('src_ip')
            self.src_ip = value
        value = attrs.get('res_bytes_sent')
        if value is not None:
            already_processed.append('res_bytes_sent')
            try:
                self.res_bytes_sent = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
        value = attrs.get('dest_ip')
        if value is not None:
            already_processed.append('dest_ip')
            self.dest_ip = value
        value = attrs.get('dest_port')
        if value is not None:
            already_processed.append('dest_port')
            try:
                self.dest_port = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'data': 
            obj_ = data.factory()
            obj_.build(child_)
            self.data.append(obj_)
# end class udp_conversation


class misc_activities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mutex_created=None, driver_loaded=None, driver_unloaded=None, key_was_checked=None, exception_occurred=None):
        if mutex_created is None:
            self.mutex_created = []
        else:
            self.mutex_created = mutex_created
        if driver_loaded is None:
            self.driver_loaded = []
        else:
            self.driver_loaded = driver_loaded
        if driver_unloaded is None:
            self.driver_unloaded = []
        else:
            self.driver_unloaded = driver_unloaded
        if key_was_checked is None:
            self.key_was_checked = []
        else:
            self.key_was_checked = key_was_checked
        if exception_occurred is None:
            self.exception_occurred = []
        else:
            self.exception_occurred = exception_occurred
    def factory(*args_, **kwargs_):
        if misc_activities.subclass:
            return misc_activities.subclass(*args_, **kwargs_)
        else:
            return misc_activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mutex_created(self): return self.mutex_created
    def set_mutex_created(self, mutex_created): self.mutex_created = mutex_created
    def add_mutex_created(self, value): self.mutex_created.append(value)
    def insert_mutex_created(self, index, value): self.mutex_created[index] = value
    def get_driver_loaded(self): return self.driver_loaded
    def set_driver_loaded(self, driver_loaded): self.driver_loaded = driver_loaded
    def add_driver_loaded(self, value): self.driver_loaded.append(value)
    def insert_driver_loaded(self, index, value): self.driver_loaded[index] = value
    def get_driver_unloaded(self): return self.driver_unloaded
    def set_driver_unloaded(self, driver_unloaded): self.driver_unloaded = driver_unloaded
    def add_driver_unloaded(self, value): self.driver_unloaded.append(value)
    def insert_driver_unloaded(self, index, value): self.driver_unloaded[index] = value
    def get_key_was_checked(self): return self.key_was_checked
    def set_key_was_checked(self, key_was_checked): self.key_was_checked = key_was_checked
    def add_key_was_checked(self, value): self.key_was_checked.append(value)
    def insert_key_was_checked(self, index, value): self.key_was_checked[index] = value
    def get_exception_occurred(self): return self.exception_occurred
    def set_exception_occurred(self, exception_occurred): self.exception_occurred = exception_occurred
    def add_exception_occurred(self, value): self.exception_occurred.append(value)
    def insert_exception_occurred(self, index, value): self.exception_occurred[index] = value
    def export(self, outfile, level, namespace_='', name_='misc_activities', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='misc_activities')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='misc_activities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='misc_activities'):
        for mutex_created_ in self.mutex_created:
            mutex_created_.export(outfile, level, namespace_, name_='mutex_created')
        for driver_loaded_ in self.driver_loaded:
            driver_loaded_.export(outfile, level, namespace_, name_='driver_loaded')
        for driver_unloaded_ in self.driver_unloaded:
            driver_unloaded_.export(outfile, level, namespace_, name_='driver_unloaded')
        for key_was_checked_ in self.key_was_checked:
            key_was_checked_.export(outfile, level, namespace_, name_='key_was_checked')
        for exception_occurred_ in self.exception_occurred:
            exception_occurred_.export(outfile, level, namespace_, name_='exception_occurred')
    def hasContent_(self):
        if (
            self.mutex_created or
            self.driver_loaded or
            self.driver_unloaded or
            self.key_was_checked or
            self.exception_occurred
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='misc_activities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mutex_created=[\n')
        level += 1
        for mutex_created_ in self.mutex_created:
            showIndent(outfile, level)
            outfile.write('model_.mutex_created(\n')
            mutex_created_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('driver_loaded=[\n')
        level += 1
        for driver_loaded_ in self.driver_loaded:
            showIndent(outfile, level)
            outfile.write('model_.driver_loaded(\n')
            driver_loaded_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('driver_unloaded=[\n')
        level += 1
        for driver_unloaded_ in self.driver_unloaded:
            showIndent(outfile, level)
            outfile.write('model_.driver_unloaded(\n')
            driver_unloaded_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('key_was_checked=[\n')
        level += 1
        for key_was_checked_ in self.key_was_checked:
            showIndent(outfile, level)
            outfile.write('model_.key_was_checked(\n')
            key_was_checked_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('exception_occurred=[\n')
        level += 1
        for exception_occurred_ in self.exception_occurred:
            showIndent(outfile, level)
            outfile.write('model_.exception_occurred(\n')
            exception_occurred_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'mutex_created': 
            obj_ = mutex_created.factory()
            obj_.build(child_)
            self.mutex_created.append(obj_)
        elif nodeName_ == 'driver_loaded': 
            obj_ = driver_loaded.factory()
            obj_.build(child_)
            self.driver_loaded.append(obj_)
        elif nodeName_ == 'driver_unloaded': 
            obj_ = driver_unloaded.factory()
            obj_.build(child_)
            self.driver_unloaded.append(obj_)
        elif nodeName_ == 'key_was_checked': 
            obj_ = key_was_checked.factory()
            obj_.build(child_)
            self.key_was_checked.append(obj_)
        elif nodeName_ == 'exception_occurred': 
            obj_ = exception_occurred.factory()
            obj_.build(child_)
            self.exception_occurred.append(obj_)
# end class misc_activities


class mutex_created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if mutex_created.subclass:
            return mutex_created.subclass(*args_, **kwargs_)
        else:
            return mutex_created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='mutex_created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='mutex_created')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='mutex_created'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mutex_created'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mutex_created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class mutex_created


class driver_loaded(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if driver_loaded.subclass:
            return driver_loaded.subclass(*args_, **kwargs_)
        else:
            return driver_loaded(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='driver_loaded', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='driver_loaded')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='driver_loaded'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='driver_loaded'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='driver_loaded'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class driver_loaded


class driver_unloaded(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if driver_unloaded.subclass:
            return driver_unloaded.subclass(*args_, **kwargs_)
        else:
            return driver_unloaded(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='driver_unloaded', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='driver_unloaded')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='driver_unloaded'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='driver_unloaded'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='driver_unloaded'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class driver_unloaded


class key_was_checked(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, key=None, valueOf_=None):
        self.count = _cast(int, count)
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if key_was_checked.subclass:
            return key_was_checked.subclass(*args_, **kwargs_)
        else:
            return key_was_checked(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='key_was_checked', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='key_was_checked')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='key_was_checked'):
        outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='key_was_checked'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='key_was_checked'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.count is not None:
            showIndent(outfile, level)
            outfile.write('count = %d,\n' % (self.count,))
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key = "%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('count')
        if value is not None:
            already_processed.append('count')
            try:
                self.count = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('key')
        if value is not None:
            already_processed.append('key')
            self.key = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class key_was_checked


class exception_occurred(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, description=None, valueOf_=None):
        self.count = _cast(int, count)
        self.description = _cast(None, description)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if exception_occurred.subclass:
            return exception_occurred.subclass(*args_, **kwargs_)
        else:
            return exception_occurred(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='exception_occurred', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='exception_occurred')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='exception_occurred'):
        outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exception_occurred'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='exception_occurred'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.count is not None:
            showIndent(outfile, level)
            outfile.write('count = %d,\n' % (self.count,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('count')
        if value is not None:
            already_processed.append('count')
            try:
                self.count = value
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('description')
        if value is not None:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class exception_occurred


class anubis_evasion(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, keywords=None):
        if keywords is None:
            self.keywords = []
        else:
            self.keywords = keywords
    def factory(*args_, **kwargs_):
        if anubis_evasion.subclass:
            return anubis_evasion.subclass(*args_, **kwargs_)
        else:
            return anubis_evasion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_keywords(self): return self.keywords
    def set_keywords(self, keywords): self.keywords = keywords
    def add_keywords(self, value): self.keywords.append(value)
    def insert_keywords(self, index, value): self.keywords[index] = value
    def export(self, outfile, level, namespace_='', name_='anubis_evasion', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='anubis_evasion')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='anubis_evasion'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='anubis_evasion'):
        for keywords_ in self.keywords:
            keywords_.export(outfile, level, namespace_, name_='keywords')
    def hasContent_(self):
        if (
            self.keywords
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='anubis_evasion'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('keywords=[\n')
        level += 1
        for keywords_ in self.keywords:
            showIndent(outfile, level)
            outfile.write('model_.keywords(\n')
            keywords_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'keywords': 
            obj_ = keywords.factory()
            obj_.build(child_)
            self.keywords.append(obj_)
# end class anubis_evasion


class keywords(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None):
        self.source = source
    def factory(*args_, **kwargs_):
        if keywords.subclass:
            return keywords.subclass(*args_, **kwargs_)
        else:
            return keywords(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def export(self, outfile, level, namespace_='', name_='keywords', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='keywords')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='keywords'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='keywords'):
        if self.source:
            self.source.export(outfile, level, namespace_, name_='source', )
    def hasContent_(self):
        if (
            self.source is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='keywords'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.source(\n')
            self.source.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'source': 
            obj_ = source.factory()
            obj_.build(child_)
            self.set_source(obj_)
# end class keywords


class source(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, popups=None, stdout=None, binary=None):
        self.popups = popups
        self.stdout = stdout
        self.binary = binary
    def factory(*args_, **kwargs_):
        if source.subclass:
            return source.subclass(*args_, **kwargs_)
        else:
            return source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_popups(self): return self.popups
    def set_popups(self, popups): self.popups = popups
    def get_stdout(self): return self.stdout
    def set_stdout(self, stdout): self.stdout = stdout
    def get_binary(self): return self.binary
    def set_binary(self, binary): self.binary = binary
    def export(self, outfile, level, namespace_='', name_='source', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='source')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='source'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='source'):
        if self.popups:
            self.popups.export(outfile, level, namespace_, name_='popups', )
        if self.stdout is not None:
            showIndent(outfile, level)
            outfile.write('<%sstdout>%s</%sstdout>\n' % (namespace_, self.gds_format_string(quote_xml(self.stdout).encode(ExternalEncoding), input_name='stdout'), namespace_))
        if self.binary is not None:
            showIndent(outfile, level)
            outfile.write('<%sbinary>%s</%sbinary>\n' % (namespace_, self.gds_format_string(quote_xml(self.binary).encode(ExternalEncoding), input_name='binary'), namespace_))
    def hasContent_(self):
        if (
            self.popups is not None or
            self.stdout is not None or
            self.binary is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='source'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.popups is not None:
            showIndent(outfile, level)
            outfile.write('popups=model_.popups(\n')
            self.popups.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.stdout is not None:
            showIndent(outfile, level)
            outfile.write('stdout=%s,\n' % quote_python(self.stdout).encode(ExternalEncoding))
        if self.binary is not None:
            showIndent(outfile, level)
            outfile.write('binary=%s,\n' % quote_python(self.binary).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'popups': 
            obj_ = popups.factory()
            obj_.build(child_)
            self.set_popups(obj_)
        elif nodeName_ == 'stdout':
            stdout_ = child_.text
            self.stdout = stdout_
        elif nodeName_ == 'binary':
            binary_ = child_.text
            self.binary = binary_
# end class source


class popups(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if popups.subclass:
            return popups.subclass(*args_, **kwargs_)
        else:
            return popups(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='popups', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='popups')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='popups'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='popups'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='popups'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class popups


class stdout(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if stdout.subclass:
            return stdout.subclass(*args_, **kwargs_)
        else:
            return stdout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='stdout', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='stdout')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='stdout'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='stdout'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stdout'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class stdout


class binary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if binary.subclass:
            return binary.subclass(*args_, **kwargs_)
        else:
            return binary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='binary', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='binary')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='binary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='binary'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='binary'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class binary


class popup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, process_name=None, number_of_popups=None, window_name=None, screenshot=None, valueOf_=None, mixedclass_=None, content_=None):
        self.process_name = _cast(None, process_name)
        self.number_of_popups = _cast(None, number_of_popups)
        self.window_name = _cast(None, window_name)
        self.screenshot = screenshot
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if popup.subclass:
            return popup.subclass(*args_, **kwargs_)
        else:
            return popup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_screenshot(self): return self.screenshot
    def set_screenshot(self, screenshot): self.screenshot = screenshot
    def get_process_name(self): return self.process_name
    def set_process_name(self, process_name): self.process_name = process_name
    def get_number_of_popups(self): return self.number_of_popups
    def set_number_of_popups(self, number_of_popups): self.number_of_popups = number_of_popups
    def get_window_name(self): return self.window_name
    def set_window_name(self, window_name): self.window_name = window_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='popup', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='popup')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='popup'):
        outfile.write(' process_name=%s' % (self.gds_format_string(quote_attrib(self.process_name).encode(ExternalEncoding), input_name='process_name'), ))
        outfile.write(' number_of_popups=%s' % (self.gds_format_string(quote_attrib(self.number_of_popups).encode(ExternalEncoding), input_name='number_of_popups'), ))
        outfile.write(' window_name=%s' % (self.gds_format_string(quote_attrib(self.window_name).encode(ExternalEncoding), input_name='window_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='popup'):
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.screenshot is not None or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='popup'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.process_name is not None:
            showIndent(outfile, level)
            outfile.write('process_name = "%s",\n' % (self.process_name,))
        if self.number_of_popups is not None:
            showIndent(outfile, level)
            outfile.write('number_of_popups = "%s",\n' % (self.number_of_popups,))
        if self.window_name is not None:
            showIndent(outfile, level)
            outfile.write('window_name = "%s",\n' % (self.window_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('process_name')
        if value is not None:
            already_processed.append('process_name')
            self.process_name = value
        value = attrs.get('number_of_popups')
        if value is not None:
            already_processed.append('number_of_popups')
            self.number_of_popups = value
        value = attrs.get('window_name')
        if value is not None:
            already_processed.append('window_name')
            self.window_name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'screenshot':
            childobj_ = screenshot.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'screenshot', childobj_)
            self.content_.append(obj_)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class popup


class screenshot(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src=None, src_small=None, valueOf_=None):
        self.src = _cast(None, src)
        self.src_small = _cast(None, src_small)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if screenshot.subclass:
            return screenshot.subclass(*args_, **kwargs_)
        else:
            return screenshot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_src_small(self): return self.src_small
    def set_src_small(self, src_small): self.src_small = src_small
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='screenshot', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='screenshot')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='screenshot'):
        outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        outfile.write(' src_small=%s' % (self.gds_format_string(quote_attrib(self.src_small).encode(ExternalEncoding), input_name='src_small'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='screenshot'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='screenshot'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.src_small is not None:
            showIndent(outfile, level)
            outfile.write('src_small = "%s",\n' % (self.src_small,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src')
        if value is not None:
            already_processed.append('src')
            self.src = value
        value = attrs.get('src_small')
        if value is not None:
            already_processed.append('src_small')
            self.src_small = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class screenshot


class global_file_info(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, global_file=None):
        if global_file is None:
            self.global_file = []
        else:
            self.global_file = global_file
    def factory(*args_, **kwargs_):
        if global_file_info.subclass:
            return global_file_info.subclass(*args_, **kwargs_)
        else:
            return global_file_info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_global_file(self): return self.global_file
    def set_global_file(self, global_file): self.global_file = global_file
    def add_global_file(self, value): self.global_file.append(value)
    def insert_global_file(self, index, value): self.global_file[index] = value
    def export(self, outfile, level, namespace_='', name_='global_file_info', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='global_file_info')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='global_file_info'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='global_file_info'):
        for global_file_ in self.global_file:
            global_file_.export(outfile, level, namespace_, name_='global_file')
    def hasContent_(self):
        if (
            self.global_file
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='global_file_info'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('global_file=[\n')
        level += 1
        for global_file_ in self.global_file:
            showIndent(outfile, level)
            outfile.write('model_.global_file(\n')
            global_file_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'global_file': 
            obj_ = global_file.factory()
            obj_.build(child_)
            self.global_file.append(obj_)
# end class global_file_info


class global_file(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, info=None, mimetype=None, name=None, md5=None, valueOf_=None):
        self.info = _cast(None, info)
        self.mimetype = _cast(None, mimetype)
        self.name = _cast(None, name)
        self.md5 = _cast(None, md5)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if global_file.subclass:
            return global_file.subclass(*args_, **kwargs_)
        else:
            return global_file(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_info(self): return self.info
    def set_info(self, info): self.info = info
    def get_mimetype(self): return self.mimetype
    def set_mimetype(self, mimetype): self.mimetype = mimetype
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_md5(self): return self.md5
    def set_md5(self, md5): self.md5 = md5
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='global_file', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='global_file')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='global_file'):
        outfile.write(' info=%s' % (self.gds_format_string(quote_attrib(self.info).encode(ExternalEncoding), input_name='info'), ))
        outfile.write(' mimetype=%s' % (self.gds_format_string(quote_attrib(self.mimetype).encode(ExternalEncoding), input_name='mimetype'), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' md5=%s' % (self.gds_format_string(quote_attrib(self.md5).encode(ExternalEncoding), input_name='md5'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='global_file'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='global_file'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.info is not None:
            showIndent(outfile, level)
            outfile.write('info = "%s",\n' % (self.info,))
        if self.mimetype is not None:
            showIndent(outfile, level)
            outfile.write('mimetype = "%s",\n' % (self.mimetype,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.md5 is not None:
            showIndent(outfile, level)
            outfile.write('md5 = "%s",\n' % (self.md5,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('info')
        if value is not None:
            already_processed.append('info')
            self.info = value
        value = attrs.get('mimetype')
        if value is not None:
            already_processed.append('mimetype')
            self.mimetype = value
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
        value = attrs.get('md5')
        if value is not None:
            already_processed.append('md5')
            self.md5 = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class global_file


class system_file_info(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, system_file=None):
        if system_file is None:
            self.system_file = []
        else:
            self.system_file = system_file
    def factory(*args_, **kwargs_):
        if system_file_info.subclass:
            return system_file_info.subclass(*args_, **kwargs_)
        else:
            return system_file_info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_system_file(self): return self.system_file
    def set_system_file(self, system_file): self.system_file = system_file
    def add_system_file(self, value): self.system_file.append(value)
    def insert_system_file(self, index, value): self.system_file[index] = value
    def export(self, outfile, level, namespace_='', name_='system_file_info', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='system_file_info')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='system_file_info'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='system_file_info'):
        for system_file_ in self.system_file:
            showIndent(outfile, level)
            outfile.write('<%ssystem_file>%s</%ssystem_file>\n' % (namespace_, self.gds_format_string(quote_xml(system_file_).encode(ExternalEncoding), input_name='system_file'), namespace_))
    def hasContent_(self):
        if (
            self.system_file
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='system_file_info'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('system_file=[\n')
        level += 1
        for system_file_ in self.system_file:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(system_file_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'system_file':
            system_file_ = child_.text
            self.system_file.append(system_file_)
# end class system_file_info


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'analysis'
        rootClass = analysis
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'analysis'
        rootClass = analysis
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="analysis",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'analysis'
        rootClass = analysis
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from anubis_v2 import *\n\n')
    sys.stdout.write('import anubis_v2 as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

