#MAEC v2.1 schema bindings
#Last updated 8/02/2012

#
# Originally Generated Fri Apr 27 16:02:07 2012 by generateDS.py version 2.7b.
#

import sys
import getopt
import re as re_
import cybox.cybox_1_0 as cybox
import cybox.common_types_1_0 as common
import cybox.uri_object_1_1 as uri_object
import cybox.system_object_1_2 as system_object
import cybox.win_system_object_1_1 as win_system_object
import cybox.code_object_1_0 as code_object
import mmdef_1_2 as mmdef

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class ActionType(cybox.ActionType):
    """The ActionType complex type is one of the foundational MAEC types,
    and serves as a method for the characterization of actions found
    or observed in malware. Actions can be thought of as system
    state changes and similar operations that represent the
    fundamental low-level operation of malware. Some examples
    include the creation of a file, deletion of a registry key, and
    the sending of some data on a socket. It imports and extends the
    CybOX ActionType. For MAEC, the id attribute is required and
    must follow the proper syntax: A dash-delimited format is used
    with the id or idref starting with the word maec followed by a
    unique string, followed by the three letter code 'act', and
    ending with an integer."""
    subclass = None
    superclass = cybox.ActionType
    def __init__(self, network_protocol=None, timestamp=None, action_status=None, ordinal_position=None, context=None, idref=None, type_=None, id=None, Action_Name=None, Description=None, Action_Aliases=None, Action_Arguments=None, Discovery_Method=None, Associated_Objects=None, Relationships=None, Frequency=None, Implementation=None, extensiontype_=None):
        super(ActionType, self).__init__(network_protocol, timestamp, action_status, ordinal_position, context, idref, type_, id, Action_Name, Description, Action_Aliases, Action_Arguments, Discovery_Method, Associated_Objects, Relationships, Frequency)
        self.Implementation = Implementation
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ActionType.subclass:
            return ActionType.subclass(*args_, **kwargs_)
        else:
            return ActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Implementation(self): return self.Implementation
    def set_Implementation(self, Implementation): self.Implementation = Implementation
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='maec:', name_='ActionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ActionType'):
        super(ActionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActionType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ActionType', fromsubclass_=False):
        super(ActionType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Implementation is not None:
            self.Implementation.export(outfile, level, 'maec:', name_='Implementation')
    def hasContent_(self):
        if (
            self.Implementation is not None or
            super(ActionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Implementation is not None:
            showIndent(outfile, level)
            outfile.write('Implementation=model_.ActionImplementationType(\n')
            self.Implementation.exportLiteral(outfile, level, name_='Implementation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(ActionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Implementation':
            obj_ = ActionImplementationType.factory()
            obj_.build(child_)
            self.set_Implementation(obj_)
        super(ActionType, self).buildChildren(child_, node, nodeName_, True)
# end class ActionType


class BehaviorType(GeneratedsSuper):
    """The BehaviorType complex type is one of the MAEC foundational types,
    and serves as a method for the characterization of malicious
    behaviors found or observed in malware. Behaviors can be thought
    of as representing the purpose behind groups of MAEC actions,
    and are therefore representative of distinct portions of higher-
    level malware functionality. Thus, while a malware instance may
    perform some multitude of actions, it is likely that these
    actions represent only a few distinct behaviors. Some examples
    include vulnerability exploitation, email address harvesting,
    and the disabling of a security service.The id attribute
    specifies a unique ID for this MAEC Behavior. The ID must follow
    the pattern defined in the BehaviorIDPattern simple type.The
    ordinal_position attribute specifies the ordinal position of the
    behavior with respect to the execution of the malware.The status
    attribute specifies the execution status of the behavior being
    characterized.The duration attribute specifies the duration of
    the behavior. One way to derive such a value may be to calculate
    the difference between the timestamps of the first and last
    actions that compose the behavior."""
    subclass = None
    superclass = None
    def __init__(self, status=None, duration=None, ordinal_position=None, id=None, Purpose=None, Description=None, Discovery_Method=None, Associated_Code=None, Actions=None, Relationships=None):
        self.status = _cast(None, status)
        self.duration = _cast(None, duration)
        self.ordinal_position = _cast(int, ordinal_position)
        self.id = _cast(None, id)
        self.Purpose = Purpose
        self.Description = Description
        self.Discovery_Method = Discovery_Method
        self.Associated_Code = Associated_Code
        self.Actions = Actions
        self.Relationships = Relationships
    def factory(*args_, **kwargs_):
        if BehaviorType.subclass:
            return BehaviorType.subclass(*args_, **kwargs_)
        else:
            return BehaviorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Discovery_Method(self): return self.Discovery_Method
    def set_Discovery_Method(self, Discovery_Method): self.Discovery_Method = Discovery_Method
    def get_Associated_Code(self): return self.Associated_Code
    def set_Associated_Code(self, Associated_Code): self.Associated_Code = Associated_Code
    def get_Actions(self): return self.Actions
    def set_Actions(self, Actions): self.Actions = Actions
    def get_Relationships(self): return self.Relationships
    def set_Relationships(self, Relationships): self.Relationships = Relationships
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_ordinal_position(self): return self.ordinal_position
    def set_ordinal_position(self, ordinal_position): self.ordinal_position = ordinal_position
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='maec:', name_='BehaviorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, 'maec:', name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehaviorType'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            outfile.write(' duration=%s' % (self.gds_format_string(quote_attrib(self.duration).encode(ExternalEncoding), input_name='duration'), ))
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.append('ordinal_position')
            outfile.write(' ordinal_position="%s"' % self.gds_format_integer(self.ordinal_position, input_name='ordinal_position'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehaviorType', fromsubclass_=False):
        if self.Purpose is not None:
            self.Purpose.export(outfile, level, 'maec:', name_='Purpose')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.Discovery_Method is not None:
            self.Discovery_Method.export(outfile, level, 'maec:', name_='Discovery_Method')
        if self.Associated_Code is not None:
            self.Associated_Code.export(outfile, level, 'maec:', name_='Associated_Code')
        if self.Actions is not None:
            self.Actions.export(outfile, level, 'maec:', name_='Actions')
        if self.Relationships is not None:
            self.Relationships.export(outfile, level, 'maec:', name_='Relationships')
    def hasContent_(self):
        if (
            self.Purpose is not None or
            self.Description is not None or
            self.Discovery_Method is not None or
            self.Associated_Code is not None or
            self.Actions is not None or
            self.Relationships is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehaviorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            showIndent(outfile, level)
            outfile.write('duration = "%s",\n' % (self.duration,))
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.append('ordinal_position')
            showIndent(outfile, level)
            outfile.write('ordinal_position = %d,\n' % (self.ordinal_position,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Purpose is not None:
            showIndent(outfile, level)
            outfile.write('Purpose=model_.BehaviorPurposeType(\n')
            self.Purpose.exportLiteral(outfile, level, name_='Purpose')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Discovery_Method is not None:
            showIndent(outfile, level)
            outfile.write('Discovery_Method=%s,\n' % quote_python(self.Discovery_Method).encode(ExternalEncoding))
        if self.Associated_Code is not None:
            showIndent(outfile, level)
            outfile.write('Associated_Code=model_.AssociatedCodeType(\n')
            self.Associated_Code.exportLiteral(outfile, level, name_='Associated_Code')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Actions is not None:
            showIndent(outfile, level)
            outfile.write('Actions=model_.BehavioralActionsType(\n')
            self.Actions.exportLiteral(outfile, level, name_='Actions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationships is not None:
            showIndent(outfile, level)
            outfile.write('Relationships=model_.BehaviorRelationshipsType(\n')
            self.Relationships.exportLiteral(outfile, level, name_='Relationships')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            self.duration = value
        value = find_attr_value_('ordinal_position', node)
        if value is not None and 'ordinal_position' not in already_processed:
            already_processed.append('ordinal_position')
            try:
                self.ordinal_position = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ordinal_position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Purpose':
            obj_ = BehaviorPurposeType.factory()
            obj_.build(child_)
            self.set_Purpose(obj_)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Discovery_Method':
            Discovery_Method_ = child_.text
            Discovery_Method_ = self.gds_validate_string(Discovery_Method_, node, 'Discovery_Method')
            self.Discovery_Method = Discovery_Method_
        elif nodeName_ == 'Associated_Code':
            obj_ = AssociatedCodeType.factory()
            obj_.build(child_)
            self.set_Associated_Code(obj_)
        elif nodeName_ == 'Actions':
            obj_ = BehavioralActionsType.factory()
            obj_.build(child_)
            self.set_Actions(obj_)
        elif nodeName_ == 'Relationships':
            obj_ = BehaviorRelationshipsType.factory()
            obj_.build(child_)
            self.set_Relationships(obj_)
# end class BehaviorType


class BundleType(GeneratedsSuper):
    """The BundleType complex type serves as the high-level construct which
    encapsulates all other MAEC elements. The id attribute specifies
    a unique ID for this MAEC Bundle. The ID must follow the pattern
    defined in the BundleIDPattern simple type.The required
    schema_version attribute specifies the version of the MAEC
    Schema that the document has been written in and that should be
    used for validation.The timestamp attribute specifies the
    date/time that the bundle was generated."""
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, id=None, schema_version=None, Analyses=None, Behaviors=None, Actions=None, Objects=None, Indicators=None, Collections=None):
        self.timestamp = _cast(None, timestamp)
        self.id = _cast(None, id)
        self.schema_version = _cast(float, schema_version)
        self.Analyses = Analyses
        self.Behaviors = Behaviors
        self.Actions = Actions
        self.Objects = Objects
        self.Indicators = Indicators
        self.Collections = Collections
    def factory(*args_, **kwargs_):
        if BundleType.subclass:
            return BundleType.subclass(*args_, **kwargs_)
        else:
            return BundleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Analyses(self): return self.Analyses
    def set_Analyses(self, Analyses): self.Analyses = Analyses
    def get_Behaviors(self): return self.Behaviors
    def set_Behaviors(self, Behaviors): self.Behaviors = Behaviors
    def get_Actions(self): return self.Actions
    def set_Actions(self, Actions): self.Actions = Actions
    def get_Objects(self): return self.Objects
    def set_Objects(self, Objects): self.Objects = Objects
    def get_Indicators(self): return self.Indicators
    def set_Indicators(self, Indicators): self.Indicators = Indicators
    def get_Collections(self): return self.Collections
    def set_Collections(self, Collections): self.Collections = Collections
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_schema_version(self): return self.schema_version
    def set_schema_version(self, schema_version): self.schema_version = schema_version
    def export(self, outfile, level, namespace_='maec:', name_='MAEC_Bundle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MAEC_Bundle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, 'maec:', name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='MAEC_Bundle'):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            outfile.write(' timestamp=%s' % (self.gds_format_string(quote_attrib(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.schema_version is not None and 'schema_version' not in already_processed:
            already_processed.append('schema_version')
            outfile.write(' schema_version="%s"' % self.schema_version)
    def exportChildren(self, outfile, level, namespace_='maec:', name_='MAEC_Bundle', fromsubclass_=False):
        if self.Analyses is not None:
            self.Analyses.export(outfile, level, 'maec:', name_='Analyses')
        if self.Behaviors is not None:
            self.Behaviors.export(outfile, level, 'maec:', name_='Behaviors')
        if self.Actions is not None:
            self.Actions.export(outfile, level, 'maec:', name_='Actions')
        if self.Objects is not None:
            self.Objects.export(outfile, level, 'maec:', name_='Objects')
        if self.Indicators is not None:
            self.Indicators.export(outfile, level, 'maec:', name_='Indicators')
        if self.Collections is not None:
            self.Collections.export(outfile, level, 'maec:', name_='Collections')
    def hasContent_(self):
        if (
            self.Analyses is not None or
            self.Behaviors is not None or
            self.Actions is not None or
            self.Objects is not None or
            self.Indicators is not None or
            self.Collections is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MAEC_Bundle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            showIndent(outfile, level)
            outfile.write('timestamp = "%s",\n' % (self.timestamp,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.schema_version is not None and 'schema_version' not in already_processed:
            already_processed.append('schema_version')
            showIndent(outfile, level)
            outfile.write('schema_version = %f,\n' % (self.schema_version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Analyses is not None:
            showIndent(outfile, level)
            outfile.write('Analyses=model_.Analyses(\n')
            self.Analyses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Behaviors is not None:
            showIndent(outfile, level)
            outfile.write('Behaviors=model_.Behaviors(\n')
            self.Behaviors.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Actions is not None:
            showIndent(outfile, level)
            outfile.write('Actions=model_.Actions(\n')
            self.Actions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Objects is not None:
            showIndent(outfile, level)
            outfile.write('Objects=model_.Objects(\n')
            self.Objects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Indicators is not None:
            showIndent(outfile, level)
            outfile.write('Indicators=model_.Indicators(\n')
            self.Indicators.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Collections is not None:
            showIndent(outfile, level)
            outfile.write('Collections=model_.Collections(\n')
            self.Collections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            self.timestamp = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('schema_version', node)
        if value is not None and 'schema_version' not in already_processed:
            already_processed.append('schema_version')
            try:
                self.schema_version = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (schema_version): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Analyses':
            obj_ = Analyses.factory()
            obj_.build(child_)
            self.set_Analyses(obj_)
        elif nodeName_ == 'Behaviors':
            obj_ = Behaviors.factory()
            obj_.build(child_)
            self.set_Behaviors(obj_)
        elif nodeName_ == 'Actions':
            obj_ = Actions.factory()
            obj_.build(child_)
            self.set_Actions(obj_)
        elif nodeName_ == 'Objects':
            obj_ = Objects.factory()
            obj_.build(child_)
            self.set_Objects(obj_)
        elif nodeName_ == 'Indicators':
            obj_ = Indicators.factory()
            obj_.build(child_)
            self.set_Indicators(obj_)
        elif nodeName_ == 'Collections':
            obj_ = Collections.factory()
            obj_.build(child_)
            self.set_Collections(obj_)
# end class BundleType


class Analyses(GeneratedsSuper):
    """The Analyses element contains 1-n AnalysisType objects, representing
    any analyses performed on a malware instance."""
    subclass = None
    superclass = None
    def __init__(self, Analysis=None):
        if Analysis is None:
            self.Analysis = []
        else:
            self.Analysis = Analysis
    def factory(*args_, **kwargs_):
        if Analyses.subclass:
            return Analyses.subclass(*args_, **kwargs_)
        else:
            return Analyses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Analysis(self): return self.Analysis
    def set_Analysis(self, Analysis): self.Analysis = Analysis
    def add_Analysis(self, value): self.Analysis.append(value)
    def insert_Analysis(self, index, value): self.Analysis[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Analyses', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Analyses')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Analyses'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Analyses', fromsubclass_=False):
        for Analysis_ in self.Analysis:
            Analysis_.export(outfile, level, 'maec:', name_='Analysis')
    def hasContent_(self):
        if (
            self.Analysis
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Analyses'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Analysis=[\n')
        level += 1
        for Analysis_ in self.Analysis:
            showIndent(outfile, level)
            outfile.write('model_.AnalysisType(\n')
            Analysis_.exportLiteral(outfile, level, name_='AnalysisType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Analysis':
            obj_ = AnalysisType.factory()
            obj_.build(child_)
            self.Analysis.append(obj_)
# end class Analyses


class Behaviors(GeneratedsSuper):
    """The Behaviors element contains 1-n BehaviorType objects,
    representing any behaviors that were observed for a malware
    instance."""
    subclass = None
    superclass = None
    def __init__(self, Behavior=None):
        if Behavior is None:
            self.Behavior = []
        else:
            self.Behavior = Behavior
    def factory(*args_, **kwargs_):
        if Behaviors.subclass:
            return Behaviors.subclass(*args_, **kwargs_)
        else:
            return Behaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior(self): return self.Behavior
    def set_Behavior(self, Behavior): self.Behavior = Behavior
    def add_Behavior(self, value): self.Behavior.append(value)
    def insert_Behavior(self, index, value): self.Behavior[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Behaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Behaviors')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Behaviors'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Behaviors', fromsubclass_=False):
        for Behavior_ in self.Behavior:
            Behavior_.export(outfile, level, 'maec:', name_='Behavior')
    def hasContent_(self):
        if (
            self.Behavior
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Behaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Behavior=[\n')
        level += 1
        for Behavior_ in self.Behavior:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorType(\n')
            Behavior_.exportLiteral(outfile, level, name_='BehaviorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior':
            obj_ = BehaviorType.factory()
            obj_.build(child_)
            self.Behavior.append(obj_)
# end class Behaviors


class Actions(GeneratedsSuper):
    """The Actions element contains 1-n ActionType objects, representing
    any actions that were observed for a malware instance."""
    subclass = None
    superclass = None
    def __init__(self, Action=None):
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
    def factory(*args_, **kwargs_):
        if Actions.subclass:
            return Actions.subclass(*args_, **kwargs_)
        else:
            return Actions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Actions', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Actions')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Actions'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Actions', fromsubclass_=False):
        for Action_ in self.Action:
            Action_.export(outfile, level, 'maec:', name_='Action')
    def hasContent_(self):
        if (
            self.Action
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Actions'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.ActionType(\n')
            Action_.exportLiteral(outfile, level, name_='ActionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            class_obj_ = self.get_class_obj_(child_, ActionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Action.append(obj_)
# end class Actions

class Action_References(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Action_Reference=None):
        if Action_Reference is None:
            self.Action_Reference = []
        else:
            self.Action_Reference = Action_Reference
    def factory(*args_, **kwargs_):
        if Actions.subclass:
            return Actions.subclass(*args_, **kwargs_)
        else:
            return Actions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Reference(self): return self.Action_Reference
    def set_Action_Reference(self, Action): self.Action_Reference = Action
    def add_Action_Reference(self, value): self.Action_Reference.append(value)
    def insert_Action_Reference(self, index, value): self.Action[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Actions', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Actions')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Actions'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Actions', fromsubclass_=False):
        for Action_Reference_ in self.Action_Reference:
            Action_Reference_.export(outfile, level, 'maec:', name_='Action_Reference')
    def hasContent_(self):
        if (
            self.Action_Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Actions'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.ActionReferenceType(\n')
            Action_.exportLiteral(outfile, level, name_='ActionReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Reference':
            class_obj_ = self.get_class_obj_(child_, ActionRefereceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Action_Reference.append(obj_)
# end class Actions

class Objects(GeneratedsSuper):
    """The Objects element contains 1-n ObjectType objects, representing
    any objects associated with a malware instance. It can also be
    used as a mechanism for storage of objects that are referenced
    multiple times in the Bundle."""
    subclass = None
    superclass = None
    def __init__(self, Object=None):
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
    def factory(*args_, **kwargs_):
        if Objects.subclass:
            return Objects.subclass(*args_, **kwargs_)
        else:
            return Objects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object(self, index, value): self.Object[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Objects', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Objects')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Objects'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Objects', fromsubclass_=False):
        for Object_ in self.Object:
            Object_.export(outfile, level, 'maec:', name_='Object')
    def hasContent_(self):
        if (
            self.Object
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Objects'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Object_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            obj_ = cybox.ObjectType.factory()
            obj_.build(child_)
            self.Object.append(obj_)
# end class Objects


class Indicators(GeneratedsSuper):
    """The Indicators element contains 1-n IndicatorType objects,
    representing any malware indicators that were characterized."""
    subclass = None
    superclass = None
    def __init__(self, Indicator=None):
        if Indicator is None:
            self.Indicator = []
        else:
            self.Indicator = Indicator
    def factory(*args_, **kwargs_):
        if Indicators.subclass:
            return Indicators.subclass(*args_, **kwargs_)
        else:
            return Indicators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Indicator(self): return self.Indicator
    def set_Indicator(self, Indicator): self.Indicator = Indicator
    def add_Indicator(self, value): self.Indicator.append(value)
    def insert_Indicator(self, index, value): self.Indicator[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Indicators', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Indicators')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Indicators'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Indicators', fromsubclass_=False):
        for Indicator_ in self.Indicator:
            Indicator_.export(outfile, level, 'maec:', name_='Indicator')
    def hasContent_(self):
        if (
            self.Indicator
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Indicators'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Indicator=[\n')
        level += 1
        for Indicator_ in self.Indicator:
            showIndent(outfile, level)
            outfile.write('model_.IndicatorType(\n')
            Indicator_.exportLiteral(outfile, level, name_='IndicatorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Indicator':
            obj_ = IndicatorType.factory()
            obj_.build(child_)
            self.Indicator.append(obj_)
# end class Indicators


class Collections(GeneratedsSuper):
    """The Collections element contains the collection element types for
    Behaviors, Actions, Objects, and Indicators."""
    subclass = None
    superclass = None
    def __init__(self, Behavior_Collections=None, Action_Collections=None, Object_Collections=None, Indicator_Collections=None):
        self.Behavior_Collections = Behavior_Collections
        self.Action_Collections = Action_Collections
        self.Object_Collections = Object_Collections
        self.Indicator_Collections = Indicator_Collections
    def factory(*args_, **kwargs_):
        if Collections.subclass:
            return Collections.subclass(*args_, **kwargs_)
        else:
            return Collections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior_Collections(self): return self.Behavior_Collections
    def set_Behavior_Collections(self, Behavior_Collections): self.Behavior_Collections = Behavior_Collections
    def get_Action_Collections(self): return self.Action_Collections
    def set_Action_Collections(self, Action_Collections): self.Action_Collections = Action_Collections
    def get_Object_Collections(self): return self.Object_Collections
    def set_Object_Collections(self, Object_Collections): self.Object_Collections = Object_Collections
    def get_Indicator_Collections(self): return self.Indicator_Collections
    def set_Indicator_Collections(self, Indicator_Collections): self.Indicator_Collections = Indicator_Collections
    def export(self, outfile, level, namespace_='maec:', name_='Collections', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Collections')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Collections'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Collections', fromsubclass_=False):
        if self.Behavior_Collections is not None:
            self.Behavior_Collections.export(outfile, level, 'maec:', name_='Behavior_Collections')
        if self.Action_Collections is not None:
            self.Action_Collections.export(outfile, level, 'maec:', name_='Action_Collections')
        if self.Object_Collections is not None:
            self.Object_Collections.export(outfile, level, 'maec:', name_='Object_Collections')
        if self.Indicator_Collections is not None:
            self.Indicator_Collections.export(outfile, level, 'maec:', name_='Indicator_Collections')
    def hasContent_(self):
        if (
            self.Behavior_Collections is not None or
            self.Action_Collections is not None or
            self.Object_Collections is not None or
            self.Indicator_Collections is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Collections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Behavior_Collections is not None:
            showIndent(outfile, level)
            outfile.write('Behavior_Collections=model_.Behavior_Collections(\n')
            self.Behavior_Collections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action_Collections is not None:
            showIndent(outfile, level)
            outfile.write('Action_Collections=model_.Action_Collections(\n')
            self.Action_Collections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Object_Collections is not None:
            showIndent(outfile, level)
            outfile.write('Object_Collections=model_.Object_Collections(\n')
            self.Object_Collections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Indicator_Collections is not None:
            showIndent(outfile, level)
            outfile.write('Indicator_Collections=model_.Indicator_Collections(\n')
            self.Indicator_Collections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior_Collections':
            obj_ = Behavior_Collections.factory()
            obj_.build(child_)
            self.set_Behavior_Collections(obj_)
        elif nodeName_ == 'Action_Collections':
            obj_ = Action_Collections.factory()
            obj_.build(child_)
            self.set_Action_Collections(obj_)
        elif nodeName_ == 'Object_Collections':
            obj_ = Object_Collections.factory()
            obj_.build(child_)
            self.set_Object_Collections(obj_)
        elif nodeName_ == 'Indicator_Collections':
            obj_ = Indicator_Collections.factory()
            obj_.build(child_)
            self.set_Indicator_Collections(obj_)
# end class Collections


class Behavior_Collections(GeneratedsSuper):
    """The Behavior_Collections element contains any collections of MAEC
    Behaviors in the Bundle."""
    subclass = None
    superclass = None
    def __init__(self, Behavior_Collection=None):
        if Behavior_Collection is None:
            self.Behavior_Collection = []
        else:
            self.Behavior_Collection = Behavior_Collection
    def factory(*args_, **kwargs_):
        if Behavior_Collections.subclass:
            return Behavior_Collections.subclass(*args_, **kwargs_)
        else:
            return Behavior_Collections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior_Collection(self): return self.Behavior_Collection
    def set_Behavior_Collection(self, Behavior_Collection): self.Behavior_Collection = Behavior_Collection
    def add_Behavior_Collection(self, value): self.Behavior_Collection.append(value)
    def insert_Behavior_Collection(self, index, value): self.Behavior_Collection[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Behavior_Collections', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Behavior_Collections')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Behavior_Collections'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Behavior_Collections', fromsubclass_=False):
        for Behavior_Collection_ in self.Behavior_Collection:
            Behavior_Collection_.export(outfile, level, 'maec:', name_='Behavior_Collection')
    def hasContent_(self):
        if (
            self.Behavior_Collection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Behavior_Collections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Behavior_Collection=[\n')
        level += 1
        for Behavior_Collection_ in self.Behavior_Collection:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorCollectionType(\n')
            Behavior_Collection_.exportLiteral(outfile, level, name_='BehaviorCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior_Collection':
            obj_ = BehaviorCollectionType.factory()
            obj_.build(child_)
            self.Behavior_Collection.append(obj_)
# end class Behavior_Collections


class Action_Collections(GeneratedsSuper):
    """The Action_Collections element contains any collections of MAEC
    Actions in the Bundle."""
    subclass = None
    superclass = None
    def __init__(self, Action_Collection=None):
        if Action_Collection is None:
            self.Action_Collection = []
        else:
            self.Action_Collection = Action_Collection
    def factory(*args_, **kwargs_):
        if Action_Collections.subclass:
            return Action_Collections.subclass(*args_, **kwargs_)
        else:
            return Action_Collections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Collection(self): return self.Action_Collection
    def set_Action_Collection(self, Action_Collection): self.Action_Collection = Action_Collection
    def add_Action_Collection(self, value): self.Action_Collection.append(value)
    def insert_Action_Collection(self, index, value): self.Action_Collection[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Action_Collections', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Action_Collections')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Action_Collections'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Action_Collections', fromsubclass_=False):
        for Action_Collection_ in self.Action_Collection:
            Action_Collection_.export(outfile, level, 'maec:', name_='Action_Collection')
    def hasContent_(self):
        if (
            self.Action_Collection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Action_Collections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Collection=[\n')
        level += 1
        for Action_Collection_ in self.Action_Collection:
            showIndent(outfile, level)
            outfile.write('model_.ActionCollectionType(\n')
            Action_Collection_.exportLiteral(outfile, level, name_='ActionCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Collection':
            obj_ = ActionCollectionType.factory()
            obj_.build(child_)
            self.Action_Collection.append(obj_)
# end class Action_Collections


class Object_Collections(GeneratedsSuper):
    """The Objects_Collections element contains any collections of CybOX
    Objects in the Bundle."""
    subclass = None
    superclass = None
    def __init__(self, Object_Collection=None):
        if Object_Collection is None:
            self.Object_Collection = []
        else:
            self.Object_Collection = Object_Collection
    def factory(*args_, **kwargs_):
        if Object_Collections.subclass:
            return Object_Collections.subclass(*args_, **kwargs_)
        else:
            return Object_Collections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object_Collection(self): return self.Object_Collection
    def set_Object_Collection(self, Object_Collection): self.Object_Collection = Object_Collection
    def add_Object_Collection(self, value): self.Object_Collection.append(value)
    def insert_Object_Collection(self, index, value): self.Object_Collection[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Object_Collections', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Object_Collections')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Object_Collections'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Object_Collections', fromsubclass_=False):
        for Object_Collection_ in self.Object_Collection:
            Object_Collection_.export(outfile, level, 'maec:', name_='Object_Collection')
    def hasContent_(self):
        if (
            self.Object_Collection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Object_Collections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object_Collection=[\n')
        level += 1
        for Object_Collection_ in self.Object_Collection:
            showIndent(outfile, level)
            outfile.write('model_.ObjectCollectionType(\n')
            Object_Collection_.exportLiteral(outfile, level, name_='ObjectCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object_Collection':
            obj_ = ObjectCollectionType.factory()
            obj_.build(child_)
            self.Object_Collection.append(obj_)
# end class Object_Collections


class Indicator_Collections(GeneratedsSuper):
    """The Indicator_Collections element contains any collections of MAEC
    Indicators in the Bundle."""
    subclass = None
    superclass = None
    def __init__(self, Indicator_Collection=None):
        if Indicator_Collection is None:
            self.Indicator_Collection = []
        else:
            self.Indicator_Collection = Indicator_Collection
    def factory(*args_, **kwargs_):
        if Indicator_Collections.subclass:
            return Indicator_Collections.subclass(*args_, **kwargs_)
        else:
            return Indicator_Collections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Indicator_Collection(self): return self.Indicator_Collection
    def set_Indicator_Collection(self, Indicator_Collection): self.Indicator_Collection = Indicator_Collection
    def add_Indicator_Collection(self, value): self.Indicator_Collection.append(value)
    def insert_Indicator_Collection(self, index, value): self.Indicator_Collection[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Indicator_Collections', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Indicator_Collections')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Indicator_Collections'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Indicator_Collections', fromsubclass_=False):
        for Indicator_Collection_ in self.Indicator_Collection:
            Indicator_Collection_.export(outfile, level, 'maec:', name_='Indicator_Collection')
    def hasContent_(self):
        if (
            self.Indicator_Collection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Indicator_Collections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Indicator_Collection=[\n')
        level += 1
        for Indicator_Collection_ in self.Indicator_Collection:
            showIndent(outfile, level)
            outfile.write('model_.IndicatorCollectionType(\n')
            Indicator_Collection_.exportLiteral(outfile, level, name_='IndicatorCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Indicator_Collection':
            obj_ = IndicatorCollectionType.factory()
            obj_.build(child_)
            self.Indicator_Collection.append(obj_)
# end class Indicator_Collections


class APICallType(GeneratedsSuper):
    """The APICallType complex type provides a method for the
    characterization of API calls, including functions and their
    parameters.The function_name attribute contains the exact name
    of the API function called, e.g. CreateFileEx.The
    normalized_function_name attribute contains the normalized name
    of the API function called, e.g. CreateFile."""
    subclass = None
    superclass = None
    def __init__(self, normalized_function_name=None, function_name=None, Address=None, Return_Value=None, Parameters=None):
        self.normalized_function_name = _cast(None, normalized_function_name)
        self.function_name = _cast(None, function_name)
        self.Address = Address
        self.Return_Value = Return_Value
        self.Parameters = Parameters
    def factory(*args_, **kwargs_):
        if APICallType.subclass:
            return APICallType.subclass(*args_, **kwargs_)
        else:
            return APICallType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Return_Value(self): return self.Return_Value
    def set_Return_Value(self, Return_Value): self.Return_Value = Return_Value
    def get_Parameters(self): return self.Parameters
    def set_Parameters(self, Parameters): self.Parameters = Parameters
    def get_normalized_function_name(self): return self.normalized_function_name
    def set_normalized_function_name(self, normalized_function_name): self.normalized_function_name = normalized_function_name
    def get_function_name(self): return self.function_name
    def set_function_name(self, function_name): self.function_name = function_name
    def export(self, outfile, level, namespace_='maec:', name_='APICallType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='APICallType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='APICallType'):
        if self.normalized_function_name is not None and 'normalized_function_name' not in already_processed:
            already_processed.append('normalized_function_name')
            outfile.write(' normalized_function_name=%s' % (self.gds_format_string(quote_attrib(self.normalized_function_name).encode(ExternalEncoding), input_name='normalized_function_name'), ))
        if self.function_name is not None and 'function_name' not in already_processed:
            already_processed.append('function_name')
            outfile.write(' function_name=%s' % (self.gds_format_string(quote_attrib(self.function_name).encode(ExternalEncoding), input_name='function_name'), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='APICallType', fromsubclass_=False):
        if self.Address is not None:
            self.Address.export(outfile, level, 'maec:', name_='Address')
        if self.Return_Value is not None:
            showIndent(outfile, level)
            outfile.write('<%sReturn_Value>%s</%sReturn_Value>\n' % (namespace_, self.gds_format_string(quote_xml(self.Return_Value).encode(ExternalEncoding), input_name='Return_Value'), namespace_))
        if self.Parameters is not None:
            self.Parameters.export(outfile, level, 'maec:', name_='Parameters')
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Return_Value is not None or
            self.Parameters is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='APICallType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.normalized_function_name is not None and 'normalized_function_name' not in already_processed:
            already_processed.append('normalized_function_name')
            showIndent(outfile, level)
            outfile.write('normalized_function_name = "%s",\n' % (self.normalized_function_name,))
        if self.function_name is not None and 'function_name' not in already_processed:
            already_processed.append('function_name')
            showIndent(outfile, level)
            outfile.write('function_name = "%s",\n' % (self.function_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=model_.xs_hexBinary(\n')
            self.Address.exportLiteral(outfile, level, name_='Address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Return_Value is not None:
            showIndent(outfile, level)
            outfile.write('Return_Value=%s,\n' % quote_python(self.Return_Value).encode(ExternalEncoding))
        if self.Parameters is not None:
            showIndent(outfile, level)
            outfile.write('Parameters=model_.ParametersType(\n')
            self.Parameters.exportLiteral(outfile, level, name_='Parameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('normalized_function_name', node)
        if value is not None and 'normalized_function_name' not in already_processed:
            already_processed.append('normalized_function_name')
            self.normalized_function_name = value
        value = find_attr_value_('function_name', node)
        if value is not None and 'function_name' not in already_processed:
            already_processed.append('function_name')
            self.function_name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = xs_hexBinary.factory()
            obj_.build(child_)
            self.set_Address(obj_)
        elif nodeName_ == 'Return_Value':
            Return_Value_ = child_.text
            Return_Value_ = self.gds_validate_string(Return_Value_, node, 'Return_Value')
            self.Return_Value = Return_Value_
        elif nodeName_ == 'Parameters':
            obj_ = ParametersType.factory()
            obj_.build(child_)
            self.set_Parameters(obj_)
# end class APICallType


class ActionImplementationType(GeneratedsSuper):
    """The ActionImplementationType complex type serves as a method for the
    characterization of action implementations. Currently supported
    are implementations achieved through API function calls and
    abstractly defined code. The id attribute specifies a unique ID
    for this MAEC Action Implementation. The ID must follow the
    pattern defined in the ActionImpIDPattern simple type. The type
    attribute refers to the type of action implementation being
    characterized in this element."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, Compatible_Platforms=None, API_Call=None, Code=None):
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.Compatible_Platforms = Compatible_Platforms
        self.API_Call = API_Call
        if Code is None:
            self.Code = []
        else:
            self.Code = Code
    def factory(*args_, **kwargs_):
        if ActionImplementationType.subclass:
            return ActionImplementationType.subclass(*args_, **kwargs_)
        else:
            return ActionImplementationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Compatible_Platforms(self): return self.Compatible_Platforms
    def set_Compatible_Platforms(self, Compatible_Platforms): self.Compatible_Platforms = Compatible_Platforms
    def get_API_Call(self): return self.API_Call
    def set_API_Call(self, API_Call): self.API_Call = API_Call
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def add_Code(self, value): self.Code.append(value)
    def insert_Code(self, index, value): self.Code[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='maec:', name_='ActionImplementationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionImplementationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ActionImplementationType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ActionImplementationType', fromsubclass_=False):
        if self.Compatible_Platforms is not None:
            self.Compatible_Platforms.export(outfile, level, 'maec:', name_='Compatible_Platforms')
        if self.API_Call is not None:
            self.API_Call.export(outfile, level, 'maec:', name_='API_Call')
        for Code_ in self.Code:
            Code_.export(outfile, level, 'maec:', name_='Code')
    def hasContent_(self):
        if (
            self.Compatible_Platforms is not None or
            self.API_Call is not None or
            self.Code
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionImplementationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Compatible_Platforms is not None:
            showIndent(outfile, level)
            outfile.write('Compatible_Platforms=model_.PlatformsType(\n')
            self.Compatible_Platforms.exportLiteral(outfile, level, name_='Compatible_Platforms')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.API_Call is not None:
            showIndent(outfile, level)
            outfile.write('API_Call=model_.APICallType(\n')
            self.API_Call.exportLiteral(outfile, level, name_='API_Call')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Code=[\n')
        level += 1
        for Code_ in self.Code:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Code_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Compatible_Platforms':
            obj_ = PlatformsType.factory()
            obj_.build(child_)
            self.set_Compatible_Platforms(obj_)
        elif nodeName_ == 'API_Call':
            obj_ = APICallType.factory()
            obj_.build(child_)
            self.set_API_Call(obj_)
        elif nodeName_ == 'Code':
            obj_ = code_object.CodeObjectType.factory()
            obj_.build(child_)
            self.Code.append(obj_)
# end class ActionImplementationType


class AnalysisType(GeneratedsSuper):
    """The AnalysisType complex type provides a way of encapsulating
    typical information associated with the analysis of a malware
    instance, such as the subject, authors, start datetime, and
    other relevant data.The id attribute specifies a unique ID for
    this MAEC Analysis. The ID must follow the pattern defined in
    the AnalysisIDPattern simple type.The type attribute specifies
    the type of malware analysis being performed; possible values
    are either Triage or In-depth/Manual.The method attribute is
    intended to provide a way of characterizing the type of analysis
    method used in the analysis element. Possible values: Static,
    Dynamic, Combinatorial. 'Combinatorial' refers to the use of
    both static and dynamic methods.The start_datetime attribute
    specifies the date/time the analysis was started.The
    complete_datetime attribute specifies the date/time the analysis
    was completed.The lastupdate_datetime attribute specifies the
    date/time the analysis was last updated."""
    subclass = None
    superclass = None
    def __init__(self, start_datetime=None, lastupdate_datetime=None, method=None, complete_datetime=None, type_=None, id=None, Subject=None, Comments=None, Summary=None, Analysts=None, Analysis_Environment=None, Source=None, Tools=None, Findings=None, Report=None):
        self.start_datetime = _cast(None, start_datetime)
        self.lastupdate_datetime = _cast(None, lastupdate_datetime)
        self.method = _cast(None, method)
        self.complete_datetime = _cast(None, complete_datetime)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.Subject = Subject
        self.Comments = Comments
        self.Summary = Summary
        self.Analysts = Analysts
        self.Analysis_Environment = Analysis_Environment
        self.Source = Source
        self.Tools = Tools
        self.Findings = Findings
        self.Report = Report
    def factory(*args_, **kwargs_):
        if AnalysisType.subclass:
            return AnalysisType.subclass(*args_, **kwargs_)
        else:
            return AnalysisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Subject(self): return self.Subject
    def set_Subject(self, Subject): self.Subject = Subject
    def get_Comments(self): return self.Comments
    def set_Comments(self, Comments): self.Comments = Comments
    def get_Summary(self): return self.Summary
    def set_Summary(self, Summary): self.Summary = Summary
    def get_Analysts(self): return self.Analysts
    def set_Analysts(self, Analysts): self.Analysts = Analysts
    def get_Analysis_Environment(self): return self.Analysis_Environment
    def set_Analysis_Environment(self, Analysis_Environment): self.Analysis_Environment = Analysis_Environment
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Tools(self): return self.Tools
    def set_Tools(self, Tools): self.Tools = Tools
    def get_Findings(self): return self.Findings
    def set_Findings(self, Findings): self.Findings = Findings
    def get_Report(self): return self.Report
    def set_Report(self, Report): self.Report = Report
    def get_start_datetime(self): return self.start_datetime
    def set_start_datetime(self, start_datetime): self.start_datetime = start_datetime
    def get_lastupdate_datetime(self): return self.lastupdate_datetime
    def set_lastupdate_datetime(self, lastupdate_datetime): self.lastupdate_datetime = lastupdate_datetime
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def get_complete_datetime(self): return self.complete_datetime
    def set_complete_datetime(self, complete_datetime): self.complete_datetime = complete_datetime
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='maec:', name_='AnalysisType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='AnalysisType'):
        if self.start_datetime is not None and 'start_datetime' not in already_processed:
            already_processed.append('start_datetime')
            outfile.write(' start_datetime=%s' % (self.gds_format_string(quote_attrib(self.start_datetime).encode(ExternalEncoding), input_name='start_datetime'), ))
        if self.lastupdate_datetime is not None and 'lastupdate_datetime' not in already_processed:
            already_processed.append('lastupdate_datetime')
            outfile.write(' lastupdate_datetime=%s' % (self.gds_format_string(quote_attrib(self.lastupdate_datetime).encode(ExternalEncoding), input_name='lastupdate_datetime'), ))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            outfile.write(' method=%s' % (quote_attrib(self.method), ))
        if self.complete_datetime is not None and 'complete_datetime' not in already_processed:
            already_processed.append('complete_datetime')
            outfile.write(' complete_datetime=%s' % (self.gds_format_string(quote_attrib(self.complete_datetime).encode(ExternalEncoding), input_name='complete_datetime'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='AnalysisType', fromsubclass_=False):
        if self.Subject is not None:
            self.Subject.export(outfile, level, 'maec:', name_='Subject', )
        if self.Comments is not None:
            self.Comments.export(outfile, level, 'maec:', name_='Comments')
        if self.Summary is not None:
            showIndent(outfile, level)
            outfile.write('<%sSummary>%s</%sSummary>\n' % (namespace_, self.gds_format_string(quote_xml(self.Summary).encode(ExternalEncoding), input_name='Summary'), namespace_))
        if self.Analysts is not None:
            self.Analysts.export(outfile, level, 'maec:', name_='Analysts')
        if self.Analysis_Environment is not None:
            self.Analysis_Environment.export(outfile, level, 'maec:', name_='Analysis_Environment')
        if self.Source is not None:
            self.Source.export(outfile, level, 'maec:', name_='Source')
        if self.Tools is not None:
            self.Tools.export(outfile, level, 'maec:', name_='Tools')
        if self.Findings is not None:
            self.Findings.export(outfile, level, 'maec:', name_='Findings')
        if self.Report is not None:
            self.Report.export(outfile, level, 'maec:', name_='Report')
    def hasContent_(self):
        if (
            self.Subject is not None or
            self.Comments is not None or
            self.Summary is not None or
            self.Analysts is not None or
            self.Analysis_Environment is not None or
            self.Source is not None or
            self.Tools is not None or
            self.Findings is not None or
            self.Report is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AnalysisType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.start_datetime is not None and 'start_datetime' not in already_processed:
            already_processed.append('start_datetime')
            showIndent(outfile, level)
            outfile.write('start_datetime = "%s",\n' % (self.start_datetime,))
        if self.lastupdate_datetime is not None and 'lastupdate_datetime' not in already_processed:
            already_processed.append('lastupdate_datetime')
            showIndent(outfile, level)
            outfile.write('lastupdate_datetime = "%s",\n' % (self.lastupdate_datetime,))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            showIndent(outfile, level)
            outfile.write('method = %s,\n' % (self.method,))
        if self.complete_datetime is not None and 'complete_datetime' not in already_processed:
            already_processed.append('complete_datetime')
            showIndent(outfile, level)
            outfile.write('complete_datetime = "%s",\n' % (self.complete_datetime,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Subject is not None:
            showIndent(outfile, level)
            outfile.write('Subject=model_.AnalysisSubjectType(\n')
            self.Subject.exportLiteral(outfile, level, name_='Subject')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Comments is not None:
            showIndent(outfile, level)
            outfile.write('Comments=model_.CommentsType(\n')
            self.Comments.exportLiteral(outfile, level, name_='Comments')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Summary is not None:
            showIndent(outfile, level)
            outfile.write('Summary=%s,\n' % quote_python(self.Summary).encode(ExternalEncoding))
        if self.Analysts is not None:
            showIndent(outfile, level)
            outfile.write('Analysts=%s,\n' % quote_python(self.Analysts).encode(ExternalEncoding))
        if self.Analysis_Environment is not None:
            showIndent(outfile, level)
            outfile.write('Analysis_Environment=model_.AnalysisEnvironmentType(\n')
            self.Analysis_Environment.exportLiteral(outfile, level, name_='Analysis_Environment')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.SourceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Tools is not None:
            showIndent(outfile, level)
            outfile.write('Tools=model_.ToolsType(\n')
            self.Tools.exportLiteral(outfile, level, name_='Tools')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Findings is not None:
            showIndent(outfile, level)
            outfile.write('Findings=model_.AnalysisFindingsType(\n')
            self.Findings.exportLiteral(outfile, level, name_='Findings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Report is not None:
            showIndent(outfile, level)
            outfile.write('Report=%s,\n' % quote_python(self.Report).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('start_datetime', node)
        if value is not None and 'start_datetime' not in already_processed:
            already_processed.append('start_datetime')
            self.start_datetime = value
        value = find_attr_value_('lastupdate_datetime', node)
        if value is not None and 'lastupdate_datetime' not in already_processed:
            already_processed.append('lastupdate_datetime')
            self.lastupdate_datetime = value
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.append('method')
            self.method = value
        value = find_attr_value_('complete_datetime', node)
        if value is not None and 'complete_datetime' not in already_processed:
            already_processed.append('complete_datetime')
            self.complete_datetime = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Subject':
            obj_ = AnalysisSubjectType.factory()
            obj_.build(child_)
            self.set_Subject(obj_)
        elif nodeName_ == 'Comments':
            obj_ = CommentsType.factory()
            obj_.build(child_)
            self.set_Comments(obj_)
        elif nodeName_ == 'Summary':
            Summary_ = child_.text
            Summary_ = self.gds_validate_string(Summary_, node, 'Summary')
            self.Summary = Summary_
        elif nodeName_ == 'Analysts':
            Analysts_ = child_.text
            Analysts_ = self.gds_validate_string(Analysts_, node, 'Analysts')
            self.Analysts = Analysts_
        elif nodeName_ == 'Analysis_Environment':
            obj_ = AnalysisEnvironmentType.factory()
            obj_.build(child_)
            self.set_Analysis_Environment(obj_)
        elif nodeName_ == 'Source':
            obj_ = SourceType.factory()
            obj_.build(child_)
            self.set_Source(obj_)
        elif nodeName_ == 'Tools':
            obj_ = ToolsType.factory()
            obj_.build(child_)
            self.set_Tools(obj_)
        elif nodeName_ == 'Findings':
            obj_ = AnalysisFindingsType.factory()
            obj_.build(child_)
            self.set_Findings(obj_)
        elif nodeName_ == 'Report':
            Report_ = child_.text
            Report_ = self.gds_validate_string(Report_, node, 'Report')
            self.Report = Report_
# end class AnalysisType


class AnalysisEnvironmentType(GeneratedsSuper):
    """The AnalysisEnvironmentType complex type provides mechanisms for
    characterizing the particular hardware/software environment used
    in analyzing a malware instance."""
    subclass = None
    superclass = None
    def __init__(self, Host_System=None, Analysis_Systems=None):
        self.Host_System = Host_System
        self.Analysis_Systems = Analysis_Systems
    def factory(*args_, **kwargs_):
        if AnalysisEnvironmentType.subclass:
            return AnalysisEnvironmentType.subclass(*args_, **kwargs_)
        else:
            return AnalysisEnvironmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Host_System(self): return self.Host_System
    def set_Host_System(self, Host_System): self.Host_System = Host_System
    def get_Analysis_Systems(self): return self.Analysis_Systems
    def set_Analysis_Systems(self, Analysis_Systems): self.Analysis_Systems = Analysis_Systems
    def export(self, outfile, level, namespace_='maec:', name_='AnalysisEnvironmentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisEnvironmentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='AnalysisEnvironmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='AnalysisEnvironmentType', fromsubclass_=False):
        if self.Host_System is not None:
            self.Host_System.export(outfile, level, 'maec:', name_='Host_System')
        if self.Analysis_Systems is not None:
            self.Analysis_Systems.export(outfile, level, 'maec:', name_='Analysis_Systems')
    def hasContent_(self):
        if (
            self.Host_System is not None or
            self.Analysis_Systems is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AnalysisEnvironmentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Host_System is not None:
            showIndent(outfile, level)
            outfile.write('Host_System=model_.HostSystemType(\n')
            self.Host_System.exportLiteral(outfile, level, name_='Host_System')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Analysis_Systems is not None:
            showIndent(outfile, level)
            outfile.write('Analysis_Systems=model_.AnalysisSystemsType(\n')
            self.Analysis_Systems.exportLiteral(outfile, level, name_='Analysis_Systems')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Host_System':
            obj_ = HostSystemType.factory()
            obj_.build(child_)
            self.set_Host_System(obj_)
        elif nodeName_ == 'Analysis_Systems':
            obj_ = AnalysisSystemsType.factory()
            obj_.build(child_)
            self.set_Analysis_Systems(obj_)
# end class AnalysisEnvironmentType


class CVEVulnerabilityType(GeneratedsSuper):
    """The CVEVulnerabilityType complex type provides a way of referencing
    specific vulnerabilities that malware exploits or attempts to
    exploit via a Common Vulnerabilities and Exposures (CPE)
    identifier. For more information on CPE please see
    http://cpe.mitre.org. The cve_id attribute contains the ID of
    the CVE that is being referenced. E.g. CVE-1999-0002."""
    subclass = None
    superclass = None
    def __init__(self, cve_id=None, Description=None):
        self.cve_id = _cast(None, cve_id)
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CVEVulnerabilityType.subclass:
            return CVEVulnerabilityType.subclass(*args_, **kwargs_)
        else:
            return CVEVulnerabilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_cve_id(self): return self.cve_id
    def set_cve_id(self, cve_id): self.cve_id = cve_id
    def export(self, outfile, level, namespace_='maec:', name_='CVEVulnerabilityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CVEVulnerabilityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='CVEVulnerabilityType'):
        if self.cve_id is not None and 'cve_id' not in already_processed:
            already_processed.append('cve_id')
            outfile.write(' cve_id=%s' % (self.gds_format_string(quote_attrib(self.cve_id).encode(ExternalEncoding), input_name='cve_id'), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='CVEVulnerabilityType', fromsubclass_=False):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
    def hasContent_(self):
        if (
            self.Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CVEVulnerabilityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cve_id is not None and 'cve_id' not in already_processed:
            already_processed.append('cve_id')
            showIndent(outfile, level)
            outfile.write('cve_id = "%s",\n' % (self.cve_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cve_id', node)
        if value is not None and 'cve_id' not in already_processed:
            already_processed.append('cve_id')
            self.cve_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class CVEVulnerabilityType


class IndicatorType(common.IndicatorType):
    """The IndicatorType complex type provides a way of defining MAEC
    Object-based indicators for malware and related entities, such
    as Actions and Behaviors, along with any additional context
    regarding the indicator.The id attribute specifies a unique ID
    for this MAEC Indicator. The ID must follow the pattern defined
    in the IndicatorIDPattern simple type.The creation_datetime
    attribute specifies the date/time that the indicator was
    created.The lastupdate_datetime attribute specifies the last
    date/time that the indicator was updated.The importance
    attribute specifies the relative importance of the indicator.The
    numeric_importance attribute specifies the specific numeric
    importance of the indicator.The version attribute specifies the
    version of the indicator."""
    subclass = None
    superclass = common.IndicatorType
    def __init__(self, type_=None, creation_datetime=None, importance=None, numeric_importance=None, lastupdate_datetime=None, version=None, id=None, Author=None, Description=None, Source=None, Comments=None, Target=None, Observables=None):
        super(IndicatorType, self).__init__(type_)
        self.creation_datetime = _cast(None, creation_datetime)
        self.importance = _cast(None, importance)
        self.numeric_importance = _cast(int, numeric_importance)
        self.lastupdate_datetime = _cast(None, lastupdate_datetime)
        self.version = _cast(None, version)
        self.id = _cast(None, id)
        self.Author = Author
        self.Description = Description
        self.Source = Source
        self.Comments = Comments
        self.Target = Target
        self.Observables = Observables
    def factory(*args_, **kwargs_):
        if IndicatorType.subclass:
            return IndicatorType.subclass(*args_, **kwargs_)
        else:
            return IndicatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Author(self): return self.Author
    def set_Author(self, Author): self.Author = Author
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Comments(self): return self.Comments
    def set_Comments(self, Comments): self.Comments = Comments
    def get_Target(self): return self.Target
    def set_Target(self, Target): self.Target = Target
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def get_creation_datetime(self): return self.creation_datetime
    def set_creation_datetime(self, creation_datetime): self.creation_datetime = creation_datetime
    def get_importance(self): return self.importance
    def set_importance(self, importance): self.importance = importance
    def get_numeric_importance(self): return self.numeric_importance
    def set_numeric_importance(self, numeric_importance): self.numeric_importance = numeric_importance
    def get_lastupdate_datetime(self): return self.lastupdate_datetime
    def set_lastupdate_datetime(self, lastupdate_datetime): self.lastupdate_datetime = lastupdate_datetime
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='maec:', name_='IndicatorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndicatorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='IndicatorType'):
        super(IndicatorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IndicatorType')
        if self.creation_datetime is not None and 'creation_datetime' not in already_processed:
            already_processed.append('creation_datetime')
            outfile.write(' creation_datetime=%s' % (self.gds_format_string(quote_attrib(self.creation_datetime).encode(ExternalEncoding), input_name='creation_datetime'), ))
        if self.importance is not None and 'importance' not in already_processed:
            already_processed.append('importance')
            outfile.write(' importance=%s' % (quote_attrib(self.importance), ))
        if self.numeric_importance is not None and 'numeric_importance' not in already_processed:
            already_processed.append('numeric_importance')
            outfile.write(' numeric_importance="%s"' % self.gds_format_integer(self.numeric_importance, input_name='numeric_importance'))
        if self.lastupdate_datetime is not None and 'lastupdate_datetime' not in already_processed:
            already_processed.append('lastupdate_datetime')
            outfile.write(' lastupdate_datetime=%s' % (self.gds_format_string(quote_attrib(self.lastupdate_datetime).encode(ExternalEncoding), input_name='lastupdate_datetime'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='IndicatorType', fromsubclass_=False):
        if self.Author is not None:
            showIndent(outfile, level)
            outfile.write('<%sAuthor>%s</%sAuthor>\n' % (namespace_, self.gds_format_string(quote_xml(self.Author).encode(ExternalEncoding), input_name='Author'), namespace_))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.Source is not None:
            self.Source.export(outfile, level, 'maec:', name_='Source')
        if self.Comments is not None:
            self.Comments.export(outfile, level, 'maec:', name_='Comments')
        if self.Target is not None:
            self.Target.export(outfile, level, 'maec:', name_='Target')
        if self.Observables is not None:
            self.Observables.export(outfile, level, 'maec:', name_='Observables')
    def hasContent_(self):
        if (
            self.Author is not None or
            self.Description is not None or
            self.Source is not None or
            self.Comments is not None or
            self.Target is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IndicatorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.creation_datetime is not None and 'creation_datetime' not in already_processed:
            already_processed.append('creation_datetime')
            showIndent(outfile, level)
            outfile.write('creation_datetime = "%s",\n' % (self.creation_datetime,))
        if self.importance is not None and 'importance' not in already_processed:
            already_processed.append('importance')
            showIndent(outfile, level)
            outfile.write('importance = %s,\n' % (self.importance,))
        if self.numeric_importance is not None and 'numeric_importance' not in already_processed:
            already_processed.append('numeric_importance')
            showIndent(outfile, level)
            outfile.write('numeric_importance = %d,\n' % (self.numeric_importance,))
        if self.lastupdate_datetime is not None and 'lastupdate_datetime' not in already_processed:
            already_processed.append('lastupdate_datetime')
            showIndent(outfile, level)
            outfile.write('lastupdate_datetime = "%s",\n' % (self.lastupdate_datetime,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Author is not None:
            showIndent(outfile, level)
            outfile.write('Author=%s,\n' % quote_python(self.Author).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.SourceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Comments is not None:
            showIndent(outfile, level)
            outfile.write('Comments=model_.CommentsType(\n')
            self.Comments.exportLiteral(outfile, level, name_='Comments')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target is not None:
            showIndent(outfile, level)
            outfile.write('Target=model_.TargetType(\n')
            self.Target.exportLiteral(outfile, level, name_='Target')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=%s,\n' % quote_python(self.Observables).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creation_datetime', node)
        if value is not None and 'creation_datetime' not in already_processed:
            already_processed.append('creation_datetime')
            self.creation_datetime = value
        value = find_attr_value_('importance', node)
        if value is not None and 'importance' not in already_processed:
            already_processed.append('importance')
            self.importance = value
        value = find_attr_value_('numeric_importance', node)
        if value is not None and 'numeric_importance' not in already_processed:
            already_processed.append('numeric_importance')
            try:
                self.numeric_importance = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numeric_importance < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('lastupdate_datetime', node)
        if value is not None and 'lastupdate_datetime' not in already_processed:
            already_processed.append('lastupdate_datetime')
            self.lastupdate_datetime = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Author':
            Author_ = child_.text
            Author_ = self.gds_validate_string(Author_, node, 'Author')
            self.Author = Author_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Source':
            obj_ = SourceType.factory()
            obj_.build(child_)
            self.set_Source(obj_)
        elif nodeName_ == 'Comments':
            obj_ = CommentsType.factory()
            obj_.build(child_)
            self.set_Comments(obj_)
        elif nodeName_ == 'Target':
            obj_ = TargetType.factory()
            obj_.build(child_)
            self.set_Target(obj_)
        elif nodeName_ == 'Observables':
            obj_ = cybox.ObservableCompositionType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class IndicatorType


class TargetType(GeneratedsSuper):
    """The TargetType complex type provides a mechanism for characterizing
    the particular entity being targeted by an indicator or
    signature, whether it is a particular malware instance, object,
    action, behavior, family, class, or other.The type attribute
    refers to the specific type of malware entity being targeted."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, Name=None, Description=None, Targeted_Behaviors=None, Targeted_Actions=None, Targeted_Objects=None):
        self.type_ = _cast(None, type_)
        self.Name = Name
        self.Description = Description
        self.Targeted_Behaviors = Targeted_Behaviors
        self.Targeted_Actions = Targeted_Actions
        self.Targeted_Objects = Targeted_Objects
    def factory(*args_, **kwargs_):
        if TargetType.subclass:
            return TargetType.subclass(*args_, **kwargs_)
        else:
            return TargetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Targeted_Behaviors(self): return self.Targeted_Behaviors
    def set_Targeted_Behaviors(self, Targeted_Behaviors): self.Targeted_Behaviors = Targeted_Behaviors
    def get_Targeted_Actions(self): return self.Targeted_Actions
    def set_Targeted_Actions(self, Targeted_Actions): self.Targeted_Actions = Targeted_Actions
    def get_Targeted_Objects(self): return self.Targeted_Objects
    def set_Targeted_Objects(self, Targeted_Objects): self.Targeted_Objects = Targeted_Objects
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='maec:', name_='TargetType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='TargetType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='TargetType', fromsubclass_=False):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.Targeted_Behaviors is not None:
            self.Targeted_Behaviors.export(outfile, level, 'maec:', name_='Targeted_Behaviors')
        if self.Targeted_Actions is not None:
            self.Targeted_Actions.export(outfile, level, 'maec:', name_='Targeted_Actions')
        if self.Targeted_Objects is not None:
            self.Targeted_Objects.export(outfile, level, 'maec:', name_='Targeted_Objects')
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Description is not None or
            self.Targeted_Behaviors is not None or
            self.Targeted_Actions is not None or
            self.Targeted_Objects is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TargetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Targeted_Behaviors is not None:
            showIndent(outfile, level)
            outfile.write('Targeted_Behaviors=model_.BehaviorReferenceListType(\n')
            self.Targeted_Behaviors.exportLiteral(outfile, level, name_='Targeted_Behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targeted_Actions is not None:
            showIndent(outfile, level)
            outfile.write('Targeted_Actions=model_.ActionReferenceListType(\n')
            self.Targeted_Actions.exportLiteral(outfile, level, name_='Targeted_Actions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targeted_Objects is not None:
            showIndent(outfile, level)
            outfile.write('Targeted_Objects=model_.ObjectReferenceListType(\n')
            self.Targeted_Objects.exportLiteral(outfile, level, name_='Targeted_Objects')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Targeted_Behaviors':
            obj_ = BehaviorReferenceListType.factory()
            obj_.build(child_)
            self.set_Targeted_Behaviors(obj_)
        elif nodeName_ == 'Targeted_Actions':
            obj_ = ActionReferenceListType.factory()
            obj_.build(child_)
            self.set_Targeted_Actions(obj_)
        elif nodeName_ == 'Targeted_Objects':
            obj_ = ObjectReferenceListType.factory()
            obj_.build(child_)
            self.set_Targeted_Objects(obj_)
# end class TargetType


class SourceType(GeneratedsSuper):
    """The SourceType complex type provides a way of characterizing the
    external source of a relevant MAEC entity, such as an analysis
    or indicator."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Method=None, Reference=None, Organization=None, URL=None):
        self.Name = Name
        self.Method = Method
        self.Reference = Reference
        self.Organization = Organization
        self.URL = URL
    def factory(*args_, **kwargs_):
        if SourceType.subclass:
            return SourceType.subclass(*args_, **kwargs_)
        else:
            return SourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Method(self): return self.Method
    def set_Method(self, Method): self.Method = Method
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def get_Organization(self): return self.Organization
    def set_Organization(self, Organization): self.Organization = Organization
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def export(self, outfile, level, namespace_='maec:', name_='SourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='SourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='SourceType', fromsubclass_=False):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        if self.Method is not None:
            showIndent(outfile, level)
            outfile.write('<%sMethod>%s</%sMethod>\n' % (namespace_, self.gds_format_string(quote_xml(self.Method).encode(ExternalEncoding), input_name='Method'), namespace_))
        if self.Reference is not None:
            showIndent(outfile, level)
            outfile.write('<%sReference>%s</%sReference>\n' % (namespace_, self.gds_format_string(quote_xml(self.Reference).encode(ExternalEncoding), input_name='Reference'), namespace_))
        if self.Organization is not None:
            showIndent(outfile, level)
            outfile.write('<%sOrganization>%s</%sOrganization>\n' % (namespace_, self.gds_format_string(quote_xml(self.Organization).encode(ExternalEncoding), input_name='Organization'), namespace_))
        if self.URL is not None:
            self.URL.export(outfile, level, 'maec:', name_='URL')
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Method is not None or
            self.Reference is not None or
            self.Organization is not None or
            self.URL is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Method is not None:
            showIndent(outfile, level)
            outfile.write('Method=%s,\n' % quote_python(self.Method).encode(ExternalEncoding))
        if self.Reference is not None:
            showIndent(outfile, level)
            outfile.write('Reference=%s,\n' % quote_python(self.Reference).encode(ExternalEncoding))
        if self.Organization is not None:
            showIndent(outfile, level)
            outfile.write('Organization=%s,\n' % quote_python(self.Organization).encode(ExternalEncoding))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Method':
            Method_ = child_.text
            Method_ = self.gds_validate_string(Method_, node, 'Method')
            self.Method = Method_
        elif nodeName_ == 'Reference':
            Reference_ = child_.text
            Reference_ = self.gds_validate_string(Reference_, node, 'Reference')
            self.Reference = Reference_
        elif nodeName_ == 'Organization':
            Organization_ = child_.text
            Organization_ = self.gds_validate_string(Organization_, node, 'Organization')
            self.Organization = Organization_
        elif nodeName_ == 'URL':
            obj_ = uri_object.URIObjectType.factory()
            obj_.build(child_)
            self.set_URL(obj_)
# end class SourceType


class CommentsType(GeneratedsSuper):
    """The CommentsType complex type provides a simple way of capturing any
    comments related malware associated entities, such as analyses
    and indicators."""
    subclass = None
    superclass = None
    def __init__(self, Comment=None):
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CommentsType.subclass:
            return CommentsType.subclass(*args_, **kwargs_)
        else:
            return CommentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='CommentsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommentsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='CommentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='CommentsType', fromsubclass_=False):
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, 'maec:', name_='Comment')
    def hasContent_(self):
        if (
            self.Comment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CommentsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
# end class CommentsType


class BaseCollectionType(GeneratedsSuper):
    """The BaseCollectionType complex type is the base type for other MAEC
    collection types.The name attribute specifies the name of the
    collection."""
    subclass = None
    superclass = None
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, extensiontype_=None):
        self.name = _cast(None, name)
        self.Affinity_Type = Affinity_Type
        self.Affinity_Degree = Affinity_Degree
        self.Description = Description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if BaseCollectionType.subclass:
            return BaseCollectionType.subclass(*args_, **kwargs_)
        else:
            return BaseCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Affinity_Type(self): return self.Affinity_Type
    def set_Affinity_Type(self, Affinity_Type): self.Affinity_Type = Affinity_Type
    def get_Affinity_Degree(self): return self.Affinity_Degree
    def set_Affinity_Degree(self, Affinity_Degree): self.Affinity_Degree = Affinity_Degree
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='maec:', name_='BaseCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaseCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BaseCollectionType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BaseCollectionType', fromsubclass_=False):
        if self.Affinity_Type is not None:
            showIndent(outfile, level)
            outfile.write('<%sAffinity_Type>%s</%sAffinity_Type>\n' % (namespace_, self.gds_format_string(quote_xml(self.Affinity_Type).encode(ExternalEncoding), input_name='Affinity_Type'), namespace_))
        if self.Affinity_Degree is not None:
            showIndent(outfile, level)
            outfile.write('<%sAffinity_Degree>%s</%sAffinity_Degree>\n' % (namespace_, self.gds_format_string(quote_xml(self.Affinity_Degree).encode(ExternalEncoding), input_name='Affinity_Degree'), namespace_))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
    def hasContent_(self):
        if (
            self.Affinity_Type is not None or
            self.Affinity_Degree is not None or
            self.Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BaseCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Affinity_Type is not None:
            showIndent(outfile, level)
            outfile.write('Affinity_Type=%s,\n' % quote_python(self.Affinity_Type).encode(ExternalEncoding))
        if self.Affinity_Degree is not None:
            showIndent(outfile, level)
            outfile.write('Affinity_Degree=%s,\n' % quote_python(self.Affinity_Degree).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Affinity_Type':
            Affinity_Type_ = child_.text
            Affinity_Type_ = self.gds_validate_string(Affinity_Type_, node, 'Affinity_Type')
            self.Affinity_Type = Affinity_Type_
        elif nodeName_ == 'Affinity_Degree':
            Affinity_Degree_ = child_.text
            Affinity_Degree_ = self.gds_validate_string(Affinity_Degree_, node, 'Affinity_Degree')
            self.Affinity_Degree = Affinity_Degree_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class BaseCollectionType


class IndicatorCollectionType(BaseCollectionType):
    """The IndicatorCollectionType complex type provides a mechanism for
    characterizing collections of indicators.The id attribute
    specifies a unique ID for this MAEC Indicator Collection. The ID
    must follow the pattern defined in the IndicatorCollIDPattern
    simple type."""
    subclass = None
    superclass = BaseCollectionType
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, id=None, Indicator_List=None):
        super(IndicatorCollectionType, self).__init__(name, Affinity_Type, Affinity_Degree, Description, )
        self.id = _cast(None, id)
        self.Indicator_List = Indicator_List
    def factory(*args_, **kwargs_):
        if IndicatorCollectionType.subclass:
            return IndicatorCollectionType.subclass(*args_, **kwargs_)
        else:
            return IndicatorCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Indicator_List(self): return self.Indicator_List
    def set_Indicator_List(self, Indicator_List): self.Indicator_List = Indicator_List
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='maec:', name_='IndicatorCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndicatorCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='IndicatorCollectionType'):
        super(IndicatorCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IndicatorCollectionType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='IndicatorCollectionType', fromsubclass_=False):
        super(IndicatorCollectionType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Indicator_List is not None:
            self.Indicator_List.export(outfile, level, 'maec:', name_='Indicator_List', )
    def hasContent_(self):
        if (
            self.Indicator_List is not None or
            super(IndicatorCollectionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IndicatorCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        super(IndicatorCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IndicatorCollectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Indicator_List is not None:
            showIndent(outfile, level)
            outfile.write('Indicator_List=model_.IndicatorListType(\n')
            self.Indicator_List.exportLiteral(outfile, level, name_='Indicator_List')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        super(IndicatorCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Indicator_List':
            obj_ = IndicatorListType.factory()
            obj_.build(child_)
            self.set_Indicator_List(obj_)
        super(IndicatorCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class IndicatorCollectionType


class BehaviorRelationshipType(GeneratedsSuper):
    """The BehaviorRelationshipType complex type provides a method for the
    characterization of relationships among MAEC Behaviors. The type
    attribute specifies the nature of the relationship between
    behaviors that is being characterized."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, Behavior_Reference=None):
        self.type_ = _cast(None, type_)
        if Behavior_Reference is None:
            self.Behavior_Reference = []
        else:
            self.Behavior_Reference = Behavior_Reference
    def factory(*args_, **kwargs_):
        if BehaviorRelationshipType.subclass:
            return BehaviorRelationshipType.subclass(*args_, **kwargs_)
        else:
            return BehaviorRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior_Reference(self): return self.Behavior_Reference
    def set_Behavior_Reference(self, Behavior_Reference): self.Behavior_Reference = Behavior_Reference
    def add_Behavior_Reference(self, value): self.Behavior_Reference.append(value)
    def insert_Behavior_Reference(self, index, value): self.Behavior_Reference[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='maec:', name_='BehaviorRelationshipType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorRelationshipType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehaviorRelationshipType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehaviorRelationshipType', fromsubclass_=False):
        for Behavior_Reference_ in self.Behavior_Reference:
            Behavior_Reference_.export(outfile, level, 'maec:', name_='Behavior_Reference')
    def hasContent_(self):
        if (
            self.Behavior_Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehaviorRelationshipType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Behavior_Reference=[\n')
        level += 1
        for Behavior_Reference_ in self.Behavior_Reference:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorReferenceType(\n')
            Behavior_Reference_.exportLiteral(outfile, level, name_='BehaviorReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior_Reference':
            obj_ = BehaviorReferenceType.factory()
            obj_.build(child_)
            self.Behavior_Reference.append(obj_)
# end class BehaviorRelationshipType


class AnalysisSubjectType(GeneratedsSuper):
    """The AnalysisSubjectType complex type provides a method for
    characterizing the particular subject of a malware analysis."""
    subclass = None
    superclass = None
    def __init__(self, Object=None, Object_Reference=None, URL=None, Field_Data=None, Command_Line=None, Analysis_Duration=None, Exit_Code=None):
        self.Object = Object
        self.Object_Reference = Object_Reference
        self.URL = URL
        self.Field_Data = Field_Data
        self.Command_Line = Command_Line
        self.Analysis_Duration = Analysis_Duration
        self.Exit_Code = Exit_Code
    def factory(*args_, **kwargs_):
        if AnalysisSubjectType.subclass:
            return AnalysisSubjectType.subclass(*args_, **kwargs_)
        else:
            return AnalysisSubjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def get_Object_Reference(self): return self.Object_Reference
    def set_Object_Reference(self, Object_Reference): self.Object_Reference = Object_Reference
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_Field_Data(self): return self.Field_Data
    def set_Field_Data(self, Field_Data): self.Field_Data = Field_Data
    def get_Command_Line(self): return self.Command_Line
    def set_Command_Line(self, Command_Line): self.Command_Line = Command_Line
    def get_Analysis_Duration(self): return self.Analysis_Duration
    def set_Analysis_Duration(self, Analysis_Duration): self.Analysis_Duration = Analysis_Duration
    def get_Exit_Code(self): return self.Exit_Code
    def set_Exit_Code(self, Exit_Code): self.Exit_Code = Exit_Code
    def export(self, outfile, level, namespace_='maec:', name_='AnalysisSubjectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisSubjectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='AnalysisSubjectType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='AnalysisSubjectType', fromsubclass_=False):
        if self.Object is not None:
            self.Object.export(outfile, level, 'maec:', name_='Object', )
        if self.Object_Reference is not None:
            self.Object_Reference.export(outfile, level, 'maec:', name_='Object_Reference', )
        if self.URL is not None:
            self.URL.export(outfile, level, 'maec:', name_='URL')
        if self.Field_Data is not None:
            self.Field_Data.export(outfile, level, 'maec:', name_='Field_Data')
        if self.Command_Line is not None:
            showIndent(outfile, level)
            outfile.write('<%sCommand_Line>%s</%sCommand_Line>\n' % (namespace_, self.gds_format_string(quote_xml(self.Command_Line).encode(ExternalEncoding), input_name='Command_Line'), namespace_))
        if self.Analysis_Duration is not None:
            showIndent(outfile, level)
            outfile.write('<%sAnalysis_Duration>%s</%sAnalysis_Duration>\n' % (namespace_, self.gds_format_float(self.Analysis_Duration, input_name='Analysis_Duration'), namespace_))
        if self.Exit_Code is not None:
            showIndent(outfile, level)
            outfile.write('<%sExit_Code>%s</%sExit_Code>\n' % (namespace_, self.gds_format_integer(self.Exit_Code, input_name='Exit_Code'), namespace_))
    def hasContent_(self):
        if (
            self.Object is not None or
            self.Object_Reference is not None or
            self.URL is not None or
            self.Field_Data is not None or
            self.Command_Line is not None or
            self.Analysis_Duration is not None or
            self.Exit_Code is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AnalysisSubjectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('Object=%s,\n' % quote_python(self.Object).encode(ExternalEncoding))
        if self.Object_Reference is not None:
            showIndent(outfile, level)
            outfile.write('Object_Reference=model_.ObjectReferenceType(\n')
            self.Object_Reference.exportLiteral(outfile, level, name_='Object_Reference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        if self.Field_Data is not None:
            showIndent(outfile, level)
            outfile.write('Field_Data=%s,\n' % quote_python(self.Field_Data).encode(ExternalEncoding))
        if self.Command_Line is not None:
            showIndent(outfile, level)
            outfile.write('Command_Line=%s,\n' % quote_python(self.Command_Line).encode(ExternalEncoding))
        if self.Analysis_Duration is not None:
            showIndent(outfile, level)
            outfile.write('Analysis_Duration=%f,\n' % self.Analysis_Duration)
        if self.Exit_Code is not None:
            showIndent(outfile, level)
            outfile.write('Exit_Code=%d,\n' % self.Exit_Code)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            obj_ = cybox.ObjectType.factory()
            obj_.build(child_)
            self.set_Object(obj_)
        elif nodeName_ == 'Object_Reference':
            obj_ = ObjectReferenceType.factory()
            obj_.build(child_)
            self.set_Object_Reference(obj_)
        elif nodeName_ == 'URL':
            obj_ = uri_object.URIObjectType.factory()
            obj_.build(child_)
            self.set_URL(obj_)
        elif nodeName_ == 'Field_Data':
            obj_ = mmdef.fieldDataEntry.factory()
            obj_.build(child_)
            self.set_Field_Data(obj_)
        elif nodeName_ == 'Command_Line':
            Command_Line_ = child_.text
            Command_Line_ = self.gds_validate_string(Command_Line_, node, 'Command_Line')
            self.Command_Line = Command_Line_
        elif nodeName_ == 'Analysis_Duration':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Analysis_Duration')
            self.Analysis_Duration = fval_
        elif nodeName_ == 'Exit_Code':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Exit_Code')
            self.Exit_Code = ival_
# end class AnalysisSubjectType


class AVClassificationsType(cybox.DomainSpecificObjectAttributesType):
    """The AVDetectionsType references any Anti-Virus (AV) tool
    classifications of an object."""
    subclass = None
    superclass = cybox.DomainSpecificObjectAttributesType
    def __init__(self, type_=None, AV_Classification=None):
        super(AVClassificationsType, self).__init__(type_)
        if AV_Classification is None:
            self.AV_Classification = []
        else:
            self.AV_Classification = AV_Classification
    def factory(*args_, **kwargs_):
        if AVClassificationsType.subclass:
            return AVClassificationsType.subclass(*args_, **kwargs_)
        else:
            return AVClassificationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AV_Classification(self): return self.AV_Classification
    def set_AV_Classification(self, AV_Classification): self.AV_Classification = AV_Classification
    def add_AV_Classification(self, value): self.AV_Classification.append(value)
    def insert_AV_Classification(self, index, value): self.AV_Classification[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='AVClassificationsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AVClassificationsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='AVClassificationsType'):
        super(AVClassificationsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AVClassificationsType')
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='AVClassificationsType', fromsubclass_=False):
        for AV_Classification_ in self.AV_Classification:
            AV_Classification_.export(outfile, level, 'maec:', name_='AV_Classification')
    def hasContent_(self):
        if (
            self.AV_Classification
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AVClassificationsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AV_Classification=[\n')
        level += 1
        for AV_Classification_ in self.AV_Classification:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AV_Classification_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AV_Classification':
            obj_ = mmdef.classificationObject.factory()
            obj_.build(child_)
            self.AV_Classification.append(obj_)
        super(AVClassificationsType, self).buildChildren(child_, node, nodeName_, True)
# end class AVClassificationsType


class AnalysisSystemsType(GeneratedsSuper):
    """The AnalysisSystemsType is intended to capture a list of the
    systems, physical or virtual, used in the analysis of the
    malware."""
    subclass = None
    superclass = None
    def __init__(self, Analysis_System=None):
        if Analysis_System is None:
            self.Analysis_System = []
        else:
            self.Analysis_System = Analysis_System
    def factory(*args_, **kwargs_):
        if AnalysisSystemsType.subclass:
            return AnalysisSystemsType.subclass(*args_, **kwargs_)
        else:
            return AnalysisSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Analysis_System(self): return self.Analysis_System
    def set_Analysis_System(self, Analysis_System): self.Analysis_System = Analysis_System
    def add_Analysis_System(self, value): self.Analysis_System.append(value)
    def insert_Analysis_System(self, index, value): self.Analysis_System[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='AnalysisSystemsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisSystemsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='AnalysisSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='AnalysisSystemsType', fromsubclass_=False):
        for Analysis_System_ in self.Analysis_System:
            Analysis_System_.export(outfile, level, 'maec:', name_='Analysis_System')
    def hasContent_(self):
        if (
            self.Analysis_System
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AnalysisSystemsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Analysis_System=[\n')
        level += 1
        for Analysis_System_ in self.Analysis_System:
            showIndent(outfile, level)
            outfile.write('model_.AnalysisSystemType(\n')
            Analysis_System_.exportLiteral(outfile, level, name_='AnalysisSystemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Analysis_System':
            obj_ = AnalysisSystemType.factory()
            obj_.build(child_)
            self.Analysis_System.append(obj_)
# end class AnalysisSystemsType


class AnalysisFindingsType(GeneratedsSuper):
    """The AnalysisFindingsType specifies the particular findings of the
    malware analysis, in terms of MAEC actions and behaviors."""
    subclass = None
    superclass = None
    def __init__(self, Behaviors=None, Actions=None):
        self.Behaviors = Behaviors
        self.Actions = Actions
    def factory(*args_, **kwargs_):
        if AnalysisFindingsType.subclass:
            return AnalysisFindingsType.subclass(*args_, **kwargs_)
        else:
            return AnalysisFindingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behaviors(self): return self.Behaviors
    def set_Behaviors(self, Behaviors): self.Behaviors = Behaviors
    def get_Actions(self): return self.Actions
    def set_Actions(self, Actions): self.Actions = Actions
    def export(self, outfile, level, namespace_='maec:', name_='AnalysisFindingsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisFindingsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='AnalysisFindingsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='AnalysisFindingsType', fromsubclass_=False):
        if self.Behaviors is not None:
            self.Behaviors.export(outfile, level, 'maec:', name_='Behaviors')
        if self.Actions is not None:
            self.Actions.export(outfile, level, 'maec:', name_='Actions')
    def hasContent_(self):
        if (
            self.Behaviors is not None or
            self.Actions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AnalysisFindingsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Behaviors is not None:
            showIndent(outfile, level)
            outfile.write('Behaviors=model_.Behaviors(\n')
            self.Behaviors.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Actions is not None:
            showIndent(outfile, level)
            outfile.write('Actions=model_.Actions(\n')
            self.Actions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behaviors':
            obj_ = BehaviorReferenceListType.factory()
            obj_.build(child_)
            self.set_Behaviors(obj_)
        elif nodeName_ == 'Actions':
            obj_ = ActionReferenceListType.factory()
            obj_.build(child_)
            self.set_Actions(obj_)
# end class AnalysisFindingsType


class ParameterType(GeneratedsSuper):
    """The ParameterType is intended to characterize function
    parameters.This attribute refers to the ordinal position of the
    function parameter with respect to the function itself.The name
    attribute specifies the name of the parameter name/value
    pair.The value specifies the actual value of the parameter
    name/value pair."""
    subclass = None
    superclass = None
    def __init__(self, ordinal_position=None, name=None, value=None):
        self.ordinal_position = _cast(int, ordinal_position)
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if ParameterType.subclass:
            return ParameterType.subclass(*args_, **kwargs_)
        else:
            return ParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ordinal_position(self): return self.ordinal_position
    def set_ordinal_position(self, ordinal_position): self.ordinal_position = ordinal_position
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='maec:', name_='ParameterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ParameterType'):
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.append('ordinal_position')
            outfile.write(' ordinal_position="%s"' % self.gds_format_integer(self.ordinal_position, input_name='ordinal_position'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ParameterType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParameterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.append('ordinal_position')
            showIndent(outfile, level)
            outfile.write('ordinal_position = %d,\n' % (self.ordinal_position,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ordinal_position', node)
        if value is not None and 'ordinal_position' not in already_processed:
            already_processed.append('ordinal_position')
            try:
                self.ordinal_position = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ordinal_position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParameterType


class ToolsType(GeneratedsSuper):
    """The ToolsType is intended to characterize one or more tools,
    typically associated with the analysis or detection of the
    malware."""
    subclass = None
    superclass = None
    def __init__(self, Tool=None):
        if Tool is None:
            self.Tool = []
        else:
            self.Tool = Tool
    def factory(*args_, **kwargs_):
        if ToolsType.subclass:
            return ToolsType.subclass(*args_, **kwargs_)
        else:
            return ToolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tool(self): return self.Tool
    def set_Tool(self, Tool): self.Tool = Tool
    def add_Tool(self, value): self.Tool.append(value)
    def insert_Tool(self, index, value): self.Tool[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='ToolsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToolsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ToolsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ToolsType', fromsubclass_=False):
        for Tool_ in self.Tool:
            Tool_.export(outfile, level, 'maec:', name_='Tool')
    def hasContent_(self):
        if (
            self.Tool
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ToolsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Tool=[\n')
        level += 1
        for Tool_ in self.Tool:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Tool_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tool':
            obj_ = common.ToolInformationType.factory()
            obj_.build(child_)
            self.Tool.append(obj_)
# end class ToolsType


class AssociatedCodeType(GeneratedsSuper):
    """The AssociatedCodeType is intended to serve as generic way of
    specifying any code snippets associated with a MAEC entity, such
    as a behavior."""
    subclass = None
    superclass = None
    def __init__(self, Code_Snippet=None):
        if Code_Snippet is None:
            self.Code_Snippet = []
        else:
            self.Code_Snippet = Code_Snippet
    def factory(*args_, **kwargs_):
        if AssociatedCodeType.subclass:
            return AssociatedCodeType.subclass(*args_, **kwargs_)
        else:
            return AssociatedCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code_Snippet(self): return self.Code_Snippet
    def set_Code_Snippet(self, Code_Snippet): self.Code_Snippet = Code_Snippet
    def add_Code_Snippet(self, value): self.Code_Snippet.append(value)
    def insert_Code_Snippet(self, index, value): self.Code_Snippet[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='AssociatedCodeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedCodeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='AssociatedCodeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='AssociatedCodeType', fromsubclass_=False):
        for Code_Snippet_ in self.Code_Snippet:
            showIndent(outfile, level)
            outfile.write('<%sCode_Snippet>%s</%sCode_Snippet>\n' % (namespace_, self.gds_format_string(quote_xml(Code_Snippet_).encode(ExternalEncoding), input_name='Code_Snippet'), namespace_))
    def hasContent_(self):
        if (
            self.Code_Snippet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssociatedCodeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Code_Snippet=[\n')
        level += 1
        for Code_Snippet_ in self.Code_Snippet:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Code_Snippet_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code_Snippet':
            Code_Snippet_ = child_.text
            Code_Snippet_ = self.gds_validate_string(Code_Snippet_, node, 'Code_Snippet')
            self.Code_Snippet.append(Code_Snippet_)
# end class AssociatedCodeType


class BehaviorPurposeType(GeneratedsSuper):
    """The BehaviorPurposeType is intended to characterize the purpose
    behind a malware behavior."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Vulnerability_Exploit=None):
        self.Description = Description
        self.Vulnerability_Exploit = Vulnerability_Exploit
    def factory(*args_, **kwargs_):
        if BehaviorPurposeType.subclass:
            return BehaviorPurposeType.subclass(*args_, **kwargs_)
        else:
            return BehaviorPurposeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Vulnerability_Exploit(self): return self.Vulnerability_Exploit
    def set_Vulnerability_Exploit(self, Vulnerability_Exploit): self.Vulnerability_Exploit = Vulnerability_Exploit
    def export(self, outfile, level, namespace_='maec:', name_='BehaviorPurposeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorPurposeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehaviorPurposeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehaviorPurposeType', fromsubclass_=False):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.Vulnerability_Exploit is not None:
            self.Vulnerability_Exploit.export(outfile, level, 'maec:', name_='Vulnerability_Exploit')
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Vulnerability_Exploit is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehaviorPurposeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Vulnerability_Exploit is not None:
            showIndent(outfile, level)
            outfile.write('Vulnerability_Exploit=model_.VulnerabilityExploitType(\n')
            self.Vulnerability_Exploit.exportLiteral(outfile, level, name_='Vulnerability_Exploit')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Vulnerability_Exploit':
            obj_ = VulnerabilityExploitType.factory()
            obj_.build(child_)
            self.set_Vulnerability_Exploit(obj_)
# end class BehaviorPurposeType


class PlatformsType(GeneratedsSuper):
    """The PlatformsType specifies a list of software or hardware
    platforms."""
    subclass = None
    superclass = None
    def __init__(self, Platform=None):
        if Platform is None:
            self.Platform = []
        else:
            self.Platform = Platform
    def factory(*args_, **kwargs_):
        if PlatformsType.subclass:
            return PlatformsType.subclass(*args_, **kwargs_)
        else:
            return PlatformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Platform(self): return self.Platform
    def set_Platform(self, Platform): self.Platform = Platform
    def add_Platform(self, value): self.Platform.append(value)
    def insert_Platform(self, index, value): self.Platform[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='PlatformsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='PlatformsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='PlatformsType', fromsubclass_=False):
        for Platform_ in self.Platform:
            Platform_.export(outfile, level, 'maec:', name_='Platform')
    def hasContent_(self):
        if (
            self.Platform
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PlatformsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Platform=[\n')
        level += 1
        for Platform_ in self.Platform:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Platform_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Platform':
            Platform_ = child_.text
            Platform_ = self.gds_validate_string(Platform_, node, 'Platform')
            self.Platform.append(Platform_)
# end class PlatformsType


class VulnerabilityExploitType(GeneratedsSuper):
    """The VulnerabilityExploitType is intended to characterize any
    vulnerability that may be exploited by malware.The
    known_vulnerability attribute specifies whether the
    vulnerability that the malware is exploiting has been previously
    identified. If so, it should be referenced via a CVE ID in the
    CVE element. If not, the platform(s) targeted by the
    vulnerability exploitation behavior may be specified in the
    Targeted_Platforms element."""
    subclass = None
    superclass = None
    def __init__(self, known_vulnerability=None, CVE=None, Targeted_Platforms=None):
        self.known_vulnerability = _cast(bool, known_vulnerability)
        self.CVE = CVE
        self.Targeted_Platforms = Targeted_Platforms
    def factory(*args_, **kwargs_):
        if VulnerabilityExploitType.subclass:
            return VulnerabilityExploitType.subclass(*args_, **kwargs_)
        else:
            return VulnerabilityExploitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CVE(self): return self.CVE
    def set_CVE(self, CVE): self.CVE = CVE
    def get_Targeted_Platforms(self): return self.Targeted_Platforms
    def set_Targeted_Platforms(self, Targeted_Platforms): self.Targeted_Platforms = Targeted_Platforms
    def get_known_vulnerability(self): return self.known_vulnerability
    def set_known_vulnerability(self, known_vulnerability): self.known_vulnerability = known_vulnerability
    def export(self, outfile, level, namespace_='maec:', name_='VulnerabilityExploitType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VulnerabilityExploitType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='VulnerabilityExploitType'):
        if self.known_vulnerability is not None and 'known_vulnerability' not in already_processed:
            already_processed.append('known_vulnerability')
            outfile.write(' known_vulnerability="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.known_vulnerability)), input_name='known_vulnerability'))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='VulnerabilityExploitType', fromsubclass_=False):
        if self.CVE is not None:
            self.CVE.export(outfile, level, 'maec:', name_='CVE')
        if self.Targeted_Platforms is not None:
            self.Targeted_Platforms.export(outfile, level, 'maec:', name_='Targeted_Platforms')
    def hasContent_(self):
        if (
            self.CVE is not None or
            self.Targeted_Platforms is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VulnerabilityExploitType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.known_vulnerability is not None and 'known_vulnerability' not in already_processed:
            already_processed.append('known_vulnerability')
            showIndent(outfile, level)
            outfile.write('known_vulnerability = %s,\n' % (self.known_vulnerability,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CVE is not None:
            showIndent(outfile, level)
            outfile.write('CVE=model_.CVEVulnerabilityType(\n')
            self.CVE.exportLiteral(outfile, level, name_='CVE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targeted_Platforms is not None:
            showIndent(outfile, level)
            outfile.write('Targeted_Platforms=model_.PlatformsType(\n')
            self.Targeted_Platforms.exportLiteral(outfile, level, name_='Targeted_Platforms')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('known_vulnerability', node)
        if value is not None and 'known_vulnerability' not in already_processed:
            already_processed.append('known_vulnerability')
            if value in ('true', '1'):
                self.known_vulnerability = True
            elif value in ('false', '0'):
                self.known_vulnerability = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CVE':
            obj_ = CVEVulnerabilityType.factory()
            obj_.build(child_)
            self.set_CVE(obj_)
        elif nodeName_ == 'Targeted_Platforms':
            obj_ = PlatformsType.factory()
            obj_.build(child_)
            self.set_Targeted_Platforms(obj_)
# end class VulnerabilityExploitType


class ParametersType(GeneratedsSuper):
    """The ParametersType is intended to capture a list of function
    parameters."""
    subclass = None
    superclass = None
    def __init__(self, Parameter=None):
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
    def factory(*args_, **kwargs_):
        if ParametersType.subclass:
            return ParametersType.subclass(*args_, **kwargs_)
        else:
            return ParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter(self, index, value): self.Parameter[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='ParametersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParametersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ParametersType', fromsubclass_=False):
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, 'maec:', name_='Parameter')
    def hasContent_(self):
        if (
            self.Parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParametersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Parameter=[\n')
        level += 1
        for Parameter_ in self.Parameter:
            showIndent(outfile, level)
            outfile.write('model_.ParameterType(\n')
            Parameter_.exportLiteral(outfile, level, name_='ParameterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Parameter':
            obj_ = ParameterType.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
# end class ParametersType


class BehaviorRelationshipsType(GeneratedsSuper):
    """The BehaviorRelationshipsType is intended to capture the
    relationships that a behavior may have to other behaviors."""
    subclass = None
    superclass = None
    def __init__(self, Relationship=None):
        if Relationship is None:
            self.Relationship = []
        else:
            self.Relationship = Relationship
    def factory(*args_, **kwargs_):
        if BehaviorRelationshipsType.subclass:
            return BehaviorRelationshipsType.subclass(*args_, **kwargs_)
        else:
            return BehaviorRelationshipsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def add_Relationship(self, value): self.Relationship.append(value)
    def insert_Relationship(self, index, value): self.Relationship[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='BehaviorRelationshipsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorRelationshipsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehaviorRelationshipsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehaviorRelationshipsType', fromsubclass_=False):
        for Relationship_ in self.Relationship:
            Relationship_.export(outfile, level, 'maec:', name_='Relationship')
    def hasContent_(self):
        if (
            self.Relationship
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehaviorRelationshipsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship=[\n')
        level += 1
        for Relationship_ in self.Relationship:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorRelationshipType(\n')
            Relationship_.exportLiteral(outfile, level, name_='BehaviorRelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship':
            obj_ = BehaviorRelationshipType.factory()
            obj_.build(child_)
            self.Relationship.append(obj_)
# end class BehaviorRelationshipsType


class BehavioralActionsType(GeneratedsSuper):
    """The BehavioralActionsType is intended to capture the actions or
    action collections that make up a behavior."""
    subclass = None
    superclass = None
    def __init__(self, Action_Collection=None, Action=None, Action_Reference=None):
        if Action_Collection is None:
            self.Action_Collection = []
        else:
            self.Action_Collection = Action_Collection
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
        if Action_Reference is None:
            self.Action_Reference = []
        else:
            self.Action_Reference = Action_Reference
    def factory(*args_, **kwargs_):
        if BehavioralActionsType.subclass:
            return BehavioralActionsType.subclass(*args_, **kwargs_)
        else:
            return BehavioralActionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Collection(self): return self.Action_Collection
    def set_Action_Collection(self, Action_Collection): self.Action_Collection = Action_Collection
    def add_Action_Collection(self, value): self.Action_Collection.append(value)
    def insert_Action_Collection(self, index, value): self.Action_Collection[index] = value
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def get_Action_Reference(self): return self.Action_Reference
    def set_Action_Reference(self, Action_Reference): self.Action_Reference = Action_Reference
    def add_Action_Reference(self, value): self.Action_Reference.append(value)
    def insert_Action_Reference(self, index, value): self.Action_Reference[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='BehavioralActionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehavioralActionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehavioralActionsType', fromsubclass_=False):
        for Action_Collection_ in self.Action_Collection:
            Action_Collection_.export(outfile, level, 'maec:', name_='Action_Collection')
        for Action_ in self.Action:
            Action_.export(outfile, level, 'maec:', name_='Action')
        for Action_Reference_ in self.Action_Reference:
            Action_Reference_.export(outfile, level, 'maec:', name_='Action_Reference')
    def hasContent_(self):
        if (
            self.Action_Collection or
            self.Action or
            self.Action_Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehavioralActionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Collection=[\n')
        level += 1
        for Action_Collection_ in self.Action_Collection:
            showIndent(outfile, level)
            outfile.write('model_.ActionCollectionType(\n')
            Action_Collection_.exportLiteral(outfile, level, name_='ActionCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.BehavioralActionType(\n')
            Action_.exportLiteral(outfile, level, name_='BehavioralActionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Action_Reference=[\n')
        level += 1
        for Action_Reference_ in self.Action_Reference:
            showIndent(outfile, level)
            outfile.write('model_.BehavioralActionReferenceType(\n')
            Action_Reference_.exportLiteral(outfile, level, name_='BehavioralActionReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Collection':
            obj_ = ActionCollectionType.factory()
            obj_.build(child_)
            self.Action_Collection.append(obj_)
        elif nodeName_ == 'Action':
            obj_ = BehavioralActionType.factory()
            obj_.build(child_)
            self.Action.append(obj_)
        elif nodeName_ == 'Action_Reference':
            obj_ = BehavioralActionReferenceType.factory()
            obj_.build(child_)
            self.Action_Reference.append(obj_)
# end class BehavioralActionsType


class CommentType(GeneratedsSuper):
    """The CommentType is intended to capture comments made by analysts
    throughout the malware analysis process.The author attribute
    specifies the name of the author that added the comment.The
    timestamp attribute specifies the date/time that the comment was
    added."""
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, author=None, valueOf_=None):
        self.timestamp = _cast(None, timestamp)
        self.author = _cast(None, author)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CommentType.subclass:
            return CommentType.subclass(*args_, **kwargs_)
        else:
            return CommentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_author(self): return self.author
    def set_author(self, author): self.author = author
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='maec:', name_='CommentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='CommentType'):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            outfile.write(' timestamp=%s' % (self.gds_format_string(quote_attrib(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), ))
        if self.author is not None and 'author' not in already_processed:
            already_processed.append('author')
            outfile.write(' author=%s' % (self.gds_format_string(quote_attrib(self.author).encode(ExternalEncoding), input_name='author'), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='CommentType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CommentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            showIndent(outfile, level)
            outfile.write('timestamp = "%s",\n' % (self.timestamp,))
        if self.author is not None and 'author' not in already_processed:
            already_processed.append('author')
            showIndent(outfile, level)
            outfile.write('author = "%s",\n' % (self.author,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            self.timestamp = value
        value = find_attr_value_('author', node)
        if value is not None and 'author' not in already_processed:
            already_processed.append('author')
            self.author = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommentType


class AnalysisSystemType(system_object.SystemObjectType):
    """The AnalysisSystemType is intended to characterize any systems on
    which malware analysis is performed. It imports and extends
    version 1.2 of the CybOX System Object."""
    subclass = None
    superclass = system_object.SystemObjectType
    def __init__(self, Available_Physical_Memory=None, BIOS_Info=None, Date=None, Hostname=None, Local_Time=None, Network_Interface_List=None, OS=None, Processor=None, Processor_Architecture=None, System_Time=None, Timezone_DST=None, Timezone_Standard=None, Total_Physical_Memory=None, Uptime=None, Username=None, Installed_Programs=None):
        super(AnalysisSystemType, self).__init__(Available_Physical_Memory, BIOS_Info, Date, Hostname, Local_Time, Network_Interface_List, OS, Processor, Processor_Architecture, System_Time, Timezone_DST, Timezone_Standard, Total_Physical_Memory, Uptime, Username)
        self.Installed_Programs = Installed_Programs
    def factory(*args_, **kwargs_):
        if AnalysisSystemType.subclass:
            return AnalysisSystemType.subclass(*args_, **kwargs_)
        else:
            return AnalysisSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Installed_Programs(self): return self.Installed_Programs
    def set_Installed_Programs(self, Installed_Programs): self.Installed_Programs = Installed_Programs
    def export(self, outfile, level, namespace_='maec:', name_='AnalysisSystemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisSystemType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='AnalysisSystemType'):
        super(AnalysisSystemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisSystemType')
    def exportChildren(self, outfile, level, namespace_='maec:', name_='AnalysisSystemType', fromsubclass_=False):
        super(AnalysisSystemType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Installed_Programs is not None:
            self.Installed_Programs.export(outfile, level, 'maec:', name_='Installed_Programs')
    def hasContent_(self):
        if (
            self.Installed_Programs is not None or
            super(AnalysisSystemType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AnalysisSystemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Installed_Programs is not None:
            showIndent(outfile, level)
            outfile.write('Installed_Programs=model_.Installed_Programs(\n')
            self.Installed_Programs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Installed_Programs':
            obj_ = Installed_Programs.factory()
            obj_.build(child_)
            self.set_Installed_Programs(obj_)
        super(AnalysisSystemType, self).buildChildren(child_, node, nodeName_, True)
# end class AnalysisSystemType


class Installed_Programs(GeneratedsSuper):
    """The Installed_Programs element refers to information about the
    software installed on the OS used to perform the analysis. This
    can be useful for clarifying the nature of the analysis
    environment, for instance for determining whether an exploited
    piece of software was present, as well as for specifying any
    tools that may have been installed."""
    subclass = None
    superclass = None
    def __init__(self, Program=None):
        if Program is None:
            self.Program = []
        else:
            self.Program = Program
    def factory(*args_, **kwargs_):
        if Installed_Programs.subclass:
            return Installed_Programs.subclass(*args_, **kwargs_)
        else:
            return Installed_Programs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Program(self): return self.Program
    def set_Program(self, Program): self.Program = Program
    def add_Program(self, value): self.Program.append(value)
    def insert_Program(self, index, value): self.Program[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='Installed_Programs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Installed_Programs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='Installed_Programs'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='Installed_Programs', fromsubclass_=False):
        for Program_ in self.Program:
            Program_.export(outfile, level, 'maec:', name_='Program')
    def hasContent_(self):
        if (
            self.Program
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Installed_Programs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Program=[\n')
        level += 1
        for Program_ in self.Program:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Program_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Program':
            Program_ = child_.text
            Program_ = self.gds_validate_string(Program_, node, 'Program')
            self.Program.append(Program_)
# end class Installed_Programs


class HostSystemType(system_object.SystemObjectType):
    """The HostSystemType is intended to characterize the VM host system
    used in the malware analysis process."""
    subclass = None
    superclass = system_object.SystemObjectType
    def __init__(self, Available_Physical_Memory=None, BIOS_Info=None, Date=None, Hostname=None, Local_Time=None, Network_Interface_List=None, OS=None, Processor=None, Processor_Architecture=None, System_Time=None, Timezone_DST=None, Timezone_Standard=None, Total_Physical_Memory=None, Uptime=None, Username=None, Virtual_Machine=None):
        super(HostSystemType, self).__init__(Available_Physical_Memory, BIOS_Info, Date, Hostname, Local_Time, Network_Interface_List, OS, Processor, Processor_Architecture, System_Time, Timezone_DST, Timezone_Standard, Total_Physical_Memory, Uptime, Username)
        self.Virtual_Machine = Virtual_Machine
    def factory(*args_, **kwargs_):
        if HostSystemType.subclass:
            return HostSystemType.subclass(*args_, **kwargs_)
        else:
            return HostSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Virtual_Machine(self): return self.Virtual_Machine
    def set_Virtual_Machine(self, Virtual_Machine): self.Virtual_Machine = Virtual_Machine
    def export(self, outfile, level, namespace_='maec:', name_='HostSystemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HostSystemType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='HostSystemType'):
        super(HostSystemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HostSystemType')
    def exportChildren(self, outfile, level, namespace_='maec:', name_='HostSystemType', fromsubclass_=False):
        super(HostSystemType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Virtual_Machine is not None:
            self.Virtual_Machine.export(outfile, level, 'maec:', name_='Virtual_Machine')
    def hasContent_(self):
        if (
            self.Virtual_Machine is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HostSystemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Virtual_Machine is not None:
            showIndent(outfile, level)
            outfile.write('Virtual_Machine=%s,\n' % quote_python(self.Virtual_Machine).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Virtual_Machine':
            Virtual_Machine_ = child_.text
            Virtual_Machine_ = self.gds_validate_string(Virtual_Machine_, node, 'Virtual_Machine')
            self.Virtual_Machine = Virtual_Machine_
        super(HostSystemType, self).buildChildren(child_, node, nodeName_, True)
# end class HostSystemType


class BehaviorListType(GeneratedsSuper):
    """The BehaviorListType is intended to capture a list of MAEC Behaviors
    or Behavior Collections."""
    subclass = None
    superclass = None
    def __init__(self, Behavior=None, Behavior_Collection=None):
        if Behavior is None:
            self.Behavior = []
        else:
            self.Behavior = Behavior
        if Behavior_Collection is None:
            self.Behavior_Collection = []
        else:
            self.Behavior_Collection = Behavior_Collection
    def factory(*args_, **kwargs_):
        if BehaviorListType.subclass:
            return BehaviorListType.subclass(*args_, **kwargs_)
        else:
            return BehaviorListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior(self): return self.Behavior
    def set_Behavior(self, Behavior): self.Behavior = Behavior
    def add_Behavior(self, value): self.Behavior.append(value)
    def insert_Behavior(self, index, value): self.Behavior[index] = value
    def get_Behavior_Collection(self): return self.Behavior_Collection
    def set_Behavior_Collection(self, Behavior_Collection): self.Behavior_Collection = Behavior_Collection
    def add_Behavior_Collection(self, value): self.Behavior_Collection.append(value)
    def insert_Behavior_Collection(self, index, value): self.Behavior_Collection[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='BehaviorListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehaviorListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehaviorListType', fromsubclass_=False):
        for Behavior_ in self.Behavior:
            Behavior_.export(outfile, level, 'maec:', name_='Behavior')
        for Behavior_Collection_ in self.Behavior_Collection:
            Behavior_Collection_.export(outfile, level, 'maec:', name_='Behavior_Collection')
    def hasContent_(self):
        if (
            self.Behavior is not None or
            self.Behavior_Collection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehaviorListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Behavior is not None:
            showIndent(outfile, level)
            outfile.write('Behavior=model_.BehaviorType(\n')
            self.Behavior.exportLiteral(outfile, level, name_='Behavior')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Behavior_Collection=[\n')
        level += 1
        for Behavior_Collection_ in self.Behavior_Collection:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorCollectionType(\n')
            Behavior_Collection_.exportLiteral(outfile, level, name_='BehaviorCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior':
            obj_ = BehaviorType.factory()
            obj_.build(child_)
            self.Behavior.append(obj_)
        elif nodeName_ == 'Behavior_Collection':
            obj_ = BehaviorCollectionType.factory()
            obj_.build(child_)
            self.Behavior_Collection.append(obj_)
# end class BehaviorListType


class ActionListType(GeneratedsSuper):
    """The ActionListType is intended to capture a list of MAEC Actions or
    Action Collections."""
    subclass = None
    superclass = None
    def __init__(self, Action=None, Action_Collection=None):
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
        if Action_Collection is None:
            self.Action_Collection = []
        else:
            self.Action_Collection = Action_Collection
    def factory(*args_, **kwargs_):
        if ActionListType.subclass:
            return ActionListType.subclass(*args_, **kwargs_)
        else:
            return ActionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def get_Action_Collection(self): return self.Action_Collection
    def set_Action_Collection(self, Action_Collection): self.Action_Collection = Action_Collection
    def add_Action_Collection(self, value): self.Action_Collection.append(value)
    def insert_Action_Collection(self, index, value): self.Action_Collection[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='ActionListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ActionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ActionListType', fromsubclass_=False):
        for Action_ in self.Action:
            Action_.export(outfile, level, 'maec:', name_='Action')
        for Action_Collection_ in self.Action_Collection:
            Action_Collection_.export(outfile, level, 'maec:', name_='Action_Collection')
    def hasContent_(self):
        if (
            self.Action is not None or
            self.Action_Collection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Action is not None:
            showIndent(outfile, level)
            outfile.write('Action=model_.ActionType(\n')
            self.Action.exportLiteral(outfile, level, name_='Action')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Action_Collection=[\n')
        level += 1
        for Action_Collection_ in self.Action_Collection:
            showIndent(outfile, level)
            outfile.write('model_.ActionCollectionType(\n')
            Action_Collection_.exportLiteral(outfile, level, name_='ActionCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            obj_ = ActionType.factory()
            obj_.build(child_)
            self.Action.append(obj_)
        elif nodeName_ == 'Action_Collection':
            obj_ = ActionCollectionType.factory()
            obj_.build(child_)
            self.Action_Collection.append(obj_)
# end class ActionListType


class ObjectListType(GeneratedsSuper):
    """The ObjectListType is intended to capture a list of CybOX Objects or
    MAEC Object Collections."""
    subclass = None
    superclass = None
    def __init__(self, Object=None, Object_Collection=None):
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
        if Object_Collection is None:
            self.Object_Collection = []
        else:
            self.Object_Collection = Object_Collection
    def factory(*args_, **kwargs_):
        if ObjectListType.subclass:
            return ObjectListType.subclass(*args_, **kwargs_)
        else:
            return ObjectListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object(self, index, value): self.Object[index] = value
    def get_Object_Collection(self): return self.Object_Collection
    def set_Object_Collection(self, Object_Collection): self.Object_Collection = Object_Collection
    def add_Object_Collection(self, value): self.Object_Collection.append(value)
    def insert_Object_Collection(self, index, value): self.Object_Collection[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='ObjectListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ObjectListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ObjectListType', fromsubclass_=False):
        for Object_ in self.Object:
            Object_.export(outfile, level, 'maec:', name_='Object')
        for Object_Collection_ in self.Object_Collection:
            Object_Collection_.export(outfile, level, 'maec:', name_='Object_Collection')
    def hasContent_(self):
        if (
            self.Object is not None or
            self.Object_Collection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('Object=%s,\n' % quote_python(self.Object).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Object_Collection=[\n')
        level += 1
        for Object_Collection_ in self.Object_Collection:
            showIndent(outfile, level)
            outfile.write('model_.ObjectCollectionType(\n')
            Object_Collection_.exportLiteral(outfile, level, name_='ObjectCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            obj_ = cybox.ObjectType.factory()
            obj_.build(child_)
            self.Object.append(obj_)
        elif nodeName_ == 'Object_Collection':
            obj_ = ObjectCollectionType.factory()
            obj_.build(child_)
            self.Object_Collection.append(obj_)
# end class ObjectListType


class IndicatorListType(GeneratedsSuper):
    """The IndicatorListType is intended to capture a list of MAEC
    Indicators or Indicator Collections."""
    subclass = None
    superclass = None
    def __init__(self, Indicator=None, Indicator_Collection=None):
        if Indicator is None:
            self.Indicator = []
        else:
            self.Indicator = Indicator
        if Indicator_Collection is None:
            self.Indicator_Collection = []
        else:
            self.Indicator_Collection = Indicator_Collection
    def factory(*args_, **kwargs_):
        if IndicatorListType.subclass:
            return IndicatorListType.subclass(*args_, **kwargs_)
        else:
            return IndicatorListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Indicator(self): return self.Indicator
    def set_Indicator(self, Indicator): self.Indicator = Indicator
    def add_Indicator(self, value): self.Indicator.append(value)
    def insert_Indicator(self, index, value): self.Indicator[index] = value
    def get_Indicator_Collection(self): return self.Indicator_Collection
    def set_Indicator_Collection(self, Indicator_Collection): self.Indicator_Collection = Indicator_Collection
    def add_Indicator_Collection(self, value): self.Indicator_Collection.append(value)
    def insert_Indicator_Collection(self, index, value): self.Indicator_Collection[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='IndicatorListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndicatorListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='IndicatorListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='IndicatorListType', fromsubclass_=False):
        for Indicator_ in self.Indicator:
            Indicator_.export(outfile, level, 'maec:', name_='Indicator')
        for Indicator_Collection_ in self.Indicator_Collection:
            Indicator_Collection_.export(outfile, level, 'maec:', name_='Indicator_Collection')
    def hasContent_(self):
        if (
            self.Indicator or
            self.Indicator_Collection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IndicatorListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Indicator=[\n')
        level += 1
        for Indicator_ in self.Indicator:
            showIndent(outfile, level)
            outfile.write('model_.IndicatorType(\n')
            Indicator_.exportLiteral(outfile, level, name_='IndicatorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Indicator_Collection=[\n')
        level += 1
        for Indicator_Collection_ in self.Indicator_Collection:
            showIndent(outfile, level)
            outfile.write('model_.IndicatorCollectionType(\n')
            Indicator_Collection_.exportLiteral(outfile, level, name_='IndicatorCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Indicator':
            obj_ = IndicatorType.factory()
            obj_.build(child_)
            self.Indicator.append(obj_)
        elif nodeName_ == 'Indicator_Collection':
            obj_ = IndicatorCollectionType.factory()
            obj_.build(child_)
            self.Indicator_Collection.append(obj_)
# end class IndicatorListType


class BehaviorReferenceType(GeneratedsSuper):
    """The BehaviorReferenceType is intended to serve as a method for
    linking to behaviors embedded in the MAEC Bundle.The behavior_id
    attributes refers to the id of a behavior being referenced in
    the current MAEC bundle."""
    subclass = None
    superclass = None
    def __init__(self, behavior_id=None):
        self.behavior_id = _cast(None, behavior_id)
        pass
    def factory(*args_, **kwargs_):
        if BehaviorReferenceType.subclass:
            return BehaviorReferenceType.subclass(*args_, **kwargs_)
        else:
            return BehaviorReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_behavior_id(self): return self.behavior_id
    def set_behavior_id(self, behavior_id): self.behavior_id = behavior_id
    def export(self, outfile, level, namespace_='maec:', name_='BehaviorReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehaviorReferenceType'):
        if self.behavior_id is not None and 'behavior_id' not in already_processed:
            already_processed.append('behavior_id')
            outfile.write(' behavior_id=%s' % (quote_attrib(self.behavior_id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehaviorReferenceType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehaviorReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.behavior_id is not None and 'behavior_id' not in already_processed:
            already_processed.append('behavior_id')
            showIndent(outfile, level)
            outfile.write('behavior_id = %s,\n' % (self.behavior_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('behavior_id', node)
        if value is not None and 'behavior_id' not in already_processed:
            already_processed.append('behavior_id')
            self.behavior_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BehaviorReferenceType


class ObjectReferenceType(GeneratedsSuper):
    """The ObjectReferenceType is intended to serve as a method for linking
    to CyBOX Objects embedded in the MAEC Bundle.The object_id
    attribute specifies the id of a CybOX Object being referenced in
    the current MAEC Bundle."""
    subclass = None
    superclass = None
    def __init__(self, object_id=None):
        self.object_id = _cast(None, object_id)
        pass
    def factory(*args_, **kwargs_):
        if ObjectReferenceType.subclass:
            return ObjectReferenceType.subclass(*args_, **kwargs_)
        else:
            return ObjectReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_id(self): return self.object_id
    def set_object_id(self, object_id): self.object_id = object_id
    def export(self, outfile, level, namespace_='maec:', name_='ObjectReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ObjectReferenceType'):
        if self.object_id is not None and 'object_id' not in already_processed:
            already_processed.append('object_id')
            outfile.write(' object_id=%s' % (quote_attrib(self.object_id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ObjectReferenceType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.object_id is not None and 'object_id' not in already_processed:
            already_processed.append('object_id')
            showIndent(outfile, level)
            outfile.write('object_id = %s,\n' % (self.object_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('object_id', node)
        if value is not None and 'object_id' not in already_processed:
            already_processed.append('object_id')
            self.object_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ObjectReferenceType


class BehavioralActionType(ActionType):
    """The BehavioralActionType defines an action that can be used as part
    of a behavior.The behavioral_ordering attribute defines the
    ordering of the action with respect to the other actions that
    make up the behavior. So an action with a behavioral_ordering of
    "1" would come before an action with a behavioral_ordering of
    "2", etc."""
    subclass = None
    superclass = ActionType
    def __init__(self, Implementation=None, behavioral_ordering=None):
        super(BehavioralActionType, self).__init__(Implementation, )
        self.behavioral_ordering = _cast(int, behavioral_ordering)
        pass
    def factory(*args_, **kwargs_):
        if BehavioralActionType.subclass:
            return BehavioralActionType.subclass(*args_, **kwargs_)
        else:
            return BehavioralActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_behavioral_ordering(self): return self.behavioral_ordering
    def set_behavioral_ordering(self, behavioral_ordering): self.behavioral_ordering = behavioral_ordering
    def export(self, outfile, level, namespace_='maec:', name_='BehavioralActionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehavioralActionType'):
        super(BehavioralActionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionType')
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.append('behavioral_ordering')
            outfile.write(' behavioral_ordering="%s"' % self.gds_format_integer(self.behavioral_ordering, input_name='behavioral_ordering'))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehavioralActionType', fromsubclass_=False):
        super(BehavioralActionType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(BehavioralActionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehavioralActionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.append('behavioral_ordering')
            showIndent(outfile, level)
            outfile.write('behavioral_ordering = %d,\n' % (self.behavioral_ordering,))
        super(BehavioralActionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BehavioralActionType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('behavioral_ordering', node)
        if value is not None and 'behavioral_ordering' not in already_processed:
            already_processed.append('behavioral_ordering')
            try:
                self.behavioral_ordering = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.behavioral_ordering <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(BehavioralActionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BehavioralActionType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BehavioralActionType


class BehavioralActionReferenceType(cybox.ActionReferenceType):
    """The BehavioralActionReferenceType defines an action reference that
    can be used as part of a behavior.The behavioral_ordering
    attribute defines the ordering of the action with respect to the
    other actions that make up the behavior. So an action with a
    behavioral_ordering of "1" would come before an action with a
    behavioral_ordering of "2", etc."""
    subclass = None
    superclass = cybox.ActionReferenceType
    def __init__(self, action_id = None, behavioral_ordering=None):
        super(BehavioralActionReferenceType, self).__init__(action_id)
        self.behavioral_ordering = _cast(int, behavioral_ordering)
        pass
    def factory(*args_, **kwargs_):
        if BehavioralActionReferenceType.subclass:
            return BehavioralActionReferenceType.subclass(*args_, **kwargs_)
        else:
            return BehavioralActionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_behavioral_ordering(self): return self.behavioral_ordering
    def set_behavioral_ordering(self, behavioral_ordering): self.behavioral_ordering = behavioral_ordering
    def export(self, outfile, level, namespace_='maec:', name_='BehavioralActionReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehavioralActionReferenceType'):
        super(BehavioralActionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionReferenceType')
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.append('behavioral_ordering')
            outfile.write(' behavioral_ordering="%s"' % self.gds_format_integer(self.behavioral_ordering, input_name='behavioral_ordering'))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehavioralActionReferenceType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.behavioral_ordering or
            super(BehavioralActionReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehavioralActionReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.append('behavioral_ordering')
            showIndent(outfile, level)
            outfile.write('behavioral_ordering = %d,\n' % (self.behavioral_ordering,))
        super(BehavioralActionReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        super(BehavioralActionReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('behavioral_ordering', node)
        if value is not None and 'behavioral_ordering' not in already_processed:
            already_processed.append('behavioral_ordering')
            try:
                self.behavioral_ordering = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.behavioral_ordering <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BehavioralActionReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BehavioralActionReferenceType


class BehaviorReferenceListType(GeneratedsSuper):
    """The BehaviorRefereceListType is intended to capture a list of
    references to MAEC Behaviors."""
    subclass = None
    superclass = None
    def __init__(self, Behavior_Reference=None):
        if Behavior_Reference is None:
            self.Behavior_Reference = []
        else:
            self.Behavior_Reference = Behavior_Reference
    def factory(*args_, **kwargs_):
        if BehaviorReferenceListType.subclass:
            return BehaviorReferenceListType.subclass(*args_, **kwargs_)
        else:
            return BehaviorReferenceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior_Reference(self): return self.Behavior_Reference
    def set_Behavior_Reference(self, Behavior_Reference): self.Behavior_Reference = Behavior_Reference
    def add_Behavior_Reference(self, value): self.Behavior_Reference.append(value)
    def insert_Behavior_Reference(self, index, value): self.Behavior_Reference[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='BehaviorReferenceListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorReferenceListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehaviorReferenceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehaviorReferenceListType', fromsubclass_=False):
        for Behavior_Reference_ in self.Behavior_Reference:
            Behavior_Reference_.export(outfile, level, 'maec:', name_='Behavior_Reference')
    def hasContent_(self):
        if (
            self.Behavior_Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehaviorReferenceListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Behavior_Reference=[\n')
        level += 1
        for Behavior_Reference_ in self.Behavior_Reference:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorReferenceType(\n')
            Behavior_Reference_.exportLiteral(outfile, level, name_='BehaviorReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior_Reference':
            obj_ = BehaviorReferenceType.factory()
            obj_.build(child_)
            self.Behavior_Reference.append(obj_)
# end class BehaviorReferenceListType


class ActionReferenceListType(GeneratedsSuper):
    """The ActionReferenceListType is intended to capture a list of
    references to MAEC Actions."""
    subclass = None
    superclass = None
    def __init__(self, Action_Reference=None):
        if Action_Reference is None:
            self.Action_Reference = []
        else:
            self.Action_Reference = Action_Reference
    def factory(*args_, **kwargs_):
        if ActionReferenceListType.subclass:
            return ActionReferenceListType.subclass(*args_, **kwargs_)
        else:
            return ActionReferenceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Reference(self): return self.Action_Reference
    def set_Action_Reference(self, Action_Reference): self.Action_Reference = Action_Reference
    def add_Action_Reference(self, value): self.Action_Reference.append(value)
    def insert_Action_Reference(self, index, value): self.Action_Reference[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='ActionReferenceListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionReferenceListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ActionReferenceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ActionReferenceListType', fromsubclass_=False):
        for Action_Reference_ in self.Action_Reference:
            showIndent(outfile, level)
            outfile.write('<%sAction_Reference>%s</%sAction_Reference>\n' % (namespace_, self.gds_format_string(quote_xml(Action_Reference_).encode(ExternalEncoding), input_name='Action_Reference'), namespace_))
    def hasContent_(self):
        if (
            self.Action_Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionReferenceListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Reference=[\n')
        level += 1
        for Action_Reference_ in self.Action_Reference:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Action_Reference_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Reference':
            obj_ = cybox.ActionReferenceType.factory()
            obj_.build(child_)
            self.Action_Reference.append(obj_)
# end class ActionReferenceListType


class ObjectReferenceListType(GeneratedsSuper):
    """The ObjectReferenceListType is intended to capture a list of
    references to CybOX Objects."""
    subclass = None
    superclass = None
    def __init__(self, Object_Reference=None):
        if Object_Reference is None:
            self.Object_Reference = []
        else:
            self.Object_Reference = Object_Reference
    def factory(*args_, **kwargs_):
        if ObjectReferenceListType.subclass:
            return ObjectReferenceListType.subclass(*args_, **kwargs_)
        else:
            return ObjectReferenceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object_Reference(self): return self.Object_Reference
    def set_Object_Reference(self, Object_Reference): self.Object_Reference = Object_Reference
    def add_Object_Reference(self, value): self.Object_Reference.append(value)
    def insert_Object_Reference(self, index, value): self.Object_Reference[index] = value
    def export(self, outfile, level, namespace_='maec:', name_='ObjectReferenceListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectReferenceListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ObjectReferenceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ObjectReferenceListType', fromsubclass_=False):
        for Object_Reference_ in self.Object_Reference:
            Object_Reference_.export(outfile, level, 'maec:', name_='Object_Reference')
    def hasContent_(self):
        if (
            self.Object_Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectReferenceListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object_Reference=[\n')
        level += 1
        for Object_Reference_ in self.Object_Reference:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReferenceType(\n')
            Object_Reference_.exportLiteral(outfile, level, name_='ObjectReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object_Reference':
            obj_ = ObjectReferenceType.factory()
            obj_.build(child_)
            self.Object_Reference.append(obj_)
# end class ObjectReferenceListType


class ObjectCollectionType(BaseCollectionType):
    """The ObjectCollectionType complex type provides a mechanism for
    characterizing collections of actions. For instance, it can be
    used to group all of the actions that are associated with a
    specific behavior.The id attribute specifies a unique ID for
    this MAEC Object Collection. The ID must follow the pattern
    defined in the ObjectCollIDPattern simple type."""
    subclass = None
    superclass = BaseCollectionType
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, id=None, Object_List=None):
        super(ObjectCollectionType, self).__init__(name, Affinity_Type, Affinity_Degree, Description, )
        self.id = _cast(None, id)
        self.Object_List = Object_List
    def factory(*args_, **kwargs_):
        if ObjectCollectionType.subclass:
            return ObjectCollectionType.subclass(*args_, **kwargs_)
        else:
            return ObjectCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object_List(self): return self.Object_List
    def set_Object_List(self, Object_List): self.Object_List = Object_List
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='maec:', name_='ObjectCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ObjectCollectionType'):
        super(ObjectCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectCollectionType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ObjectCollectionType', fromsubclass_=False):
        super(ObjectCollectionType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Object_List is not None:
            self.Object_List.export(outfile, level, 'maec:', name_='Object_List', )
    def hasContent_(self):
        if (
            self.Object_List is not None
            #super(ObjectCollectionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        super(ObjectCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ObjectCollectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Object_List is not None:
            showIndent(outfile, level)
            outfile.write('Object_List=model_.ObjectListType(\n')
            self.Object_List.exportLiteral(outfile, level, name_='Object_List')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        super(ObjectCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object_List':
            obj_ = ObjectListType.factory()
            obj_.build(child_)
            self.set_Object_List(obj_)
        super(ObjectCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class ObjectCollectionType


class ActionCollectionType(BaseCollectionType):
    """The ActionCollectionType complex type provides a method for
    characterizing collections of actions. This can be useful for
    organizing actions that may be related and where the exact
    relationship is unknown, as well as actions whose associated
    behavior has not yet been established.The id attribute specifies
    a unique ID for this MAEC Action Collection. The ID must follow
    the pattern defined in the ActionCollIDPattern simple type."""
    subclass = None
    superclass = BaseCollectionType
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, id=None, Action_List=None):
        super(ActionCollectionType, self).__init__(name, Affinity_Type, Affinity_Degree, Description, )
        self.id = _cast(None, id)
        self.Action_List = Action_List
    def factory(*args_, **kwargs_):
        if ActionCollectionType.subclass:
            return ActionCollectionType.subclass(*args_, **kwargs_)
        else:
            return ActionCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_List(self): return self.Action_List
    def set_Action_List(self, Action_List): self.Action_List = Action_List
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='maec:', name_='ActionCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='ActionCollectionType'):
        super(ActionCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActionCollectionType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='ActionCollectionType', fromsubclass_=False):
        super(ActionCollectionType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Action_List is not None:
            self.Action_List.export(outfile, level, 'maec:', name_='Action_List', )
    def hasContent_(self):
        if (
            self.Action_List is not None or
            super(ActionCollectionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        super(ActionCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActionCollectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Action_List is not None:
            showIndent(outfile, level)
            outfile.write('Action_List=model_.ActionListType(\n')
            self.Action_List.exportLiteral(outfile, level, name_='Action_List')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        super(ActionCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_List':
            obj_ = ActionListType.factory()
            obj_.build(child_)
            self.set_Action_List(obj_)
        super(ActionCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class ActionCollectionType


class BehaviorCollectionType(BaseCollectionType):
    """The BehaviorCollectionType complex type provides a mechanism for
    characterizing collections of behaviors.The id attribute
    specifies a unique ID for this MAEC Behavior Collection. The ID
    must follow the pattern defined in the BehaviorCollIDPattern
    simple type."""
    subclass = None
    superclass = BaseCollectionType
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, id=None, Purpose=None, Behavior_List=None):
        super(BehaviorCollectionType, self).__init__(name, Affinity_Type, Affinity_Degree, Description, )
        self.id = _cast(None, id)
        self.Purpose = Purpose
        self.Behavior_List = Behavior_List
    def factory(*args_, **kwargs_):
        if BehaviorCollectionType.subclass:
            return BehaviorCollectionType.subclass(*args_, **kwargs_)
        else:
            return BehaviorCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    def get_Behavior_List(self): return self.Behavior_List
    def set_Behavior_List(self, Behavior_List): self.Behavior_List = Behavior_List
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='maec:', name_='BehaviorCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='maec:', name_='BehaviorCollectionType'):
        super(BehaviorCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorCollectionType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maec:', name_='BehaviorCollectionType', fromsubclass_=False):
        super(BehaviorCollectionType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Purpose is not None:
            showIndent(outfile, level)
            outfile.write('<%sPurpose>%s</%sPurpose>\n' % (namespace_, self.gds_format_string(quote_xml(self.Purpose).encode(ExternalEncoding), input_name='Purpose'), namespace_))
        if self.Behavior_List is not None:
            self.Behavior_List.export(outfile, level, 'maec:', name_='Behavior_List', )
    def hasContent_(self):
        if (
            self.Purpose is not None or
            self.Behavior_List is not None or
            super(BehaviorCollectionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BehaviorCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        super(BehaviorCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BehaviorCollectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Purpose is not None:
            showIndent(outfile, level)
            outfile.write('Purpose=%s,\n' % quote_python(self.Purpose).encode(ExternalEncoding))
        if self.Behavior_List is not None:
            showIndent(outfile, level)
            outfile.write('Behavior_List=model_.BehaviorListType(\n')
            self.Behavior_List.exportLiteral(outfile, level, name_='Behavior_List')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        super(BehaviorCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Purpose':
            Purpose_ = child_.text
            Purpose_ = self.gds_validate_string(Purpose_, node, 'Purpose')
            self.Purpose = Purpose_
        elif nodeName_ == 'Behavior_List':
            obj_ = BehaviorListType.factory()
            obj_.build(child_)
            self.set_Behavior_List(obj_)
        super(BehaviorCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class BehaviorCollectionType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'MAEC_Bundle'
        rootClass = BundleType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    #sys.stdout.write('<?xml version="1.0" ?>\n')
    #rootObj.export(sys.stdout, 0, name_=rootTag, 
        #namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'MAEC_Bundle'
        rootClass = BundleType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="MAEC_Bundle",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'MAEC_Bundle'
        rootClass = BundleType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from maec_2.1 import *\n\n')
    sys.stdout.write('import maec_2.1 as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "APICallType",
    "AVClassificationsType",
    "ActionCollectionType",
    "ActionImplementationType",
    "ActionListType",
    "ActionReferenceListType",
    "ActionType",
    "Action_Collections",
    "Actions",
    "Analyses",
    "AnalysisEnvironmentType",
    "AnalysisFindingsType",
    "AnalysisSubjectType",
    "AnalysisSystemType",
    "AnalysisSystemsType",
    "AnalysisType",
    "AssociatedCodeType",
    "BaseCollectionType",
    "BehaviorCollectionType",
    "BehaviorListType",
    "BehaviorPurposeType",
    "BehaviorReferenceListType",
    "BehaviorReferenceType",
    "BehaviorRelationshipType",
    "BehaviorRelationshipsType",
    "BehaviorType",
    "Behavior_Collections",
    "BehavioralActionReferenceType",
    "BehavioralActionType",
    "BehavioralActionsType",
    "Behaviors",
    "BundleType",
    "CVEVulnerabilityType",
    "Collections",
    "CommentType",
    "CommentsType",
    "HostSystemType",
    "IndicatorCollectionType",
    "IndicatorListType",
    "IndicatorType",
    "Indicator_Collections",
    "Indicators",
    "Installed_Programs",
    "ObjectCollectionType",
    "ObjectListType",
    "ObjectReferenceListType",
    "ObjectReferenceType",
    "Object_Collections",
    "Objects",
    "ParameterType",
    "ParametersType",
    "PlatformsType",
    "SourceType",
    "TargetType",
    "ToolsType",
    "VulnerabilityExploitType"
    ]
