#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Mon May 21 12:35:31 2012 by generateDS.py version 2.7b.
#

import sys
import getopt
import re as re_
from cybox.file_object_1_2 import FileObjectType
from cybox.win_file_object_1_2 import WindowsFileObjectType
from cybox.unix_file_object_1_2 import UnixFileObjectType
from cybox.win_executable_file_object_1_2 import WindowsExecutableFileObjectType
from cybox.win_driver_object_1_1 import WindowsDriverObjectType
from cybox.win_kernel_hook_object_1_2 import WindowsKernelHookObjectType
from cybox.port_object_1_2 import PortObjectType
from cybox.address_object_1_1 import AddressObjectType
from cybox.win_registry_key_object_1_2 import WindowsRegistryKeyObjectType
from cybox.process_object_1_2 import ProcessObjectType
from cybox.win_process_object_1_2 import WindowsProcessObjectType
from cybox.win_event_log_object_1_1 import WindowsEventLogObjectType
from cybox.account_object_1_1 import AccountObjectType
from cybox.user_account_object_1_1 import UserAccountObjectType
from cybox.win_user_account_object_1_2 import WindowsUserAccountObjectType
from cybox.win_service_object_1_2 import WindowsServiceObjectType
from cybox.volume_object_1_2 import VolumeObjectType
from cybox.win_volume_object_1_2 import WindowsVolumeObjectType
from cybox.disk_object_1_2 import DiskObjectType
from cybox.dns_record_object_1_0 import DNSRecordObjectType
from cybox.network_route_entry_object_1_0 import NetworkRouteEntryObjectType
from cybox.win_system_object_1_1 import WindowsSystemObjectType
from cybox.system_object_1_2 import SystemObjectType
from cybox.win_handle_object_1_2 import WindowsHandleObjectType
from cybox.memory_object_1_1 import MemoryObjectType
from cybox.disk_partition_object_1_2 import DiskPartitionObjectType
from cybox.email_message_object_1_1 import EmailMessageObjectType

etree_ = None
Verbose_import_ = True
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class ObservablesType(GeneratedsSuper):
    """The ObservablesType is a complex type representing a collection of
    cyber observables.The major_version attribute specifies the
    major version of the CybOX language utlized for this set of
    Observables.The minor_version attribute specifies the minor
    version of the CybOX language utlized for this set of
    Observables."""
    subclass = None
    superclass = None
    def __init__(self, major_version=None, minor_version=None, Observable_Package_Source=None, Observable=None, Pools=None, extensiontype_=None):
        self.major_version = _cast(None, major_version)
        self.minor_version = _cast(None, minor_version)
        self.Observable_Package_Source = Observable_Package_Source
        if Observable is None:
            self.Observable = []
        else:
            self.Observable = Observable
        self.Pools = Pools
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ObservablesType.subclass:
            return ObservablesType.subclass(*args_, **kwargs_)
        else:
            return ObservablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Observable_Package_Source(self): return self.Observable_Package_Source
    def set_Observable_Package_Source(self, Observable_Package_Source): self.Observable_Package_Source = Observable_Package_Source
    def get_Observable(self): return self.Observable
    def set_Observable(self, Observable): self.Observable = Observable
    def add_Observable(self, value): self.Observable.append(value)
    def insert_Observable(self, index, value): self.Observable[index] = value
    def get_Pools(self): return self.Pools
    def set_Pools(self, Pools): self.Pools = Pools
    def get_major_version(self): return self.major_version
    def set_major_version(self, major_version): self.major_version = major_version
    def get_minor_version(self): return self.minor_version
    def set_minor_version(self, minor_version): self.minor_version = minor_version
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='cybox:', name_='ObservablesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservablesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='ObservablesType'):
        if self.major_version is not None and 'major_version' not in already_processed:
            already_processed.append('major_version')
            outfile.write(' major_version=%s' % (self.gds_format_string(quote_attrib(self.major_version).encode(ExternalEncoding), input_name='major_version'), ))
        if self.minor_version is not None and 'minor_version' not in already_processed:
            already_processed.append('minor_version')
            outfile.write(' minor_version=%s' % (self.gds_format_string(quote_attrib(self.minor_version).encode(ExternalEncoding), input_name='minor_version'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='ObservablesType', fromsubclass_=False):
        if self.Observable_Package_Source is not None:
            showIndent(outfile, level)
            outfile.write('<%sObservable_Package_Source>%s</%sObservable_Package_Source>\n' % (namespace_, self.gds_format_string(quote_xml(self.Observable_Package_Source).encode(ExternalEncoding), input_name='Observable_Package_Source'), namespace_))
        for Observable_ in self.Observable:
            Observable_.export(outfile, level, namespace_, name_='Observable')
        if self.Pools is not None:
            self.Pools.export(outfile, level, namespace_, name_='Pools')
    def hasContent_(self):
        if (
            self.Observable_Package_Source is not None or
            self.Observable or
            self.Pools is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObservablesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.major_version is not None and 'major_version' not in already_processed:
            already_processed.append('major_version')
            showIndent(outfile, level)
            outfile.write('major_version = "%s",\n' % (self.major_version,))
        if self.minor_version is not None and 'minor_version' not in already_processed:
            already_processed.append('minor_version')
            showIndent(outfile, level)
            outfile.write('minor_version = "%s",\n' % (self.minor_version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Observable_Package_Source is not None:
            showIndent(outfile, level)
            outfile.write('Observable_Package_Source=%s,\n' % quote_python(self.Observable_Package_Source).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Observable=[\n')
        level += 1
        for Observable_ in self.Observable:
            showIndent(outfile, level)
            outfile.write('model_.Observable(\n')
            Observable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Pools is not None:
            showIndent(outfile, level)
            outfile.write('Pools=model_.PoolsType(\n')
            self.Pools.exportLiteral(outfile, level, name_='Pools')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('major_version', node)
        if value is not None and 'major_version' not in already_processed:
            already_processed.append('major_version')
            self.major_version = value
        value = find_attr_value_('minor_version', node)
        if value is not None and 'minor_version' not in already_processed:
            already_processed.append('minor_version')
            self.minor_version = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Observable_Package_Source':
            Observable_Package_Source_ = child_.text
            Observable_Package_Source_ = self.gds_validate_string(Observable_Package_Source_, node, 'Observable_Package_Source')
            self.Observable_Package_Source = Observable_Package_Source_
        elif nodeName_ == 'Observable':
            obj_ = ObservableType.factory()
            obj_.build(child_)
            self.Observable.append(obj_)
        elif nodeName_ == 'Pools':
            obj_ = PoolsType.factory()
            obj_.build(child_)
            self.set_Pools(obj_)
# end class ObservablesType


class ObservableType(GeneratedsSuper):
    """The ObservableType is a complex type representing a description of a
    single cyber observable.The id attribute specifies a unique id
    for this Observable.The idref attribute specifies a unique id
    reference to an Observable defined elsewhere."""
    subclass = None
    superclass = None
    def __init__(self, idref=None, id=None, Title=None, Description=None, Keywords=None, Observable_Source=None, Stateful_Measure=None, Event=None, Observable_Composition=None, Delta=None, Noisiness=None, Ease_of_Obfuscation=None, Obfuscation_Techniques=None):
        self.idref = _cast(None, idref)
        self.id = _cast(None, id)
        self.Title = Title
        self.Description = Description
        if Keywords is None:
            self.Keywords = []
        else:
            self.Keywords = Keywords
        self.Observable_Source = Observable_Source
        self.Stateful_Measure = Stateful_Measure
        self.Event = Event
        self.Observable_Composition = Observable_Composition
        self.Delta = Delta
        self.Noisiness = Noisiness
        self.Ease_of_Obfuscation = Ease_of_Obfuscation
        self.Obfuscation_Techniques = Obfuscation_Techniques
    def factory(*args_, **kwargs_):
        if ObservableType.subclass:
            return ObservableType.subclass(*args_, **kwargs_)
        else:
            return ObservableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Keywords(self): return self.Keywords
    def set_Keywords(self, Keywords): self.Keywords = Keywords
    def add_Keywords(self, value): self.Keywords.append(value)
    def insert_Keywords(self, index, value): self.Keywords[index] = value
    def get_Observable_Source(self): return self.Observable_Source
    def set_Observable_Source(self, Observable_Source): self.Observable_Source = Observable_Source
    def get_Stateful_Measure(self): return self.Stateful_Measure
    def set_Stateful_Measure(self, Stateful_Measure): self.Stateful_Measure = Stateful_Measure
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def get_Observable_Composition(self): return self.Observable_Composition
    def set_Observable_Composition(self, Observable_Composition): self.Observable_Composition = Observable_Composition
    def get_Delta(self): return self.Delta
    def set_Delta(self, Delta): self.Delta = Delta
    def get_Noisiness(self): return self.Noisiness
    def set_Noisiness(self, Noisiness): self.Noisiness = Noisiness
    def get_Ease_of_Obfuscation(self): return self.Ease_of_Obfuscation
    def set_Ease_of_Obfuscation(self, Ease_of_Obfuscation): self.Ease_of_Obfuscation = Ease_of_Obfuscation
    def get_Obfuscation_Techniques(self): return self.Obfuscation_Techniques
    def set_Obfuscation_Techniques(self, Obfuscation_Techniques): self.Obfuscation_Techniques = Obfuscation_Techniques
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_ID(self): return self.id
    def set_ID(self, id): self.id = id
    def export(self, outfile, level, namespace_='cybox:', name_='ObservableType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservableType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='ObservableType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='ObservableType', fromsubclass_=False):
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('<%sTitle>%s</%sTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        for Keywords_ in self.Keywords:
            showIndent(outfile, level)
            outfile.write('<%sKeywords>%s</%sKeywords>\n' % (namespace_, self.gds_format_string(quote_xml(Keywords_).encode(ExternalEncoding), input_name='Keywords'), namespace_))
        if self.Observable_Source is not None:
            showIndent(outfile, level)
            outfile.write('<%sObservable_Source>%s</%sObservable_Source>\n' % (namespace_, self.gds_format_string(quote_xml(self.Observable_Source).encode(ExternalEncoding), input_name='Observable_Source'), namespace_))
        if self.Stateful_Measure is not None:
            self.Stateful_Measure.export(outfile, level, namespace_, name_='Stateful_Measure')
        if self.Event is not None:
            self.Event.export(outfile, level, namespace_, name_='Event')
        if self.Observable_Composition is not None:
            self.Observable_Composition.export(outfile, level, namespace_, name_='Observable_Composition')
        if self.Delta is not None:
            self.Delta.export(outfile, level, namespace_, name_='Delta')
        if self.Noisiness is not None:
            showIndent(outfile, level)
            outfile.write('<%sNoisiness>%s</%sNoisiness>\n' % (namespace_, self.gds_format_string(quote_xml(self.Noisiness).encode(ExternalEncoding), input_name='Noisiness'), namespace_))
        if self.Ease_of_Obfuscation is not None:
            showIndent(outfile, level)
            outfile.write('<%sEase_of_Obfuscation>%s</%sEase_of_Obfuscation>\n' % (namespace_, self.gds_format_string(quote_xml(self.Ease_of_Obfuscation).encode(ExternalEncoding), input_name='Ease_of_Obfuscation'), namespace_))
        if self.Obfuscation_Techniques is not None:
            self.Obfuscation_Techniques.export(outfile, level, namespace_, name_='Obfuscation_Techniques')
    def hasContent_(self):
        if (
            self.Title is not None or
            self.Description is not None or
            self.Keywords or
            self.Observable_Source is not None or
            self.Stateful_Measure is not None or
            self.Event is not None or
            self.Observable_Composition is not None or
            self.Delta is not None or
            self.Noisiness is not None or
            self.Ease_of_Obfuscation is not None or
            self.Obfuscation_Techniques is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObservableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            showIndent(outfile, level)
            outfile.write('idref = %s,\n' % (self.idref,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Keywords=[\n')
        level += 1
        for Keywords_ in self.Keywords:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Keywords_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Observable_Source is not None:
            showIndent(outfile, level)
            outfile.write('Observable_Source=%s,\n' % quote_python(self.Observable_Source).encode(ExternalEncoding))
        if self.Stateful_Measure is not None:
            showIndent(outfile, level)
            outfile.write('Stateful_Measure=model_.StatefulMeasureType(\n')
            self.Stateful_Measure.exportLiteral(outfile, level, name_='Stateful_Measure')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Event is not None:
            showIndent(outfile, level)
            outfile.write('Event=model_.Event(\n')
            self.Event.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observable_Composition is not None:
            showIndent(outfile, level)
            outfile.write('Observable_Composition=model_.Observable_CompositionType(\n')
            self.Observable_Composition.exportLiteral(outfile, level, name_='Observable_Composition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Delta is not None:
            showIndent(outfile, level)
            outfile.write('Delta=model_.Delta(\n')
            self.Delta.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Noisiness is not None:
            showIndent(outfile, level)
            outfile.write('Noisiness=%s,\n' % quote_python(self.Noisiness).encode(ExternalEncoding))
        if self.Ease_of_Obfuscation is not None:
            showIndent(outfile, level)
            outfile.write('Ease_of_Obfuscation=%s,\n' % quote_python(self.Ease_of_Obfuscation).encode(ExternalEncoding))
        if self.Obfuscation_Techniques is not None:
            showIndent(outfile, level)
            outfile.write('Obfuscation_Techniques=model_.Obfuscation_Techniques(\n')
            self.Obfuscation_Techniques.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            self.idref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Keywords':
            Keywords_ = child_.text
            Keywords_ = self.gds_validate_string(Keywords_, node, 'Keywords')
            self.Keywords.append(Keywords_)
        elif nodeName_ == 'Observable_Source':
            Observable_Source_ = child_.text
            Observable_Source_ = self.gds_validate_string(Observable_Source_, node, 'Observable_Source')
            self.Observable_Source = Observable_Source_
        elif nodeName_ == 'Stateful_Measure':
            obj_ = StatefulMeasureType.factory()
            obj_.build(child_)
            self.set_Stateful_Measure(obj_)
        elif nodeName_ == 'Event':
            obj_ = EventType.factory()
            obj_.build(child_)
            self.set_Event(obj_)
        elif nodeName_ == 'Observable_Composition':
            obj_ = Observable_CompositionType.factory()
            obj_.build(child_)
            self.set_Observable_Composition(obj_)
        elif nodeName_ == 'Delta':
            obj_ = Delta.factory()
            obj_.build(child_)
            self.set_Delta(obj_)
        elif nodeName_ == 'Noisiness':
            Noisiness_ = child_.text
            Noisiness_ = self.gds_validate_string(Noisiness_, node, 'Noisiness')
            self.Noisiness = Noisiness_
        elif nodeName_ == 'Ease_of_Obfuscation':
            Ease_of_Obfuscation_ = child_.text
            Ease_of_Obfuscation_ = self.gds_validate_string(Ease_of_Obfuscation_, node, 'Ease_of_Obfuscation')
            self.Ease_of_Obfuscation = Ease_of_Obfuscation_
        elif nodeName_ == 'Obfuscation_Techniques':
            obj_ = Obfuscation_Techniques.factory()
            obj_.build(child_)
            self.set_Obfuscation_Techniques(obj_)
# end class ObservableType


class Delta(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Change=None, Trend=None, Frequency=None):
        self.Change = Change
        self.Trend = Trend
        self.Frequency = Frequency
    def factory(*args_, **kwargs_):
        if Delta.subclass:
            return Delta.subclass(*args_, **kwargs_)
        else:
            return Delta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Change(self): return self.Change
    def set_Change(self, Change): self.Change = Change
    def get_Trend(self): return self.Trend
    def set_Trend(self, Trend): self.Trend = Trend
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    def export(self, outfile, level, namespace_='cybox:', name_='Delta', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Delta')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Delta'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Delta', fromsubclass_=False):
        if self.Change is not None:
            showIndent(outfile, level)
            outfile.write('<%sChange>%s</%sChange>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.Change)), input_name='Change'), namespace_))
        if self.Trend is not None:
            showIndent(outfile, level)
            outfile.write('<%sTrend>%s</%sTrend>\n' % (namespace_, self.gds_format_string(quote_xml(self.Trend).encode(ExternalEncoding), input_name='Trend'), namespace_))
        if self.Frequency is not None:
            self.Frequency.export(outfile, level, namespace_, name_='Frequency', )
    def hasContent_(self):
        if (
            self.Change is not None or
            self.Trend is not None or
            self.Frequency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Delta'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Change is not None:
            showIndent(outfile, level)
            outfile.write('Change=%s,\n' % self.Change)
        if self.Trend is not None:
            showIndent(outfile, level)
            outfile.write('Trend=%s,\n' % quote_python(self.Trend).encode(ExternalEncoding))
        if self.Frequency is not None:
            showIndent(outfile, level)
            outfile.write('Frequency=model_.Frequency(\n')
            self.Frequency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Change':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Change')
            self.Change = ival_
        elif nodeName_ == 'Trend':
            Trend_ = child_.text
            Trend_ = self.gds_validate_string(Trend_, node, 'Trend')
            self.Trend = Trend_
        elif nodeName_ == 'Frequency':
            obj_ = Frequency.factory()
            obj_.build(child_)
            self.set_Frequency(obj_)
# end class Delta


class Trend(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Trend.subclass:
            return Trend.subclass(*args_, **kwargs_)
        else:
            return Trend(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='cybox:', name_='Trend', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Trend')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Trend'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Trend', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Trend'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Trend


class Frequency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Units=None, Rate=None, Scale=None):
        self.Units = _cast(None, Units)
        self.Rate = _cast(float, Rate)
        self.Scale = _cast(None, Scale)
        pass
    def factory(*args_, **kwargs_):
        if Frequency.subclass:
            return Frequency.subclass(*args_, **kwargs_)
        else:
            return Frequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_Rate(self): return self.Rate
    def set_Rate(self, Rate): self.Rate = Rate
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def export(self, outfile, level, namespace_='cybox:', name_='Frequency', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Frequency')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Frequency'):
        if self.Units is not None and 'Units' not in already_processed:
            already_processed.append('Units')
            outfile.write(' Units=%s' % (self.gds_format_string(quote_attrib(self.Units).encode(ExternalEncoding), input_name='Units'), ))
        if self.Rate is not None and 'Rate' not in already_processed:
            already_processed.append('Rate')
            outfile.write(' Rate="%s"' % self.gds_format_float(self.Rate, input_name='Rate'))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (self.gds_format_string(quote_attrib(self.Scale).encode(ExternalEncoding), input_name='Scale'), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Frequency', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Frequency'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Units is not None and 'Units' not in already_processed:
            already_processed.append('Units')
            showIndent(outfile, level)
            outfile.write('Units = "%s",\n' % (self.Units,))
        if self.Rate is not None and 'Rate' not in already_processed:
            already_processed.append('Rate')
            showIndent(outfile, level)
            outfile.write('Rate = %f,\n' % (self.Rate,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = "%s",\n' % (self.Scale,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Units', node)
        if value is not None and 'Units' not in already_processed:
            already_processed.append('Units')
            self.Units = value
        value = find_attr_value_('Rate', node)
        if value is not None and 'Rate' not in already_processed:
            already_processed.append('Rate')
            try:
                self.Rate = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (Rate): %s' % exp)
        value = find_attr_value_('Scale', node)
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Frequency


class Noisiness(GeneratedsSuper):
    """The Noisiness element is optional and enables simple
    characterization of how noisy this Observable typically could
    be. In other words, how likely is it to generate false
    positives."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Noisiness.subclass:
            return Noisiness.subclass(*args_, **kwargs_)
        else:
            return Noisiness(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='cybox:', name_='Noisiness', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Noisiness')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Noisiness'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Noisiness', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Noisiness'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Noisiness


class Ease_of_Obfuscation(GeneratedsSuper):
    """The Ease_of_Obfuscation element is optional and enables simple
    characterization of how easy it would be for an attacker to
    obfuscate the observability of this Observable."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Ease_of_Obfuscation.subclass:
            return Ease_of_Obfuscation.subclass(*args_, **kwargs_)
        else:
            return Ease_of_Obfuscation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='cybox:', name_='Ease_of_Obfuscation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Ease_of_Obfuscation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Ease_of_Obfuscation'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Ease_of_Obfuscation', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Ease_of_Obfuscation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Ease_of_Obfuscation


class Obfuscation_Techniques(GeneratedsSuper):
    """The Obfuscation_Techniques element is optional and enables the
    description of potential techniques an attacker could leverage
    to obfuscate the observability of this Observable."""
    subclass = None
    superclass = None
    def __init__(self, Obfuscation_Technique=None):
        if Obfuscation_Technique is None:
            self.Obfuscation_Technique = []
        else:
            self.Obfuscation_Technique = Obfuscation_Technique
    def factory(*args_, **kwargs_):
        if Obfuscation_Techniques.subclass:
            return Obfuscation_Techniques.subclass(*args_, **kwargs_)
        else:
            return Obfuscation_Techniques(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Obfuscation_Technique(self): return self.Obfuscation_Technique
    def set_Obfuscation_Technique(self, Obfuscation_Technique): self.Obfuscation_Technique = Obfuscation_Technique
    def add_Obfuscation_Technique(self, value): self.Obfuscation_Technique.append(value)
    def insert_Obfuscation_Technique(self, index, value): self.Obfuscation_Technique[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Obfuscation_Techniques', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Obfuscation_Techniques')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Obfuscation_Techniques'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Obfuscation_Techniques', fromsubclass_=False):
        for Obfuscation_Technique_ in self.Obfuscation_Technique:
            Obfuscation_Technique_.export(outfile, level, namespace_, name_='Obfuscation_Technique')
    def hasContent_(self):
        if (
            self.Obfuscation_Technique
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Obfuscation_Techniques'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Obfuscation_Technique=[\n')
        level += 1
        for Obfuscation_Technique_ in self.Obfuscation_Technique:
            showIndent(outfile, level)
            outfile.write('model_.Obfuscation_Technique(\n')
            Obfuscation_Technique_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Obfuscation_Technique':
            obj_ = Obfuscation_Technique.factory()
            obj_.build(child_)
            self.Obfuscation_Technique.append(obj_)
# end class Obfuscation_Techniques


class Obfuscation_Technique(GeneratedsSuper):
    """The Obfuscation_Technique element is optional and enables the
    description of a single potential technique an attacker could
    leverage to obfuscate the observability of this Observable."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Observables=None):
        self.Description = Description
        self.Observables = Observables
    def factory(*args_, **kwargs_):
        if Obfuscation_Technique.subclass:
            return Obfuscation_Technique.subclass(*args_, **kwargs_)
        else:
            return Obfuscation_Technique(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def export(self, outfile, level, namespace_='cybox:', name_='Obfuscation_Technique', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Obfuscation_Technique')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Obfuscation_Technique'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Obfuscation_Technique', fromsubclass_=False):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables')
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Obfuscation_Technique'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Observables':
            class_obj_ = self.get_class_obj_(child_, ObservablesType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class Obfuscation_Technique


class Observable_CompositionType(GeneratedsSuper):
    """The Operator attribute enables the specification of complex
    compositional cyber observables by providing logical operators
    for defining interrelationships between constituent cyber
    observables defined utilizing the recursive Observable element."""
    subclass = None
    superclass = None
    def __init__(self, Operator=None, Observable=None):
        self.Operator = _cast(None, Operator)
        if Observable is None:
            self.Observable = []
        else:
            self.Observable = Observable
    def factory(*args_, **kwargs_):
        if Observable_CompositionType.subclass:
            return Observable_CompositionType.subclass(*args_, **kwargs_)
        else:
            return Observable_CompositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Observable(self): return self.Observable
    def set_Observable(self, Observable): self.Observable = Observable
    def add_Observable(self, value): self.Observable.append(value)
    def insert_Observable(self, index, value): self.Observable[index] = value
    def get_Operator(self): return self.Operator
    def set_Operator(self, Operator): self.Operator = Operator
    def export(self, outfile, level, namespace_='cybox:', name_='Observable_CompositionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Observable_CompositionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Observable_CompositionType'):
        if self.Operator is not None and 'Operator' not in already_processed:
            already_processed.append('Operator')
            outfile.write(' Operator=%s' % (quote_attrib(self.Operator), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Observable_CompositionType', fromsubclass_=False):
        for Observable_ in self.Observable:
            Observable_.export(outfile, level, namespace_, name_='Observable')
    def hasContent_(self):
        if (
            self.Observable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Observable_CompositionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Operator is not None and 'Operator' not in already_processed:
            already_processed.append('Operator')
            showIndent(outfile, level)
            outfile.write('Operator = %s,\n' % (self.Operator,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Observable=[\n')
        level += 1
        for Observable_ in self.Observable:
            showIndent(outfile, level)
            outfile.write('model_.ObservableType(\n')
            Observable_.exportLiteral(outfile, level, name_='ObservableType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.append('operator')
            self.Operator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Observable':
            obj_ = ObservableType.factory()
            obj_.build(child_)
            self.Observable.append(obj_)
# end class Observable_CompositionType


class StatefulMeasureType(GeneratedsSuper):
    """The StatefulMeasureType is a complex type representing a cyber
    observable property that is statically stateful in nature (e.g.
    a registry key holding a certain value, a specific mutex
    existing or a file having a specific MD5 hash). The Name
    attribute is optional and enables the assignment of a relevant
    name to a specific Stateful Measure."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Description=None, Object=None):
        self.Name = _cast(None, Name)
        self.Description = Description
        self.Object = Object
    def factory(*args_, **kwargs_):
        if StatefulMeasureType.subclass:
            return StatefulMeasureType.subclass(*args_, **kwargs_)
        else:
            return StatefulMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='cybox:', name_='StatefulMeasureType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StatefulMeasureType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='StatefulMeasureType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='StatefulMeasureType', fromsubclass_=False):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.Object is not None:
            self.Object.export(outfile, level, namespace_, name_='Object', )
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Object is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StatefulMeasureType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('Object=model_.Object(\n')
            self.Object.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Object':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Object(obj_)
# end class StatefulMeasureType


class EventType(GeneratedsSuper):
    """The EventType is a complex type representing a cyber observable
    event that is dynamic in nature with specific action(s) taken
    against specific cyber relevant objects (e.g. a file is deleted,
    a registry key is created or an HTTP Get Request is
    received).The id attribute specifies a unique id for this
    Event.The idref attribute specifies a unique id reference to an
    Event defined elsewhere.The Type attribute specifies what kind
    of Event this is."""
    subclass = None
    superclass = None
    def __init__(self, idref=None, Type=None, id=None, Description=None, Producer_Observer=None, Actions=None, Event=None):
        self.idref = _cast(None, idref)
        self.Type = _cast(None, Type)
        self.id = _cast(None, id)
        self.Description = Description
        self.Producer_Observer = Producer_Observer
        self.Actions = Actions
        self.Event = Event
    def factory(*args_, **kwargs_):
        if EventType.subclass:
            return EventType.subclass(*args_, **kwargs_)
        else:
            return EventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Producer_Observer(self): return self.Producer_Observer
    def set_Producer_Observer(self, Producer_Observer): self.Producer_Observer = Producer_Observer
    def get_Actions(self): return self.Actions
    def set_Actions(self, Actions): self.Actions = Actions
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.id
    def set_ID(self, id): self.id = id
    def export(self, outfile, level, namespace_='cybox:', name_='EventType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='EventType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='EventType', fromsubclass_=False):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.Producer_Observer is not None:
            showIndent(outfile, level)
            outfile.write('<%sProducer-Observer>%s</%sProducer-Observer>\n' % (namespace_, self.gds_format_string(quote_xml(self.Producer_Observer).encode(ExternalEncoding), input_name='Producer-Observer'), namespace_))
        if self.Actions is not None:
            self.Actions.export(outfile, level, namespace_, name_='Actions')
        if self.Event is not None:
            self.Event.export(outfile, level, namespace_, name_='Event', )
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Producer_Observer is not None or
            self.Actions is not None or
            self.Event is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EventType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            showIndent(outfile, level)
            outfile.write('idref = %s,\n' % (self.idref,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Producer_Observer is not None:
            showIndent(outfile, level)
            outfile.write('Producer_Observer=%s,\n' % quote_python(self.Producer_Observer).encode(ExternalEncoding))
        if self.Actions is not None:
            showIndent(outfile, level)
            outfile.write('Actions=model_.Actions(\n')
            self.Actions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Event is not None:
            showIndent(outfile, level)
            outfile.write('Event=model_.EventType(\n')
            self.Event.exportLiteral(outfile, level, name_='Event')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            self.idref = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Producer-Observer':
            Producer_Observer_ = child_.text
            Producer_Observer_ = self.gds_validate_string(Producer_Observer_, node, 'Producer_Observer')
            self.Producer_Observer = Producer_Observer_
        elif nodeName_ == 'Actions':
            obj_ = Actions.factory()
            obj_.build(child_)
            self.set_Actions(obj_)
        elif nodeName_ == 'Event':
            obj_ = EventType.factory()
            obj_.build(child_)
            self.set_Event(obj_)
# end class EventType


class Actions(GeneratedsSuper):
    """The Actions element enables description/specification of one or more
    cyber observable actions."""
    subclass = None
    superclass = None
    def __init__(self, Action=None):
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
    def factory(*args_, **kwargs_):
        if Actions.subclass:
            return Actions.subclass(*args_, **kwargs_)
        else:
            return Actions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Actions', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Actions')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Actions'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Actions', fromsubclass_=False):
        for Action_ in self.Action:
            Action_.export(outfile, level, namespace_, name_='Action')
    def hasContent_(self):
        if (
            self.Action
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Actions'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.Action(\n')
            Action_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            obj_ = ActionType.factory()
            obj_.build(child_)
            self.Action.append(obj_)
# end class Actions


class ActionType(GeneratedsSuper):
    """The ActionType is a complex type representing a single cyber
    observable action.The id attribute specifies a unique id for
    this Action.The idref attribute specifies a unique id reference
    to an Action defined elsewhere.The Type attribute specifies the
    basic type of action performed.The ordinal_position attribute is
    intended to reference the ordinal position of the action with
    within a series of actions.The Action_Status attribute enables
    description of the status of the action being described.The
    Context attribute is optional and enables simple
    characterization of the broad operational context in which the
    Action is relevantThe NetworkProtocol attribute is optional and
    (where the Context is Network) enables the description of the
    relevant network protocol involved in the Action.The timestamp
    attribute represents the local or relative time at which the
    action occurred or was observed. The "any" attribute enables the
    capture of custom attributes describing this Action."""
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, Action_Status=None, ordinal_position=None, NetworkProtocol=None, Context=None, idref=None, Type=None, id=None, Action_Name=None, Description=None, Action_Aliases=None, Action_Arguments=None, Discovery_Method=None, Associated_Objects=None, Relationships=None):
        self.timestamp = _cast(None, timestamp)
        self.Action_Status = _cast(None, Action_Status)
        self.ordinal_position = _cast(int, ordinal_position)
        self.NetworkProtocol = _cast(None, NetworkProtocol)
        self.Context = _cast(None, Context)
        self.idref = _cast(None, idref)
        self.Type = _cast(None, Type)
        self.id = _cast(None, id)
        self.Action_Name = Action_Name
        self.Description = Description
        self.Action_Aliases = Action_Aliases
        self.Action_Arguments = Action_Arguments
        self.Discovery_Method = Discovery_Method
        self.Associated_Objects = Associated_Objects
        self.Relationships = Relationships
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ActionType.subclass:
            return ActionType.subclass(*args_, **kwargs_)
        else:
            return ActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Name(self): return self.Action_Name
    def set_Action_Name(self, Action_Name): self.Action_Name = Action_Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Action_Aliases(self): return self.Action_Aliases
    def set_Action_Aliases(self, Action_Aliases): self.Action_Aliases = Action_Aliases
    def get_Action_Arguments(self): return self.Action_Arguments
    def set_Action_Arguments(self, Action_Arguments): self.Action_Arguments = Action_Arguments
    def get_Discovery_Method(self): return self.Discovery_Method
    def set_Discovery_Method(self, Discovery_Method): self.Discovery_Method = Discovery_Method
    def get_Associated_Objects(self): return self.Associated_Objects
    def set_Associated_Objects(self, Associated_Objects): self.Associated_Objects = Associated_Objects
    def get_Relationships(self): return self.Relationships
    def set_Relationships(self, Relationships): self.Relationships = Relationships
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_Action_Status(self): return self.Action_Status
    def set_Action_Status(self, Action_Status): self.Action_Status = Action_Status
    def get_ordinal_position(self): return self.ordinal_position
    def set_ordinal_position(self, ordinal_position): self.ordinal_position = ordinal_position
    def get_NetworkProtocol(self): return self.NetworkProtocol
    def set_NetworkProtocol(self, NetworkProtocol): self.NetworkProtocol = NetworkProtocol
    def get_Context(self): return self.Context
    def set_Context(self, Context): self.Context = Context
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.id
    def set_ID(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='cybox:', name_='ActionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='ActionType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            outfile.write(' timestamp=%s' % (self.gds_format_string(quote_attrib(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), ))
        if self.Action_Status is not None and 'Action_Status' not in already_processed:
            already_processed.append('Action_Status')
            outfile.write(' Action_Status=%s' % (quote_attrib(self.Action_Status), ))
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.append('ordinal_position')
            outfile.write(' ordinal_position="%s"' % self.gds_format_integer(self.ordinal_position, input_name='ordinal_position'))
        if self.NetworkProtocol is not None and 'NetworkProtocol' not in already_processed:
            already_processed.append('NetworkProtocol')
            outfile.write(' NetworkProtocol=%s' % (quote_attrib(self.NetworkProtocol), ))
        if self.Context is not None and 'Context' not in already_processed:
            already_processed.append('Context')
            outfile.write(' Context=%s' % (quote_attrib(self.Context), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='ActionType', fromsubclass_=False):
        if self.Action_Name is not None:
            self.Action_Name.export(outfile, level, namespace_, name_='Action_Name')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.Action_Aliases is not None:
            self.Action_Aliases.export(outfile, level, namespace_, name_='Action_Aliases')
        if self.Action_Arguments is not None:
            self.Action_Arguments.export(outfile, level, namespace_, name_='Action_Arguments')
        if self.Discovery_Method is not None:
            showIndent(outfile, level)
            outfile.write('<%sDiscovery_Method>%s</%sDiscovery_Method>\n' % (namespace_, self.gds_format_string(quote_xml(self.Discovery_Method).encode(ExternalEncoding), input_name='Discovery_Method'), namespace_))
        if self.Associated_Objects is not None:
            self.Associated_Objects.export(outfile, level, namespace_, name_='Associated_Objects')
        if self.Relationships is not None:
            self.Relationships.export(outfile, level, namespace_, name_='Relationships')
    def hasContent_(self):
        if (
            self.Action_Name is not None or
            self.Description is not None or
            self.Action_Aliases is not None or
            self.Action_Arguments is not None or
            self.Discovery_Method is not None or
            self.Associated_Objects is not None or
            self.Relationships is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            showIndent(outfile, level)
            outfile.write('timestamp = "%s",\n' % (self.timestamp,))
        if self.Action_Status is not None and 'Action_Status' not in already_processed:
            already_processed.append('Action_Status')
            showIndent(outfile, level)
            outfile.write('Action_Status = %s,\n' % (self.Action_Status,))
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.append('ordinal_position')
            showIndent(outfile, level)
            outfile.write('ordinal_position = %d,\n' % (self.ordinal_position,))
        if self.NetworkProtocol is not None and 'NetworkProtocol' not in already_processed:
            already_processed.append('NetworkProtocol')
            showIndent(outfile, level)
            outfile.write('NetworkProtocol = %s,\n' % (self.NetworkProtocol,))
        if self.Context is not None and 'Context' not in already_processed:
            already_processed.append('Context')
            showIndent(outfile, level)
            outfile.write('Context = %s,\n' % (self.Context,))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            showIndent(outfile, level)
            outfile.write('idref = %s,\n' % (self.idref,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Action_Name is not None:
            showIndent(outfile, level)
            outfile.write('Action_Name=model_.Action_Name(\n')
            self.Action_Name.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Action_Aliases is not None:
            showIndent(outfile, level)
            outfile.write('Action_Aliases=model_.Action_Aliases(\n')
            self.Action_Aliases.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action_Arguments is not None:
            showIndent(outfile, level)
            outfile.write('Action_Arguments=model_.Action_Arguments(\n')
            self.Action_Arguments.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discovery_Method is not None:
            showIndent(outfile, level)
            outfile.write('Discovery_Method=%s,\n' % quote_python(self.Discovery_Method).encode(ExternalEncoding))
        if self.Associated_Objects is not None:
            showIndent(outfile, level)
            outfile.write('Associated_Objects=model_.Associated_Objects(\n')
            self.Associated_Objects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationships is not None:
            showIndent(outfile, level)
            outfile.write('Relationships=model_.Relationships(\n')
            self.Relationships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            self.timestamp = value
        value = find_attr_value_('Action_Status', node)
        if value is not None and 'Action_Status' not in already_processed:
            already_processed.append('Action_Status')
            self.Action_Status = value
        value = find_attr_value_('ordinal_position', node)
        if value is not None and 'ordinal_position' not in already_processed:
            already_processed.append('ordinal_position')
            try:
                self.ordinal_position = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ordinal_position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('NetworkProtocol', node)
        if value is not None and 'NetworkProtocol' not in already_processed:
            already_processed.append('NetworkProtocol')
            self.NetworkProtocol = value
        value = find_attr_value_('Context', node)
        if value is not None and 'Context' not in already_processed:
            already_processed.append('Context')
            self.Context = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            self.idref = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Name':
            obj_ = Action_Name.factory()
            obj_.build(child_)
            self.set_Action_Name(obj_)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Action_Aliases':
            obj_ = Action_Aliases.factory()
            obj_.build(child_)
            self.set_Action_Aliases(obj_)
        elif nodeName_ == 'Action_Arguments':
            obj_ = Action_Arguments.factory()
            obj_.build(child_)
            self.set_Action_Arguments(obj_)
        elif nodeName_ == 'Discovery_Method':
            Discovery_Method_ = child_.text
            Discovery_Method_ = self.gds_validate_string(Discovery_Method_, node, 'Discovery_Method')
            self.Discovery_Method = Discovery_Method_
        elif nodeName_ == 'Associated_Objects':
            obj_ = Associated_Objects.factory()
            obj_.build(child_)
            self.set_Associated_Objects(obj_)
        elif nodeName_ == 'Relationships':
            obj_ = Relationships.factory()
            obj_.build(child_)
            self.set_Relationships(obj_)
# end class ActionType


class Action_Name(GeneratedsSuper):
    """The Action_Name element is optional and identifies/characterizes the
    specific action performed."""
    subclass = None
    superclass = None
    def __init__(self, Defined_Name=None, Undefined_Name=None):
        self.Defined_Name = Defined_Name
        self.Undefined_Name = Undefined_Name
    def factory(*args_, **kwargs_):
        if Action_Name.subclass:
            return Action_Name.subclass(*args_, **kwargs_)
        else:
            return Action_Name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Defined_Name(self): return self.Defined_Name
    def set_Defined_Name(self, Defined_Name): self.Defined_Name = Defined_Name
    def validate_DefinedActionNameEnum(self, value):
        # Validate type DefinedActionNameEnum, a restriction on xs:string.
        pass
    def get_Undefined_Name(self): return self.Undefined_Name
    def set_Undefined_Name(self, Undefined_Name): self.Undefined_Name = Undefined_Name
    def export(self, outfile, level, namespace_='cybox:', name_='Action_Name', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Action_Name')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Action_Name'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Action_Name', fromsubclass_=False):
        if self.Defined_Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefined_Name>%s</%sDefined_Name>\n' % (namespace_, self.gds_format_string(quote_xml(self.Defined_Name).encode(ExternalEncoding), input_name='Defined_Name'), namespace_))
        if self.Undefined_Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sUndefined_Name>%s</%sUndefined_Name>\n' % (namespace_, self.gds_format_string(quote_xml(self.Undefined_Name).encode(ExternalEncoding), input_name='Undefined_Name'), namespace_))
    def hasContent_(self):
        if (
            self.Defined_Name is not None or
            self.Undefined_Name is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Action_Name'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Defined_Name is not None:
            showIndent(outfile, level)
            outfile.write('Defined_Name=%s,\n' % quote_python(self.Defined_Name).encode(ExternalEncoding))
        if self.Undefined_Name is not None:
            showIndent(outfile, level)
            outfile.write('Undefined_Name=%s,\n' % quote_python(self.Undefined_Name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Defined_Name':
            Defined_Name_ = child_.text
            Defined_Name_ = self.gds_validate_string(Defined_Name_, node, 'Defined_Name')
            self.Defined_Name = Defined_Name_
            self.validate_DefinedActionNameEnum(self.Defined_Name)    # validate type DefinedActionNameEnum
        elif nodeName_ == 'Undefined_Name':
            Undefined_Name_ = child_.text
            Undefined_Name_ = self.gds_validate_string(Undefined_Name_, node, 'Undefined_Name')
            self.Undefined_Name = Undefined_Name_
# end class Action_Name


class Action_Aliases(GeneratedsSuper):
    """The Action_Aliases element is optional and enables identification of
    other potentially used names for this Action."""
    subclass = None
    superclass = None
    def __init__(self, Action_Alias=None):
        if Action_Alias is None:
            self.Action_Alias = []
        else:
            self.Action_Alias = Action_Alias
    def factory(*args_, **kwargs_):
        if Action_Aliases.subclass:
            return Action_Aliases.subclass(*args_, **kwargs_)
        else:
            return Action_Aliases(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Alias(self): return self.Action_Alias
    def set_Action_Alias(self, Action_Alias): self.Action_Alias = Action_Alias
    def add_Action_Alias(self, value): self.Action_Alias.append(value)
    def insert_Action_Alias(self, index, value): self.Action_Alias[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Action_Aliases', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Action_Aliases')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Action_Aliases'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Action_Aliases', fromsubclass_=False):
        for Action_Alias_ in self.Action_Alias:
            showIndent(outfile, level)
            outfile.write('<%sAction_Alias>%s</%sAction_Alias>\n' % (namespace_, self.gds_format_string(quote_xml(Action_Alias_).encode(ExternalEncoding), input_name='Action_Alias'), namespace_))
    def hasContent_(self):
        if (
            self.Action_Alias
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Action_Aliases'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Alias=[\n')
        level += 1
        for Action_Alias_ in self.Action_Alias:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Action_Alias_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Alias':
            Action_Alias_ = child_.text
            Action_Alias_ = self.gds_validate_string(Action_Alias_, node, 'Action_Alias')
            self.Action_Alias.append(Action_Alias_)
# end class Action_Aliases


class Action_Arguments(GeneratedsSuper):
    """The Action_Arguments element is optional and enables the
    specification of relevant arguments/parameters for this Action."""
    subclass = None
    superclass = None
    def __init__(self, Action_Argument=None):
        if Action_Argument is None:
            self.Action_Argument = []
        else:
            self.Action_Argument = Action_Argument
    def factory(*args_, **kwargs_):
        if Action_Arguments.subclass:
            return Action_Arguments.subclass(*args_, **kwargs_)
        else:
            return Action_Arguments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Argument(self): return self.Action_Argument
    def set_Action_Argument(self, Action_Argument): self.Action_Argument = Action_Argument
    def add_Action_Argument(self, value): self.Action_Argument.append(value)
    def insert_Action_Argument(self, index, value): self.Action_Argument[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Action_Arguments', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Action_Arguments')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Action_Arguments'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Action_Arguments', fromsubclass_=False):
        for Action_Argument_ in self.Action_Argument:
            Action_Argument_.export(outfile, level, namespace_, name_='Action_Argument')
    def hasContent_(self):
        if (
            self.Action_Argument
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Action_Arguments'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Argument=[\n')
        level += 1
        for Action_Argument_ in self.Action_Argument:
            showIndent(outfile, level)
            outfile.write('model_.Action_Argument(\n')
            Action_Argument_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Argument':
            obj_ = Action_Argument.factory()
            obj_.build(child_)
            self.Action_Argument.append(obj_)
# end class Action_Arguments


class Action_Argument(GeneratedsSuper):
    """The Action_Argument element is optional and enables the
    specification of a single relevant argument/parameter for this
    Action."""
    subclass = None
    superclass = None
    def __init__(self, Argument_Name_Defined=None, Argument_Name_Undefined=None, Argument_Value=None):
        self.Argument_Name_Defined = Argument_Name_Defined
        self.Argument_Name_Undefined = Argument_Name_Undefined
        self.Argument_Value = Argument_Value
    def factory(*args_, **kwargs_):
        if Action_Argument.subclass:
            return Action_Argument.subclass(*args_, **kwargs_)
        else:
            return Action_Argument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Argument_Name_Defined(self): return self.Argument_Name_Defined
    def set_Argument_Name_Defined(self, Argument_Name_Defined): self.Argument_Name_Defined = Argument_Name_Defined
    def validate_DefinedArgumentNameEnum(self, value):
        # Validate type DefinedArgumentNameEnum, a restriction on xs:string.
        pass
    def get_Argument_Name_Undefined(self): return self.Argument_Name_Undefined
    def set_Argument_Name_Undefined(self, Argument_Name_Undefined): self.Argument_Name_Undefined = Argument_Name_Undefined
    def get_Argument_Value(self): return self.Argument_Value
    def set_Argument_Value(self, Argument_Value): self.Argument_Value = Argument_Value
    def export(self, outfile, level, namespace_='cybox:', name_='Action_Argument', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Action_Argument')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Action_Argument'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Action_Argument', fromsubclass_=False):
        if self.Argument_Name_Defined is not None:
            showIndent(outfile, level)
            outfile.write('<%sArgument_Name-Defined>%s</%sArgument_Name-Defined>\n' % (namespace_, self.gds_format_string(quote_xml(self.Argument_Name_Defined).encode(ExternalEncoding), input_name='Argument_Name-Defined'), namespace_))
        if self.Argument_Name_Undefined is not None:
            showIndent(outfile, level)
            outfile.write('<%sArgument_Name-Undefined>%s</%sArgument_Name-Undefined>\n' % (namespace_, self.gds_format_string(quote_xml(self.Argument_Name_Undefined).encode(ExternalEncoding), input_name='Argument_Name-Undefined'), namespace_))
        if self.Argument_Value is not None:
            showIndent(outfile, level)
            outfile.write('<%sArgument_Value>%s</%sArgument_Value>\n' % (namespace_, self.gds_format_string(quote_xml(self.Argument_Value).encode(ExternalEncoding), input_name='Argument_Value'), namespace_))
    def hasContent_(self):
        if (
            self.Argument_Name_Defined is not None or
            self.Argument_Name_Undefined is not None or
            self.Argument_Value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Action_Argument'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Argument_Name_Defined is not None:
            showIndent(outfile, level)
            outfile.write('Argument_Name_Defined=%s,\n' % quote_python(self.Argument_Name_Defined).encode(ExternalEncoding))
        if self.Argument_Name_Undefined is not None:
            showIndent(outfile, level)
            outfile.write('Argument_Name_Undefined=%s,\n' % quote_python(self.Argument_Name_Undefined).encode(ExternalEncoding))
        if self.Argument_Value is not None:
            showIndent(outfile, level)
            outfile.write('Argument_Value=%s,\n' % quote_python(self.Argument_Value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Argument_Name-Defined':
            Argument_Name_Defined_ = child_.text
            Argument_Name_Defined_ = self.gds_validate_string(Argument_Name_Defined_, node, 'Argument_Name_Defined')
            self.Argument_Name_Defined = Argument_Name_Defined_
            self.validate_DefinedArgumentNameEnum(self.Argument_Name_Defined)    # validate type DefinedArgumentNameEnum
        elif nodeName_ == 'Argument_Name-Undefined':
            Argument_Name_Undefined_ = child_.text
            Argument_Name_Undefined_ = self.gds_validate_string(Argument_Name_Undefined_, node, 'Argument_Name_Undefined')
            self.Argument_Name_Undefined = Argument_Name_Undefined_
        elif nodeName_ == 'Argument_Value':
            Argument_Value_ = child_.text
            Argument_Value_ = self.gds_validate_string(Argument_Value_, node, 'Argument_Value')
            self.Argument_Value = Argument_Value_
# end class Action_Argument


class Associated_Objects(GeneratedsSuper):
    """The Associated_Objects element is optional and enables the
    description/specification of cyber Objects relevant (either
    initiating or affected by) this Action."""
    subclass = None
    superclass = None
    def __init__(self, Associated_Object=None):
        if Associated_Object is None:
            self.Associated_Object = []
        else:
            self.Associated_Object = Associated_Object
    def factory(*args_, **kwargs_):
        if Associated_Objects.subclass:
            return Associated_Objects.subclass(*args_, **kwargs_)
        else:
            return Associated_Objects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Associated_Object(self): return self.Associated_Object
    def set_Associated_Object(self, Associated_Object): self.Associated_Object = Associated_Object
    def add_Associated_Object(self, value): self.Associated_Object.append(value)
    def insert_Associated_Object(self, index, value): self.Associated_Object[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Associated_Objects', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Associated_Objects')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Associated_Objects'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Associated_Objects', fromsubclass_=False):
        for Associated_Object_ in self.Associated_Object:
            Associated_Object_.export(outfile, level, namespace_, name_='Associated_Object')
    def hasContent_(self):
        if (
            self.Associated_Object
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Associated_Objects'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Associated_Object=[\n')
        level += 1
        for Associated_Object_ in self.Associated_Object:
            showIndent(outfile, level)
            outfile.write('model_.AssociatedObjectType(\n')
            Associated_Object_.exportLiteral(outfile, level, name_='AssociatedObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Associated_Object':
            obj_ = AssociatedObjectType.factory()
            obj_.build(child_)
            self.Associated_Object.append(obj_)
# end class Associated_Objects


class Relationships(GeneratedsSuper):
    """The Relationships element is optional and enables description of
    other cyber observable actions that are related to this Action."""
    subclass = None
    superclass = None
    def __init__(self, Relationship=None):
        if Relationship is None:
            self.Relationship = []
        else:
            self.Relationship = Relationship
    def factory(*args_, **kwargs_):
        if Relationships.subclass:
            return Relationships.subclass(*args_, **kwargs_)
        else:
            return Relationships(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def add_Relationship(self, value): self.Relationship.append(value)
    def insert_Relationship(self, index, value): self.Relationship[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Relationships', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationships')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Relationships'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Relationships', fromsubclass_=False):
        for Relationship_ in self.Relationship:
            Relationship_.export(outfile, level, namespace_, name_='Relationship')
    def hasContent_(self):
        if (
            self.Relationship
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationships'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship=[\n')
        level += 1
        for Relationship_ in self.Relationship:
            showIndent(outfile, level)
            outfile.write('model_.ActionRelationshipType(\n')
            Relationship_.exportLiteral(outfile, level, name_='ActionRelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship':
            obj_ = ActionRelationshipType.factory()
            obj_.build(child_)
            self.Relationship.append(obj_)
# end class Relationships


class ActionReferenceType(GeneratedsSuper):
    """ActionReferenceType is intended to serve as a method for linking to
    actions.The action_id attribute refers to the id of the action
    being referenced."""
    subclass = None
    superclass = None
    def __init__(self, action_id=None):
        self.action_id = _cast(None, action_id)
        pass
    def factory(*args_, **kwargs_):
        if ActionReferenceType.subclass:
            return ActionReferenceType.subclass(*args_, **kwargs_)
        else:
            return ActionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action_id(self): return self.action_id
    def set_action_id(self, action_id): self.action_id = action_id
    def export(self, outfile, level, namespace_='cybox:', name_='ActionReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='ActionReferenceType'):
        if self.action_id is not None and 'action_id' not in already_processed:
            already_processed.append('action_id')
            outfile.write(' action_id=%s' % (self.gds_format_string(quote_attrib(self.action_id).encode(ExternalEncoding), input_name='action_id'), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='ActionReferenceType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action_id is not None and 'action_id' not in already_processed:
            already_processed.append('action_id')
            showIndent(outfile, level)
            outfile.write('action_id = "%s",\n' % (self.action_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action_id', node)
        if value is not None and 'action_id' not in already_processed:
            already_processed.append('action_id')
            self.action_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionReferenceType


class Action_Pertinent_Object_AttributesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None):
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if Action_Pertinent_Object_AttributesType.subclass:
            return Action_Pertinent_Object_AttributesType.subclass(*args_, **kwargs_)
        else:
            return Action_Pertinent_Object_AttributesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def add_Attribute(self, value): self.Attribute.append(value)
    def insert_Attribute(self, index, value): self.Attribute[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Action-Pertinent_Object_AttributesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Action-Pertinent_Object_AttributesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Action-Pertinent_Object_AttributesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Action-Pertinent_Object_AttributesType', fromsubclass_=False):
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespace_, name_='Attribute')
    def hasContent_(self):
        if (
            self.Attribute
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Action-Pertinent_Object_AttributesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attribute=[\n')
        level += 1
        for Attribute_ in self.Attribute:
            showIndent(outfile, level)
            outfile.write('model_.Attribute(\n')
            Attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute.append(obj_)
# end class Action_Pertinent_Object_AttributesType


class Attribute(GeneratedsSuper):
    """The Attribute element identifies a single Object Attribute that is
    specifically pertinent to this Action.The Name attribute
    specifies the field name for the pertinent Object Attribute.The
    XPath attribute specifies the XPath expression identifying the
    pertinent attribute within the Defined_Object schema for this
    object type."""
    subclass = None
    superclass = None
    def __init__(self, XPath=None, Name=None):
        self.XPath = _cast(None, XPath)
        self.Name = _cast(None, Name)
        pass
    def factory(*args_, **kwargs_):
        if Attribute.subclass:
            return Attribute.subclass(*args_, **kwargs_)
        else:
            return Attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XPath(self): return self.XPath
    def set_XPath(self, XPath): self.XPath = XPath
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='cybox:', name_='Attribute', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attribute')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Attribute'):
        if self.XPath is not None and 'XPath' not in already_processed:
            already_processed.append('XPath')
            outfile.write(' XPath=%s' % (self.gds_format_string(quote_attrib(self.XPath).encode(ExternalEncoding), input_name='XPath'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Attribute', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attribute'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.XPath is not None and 'XPath' not in already_processed:
            already_processed.append('XPath')
            showIndent(outfile, level)
            outfile.write('XPath = "%s",\n' % (self.XPath,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('XPath', node)
        if value is not None and 'XPath' not in already_processed:
            already_processed.append('XPath')
            self.XPath = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Attribute


class ActionRelationshipType(GeneratedsSuper):
    """The ActionRelationshipType is a complex type characterizing a
    relationship between a specified cyber observable action and
    another cyber observable action.The type attribute describes the
    nature of the relationship between this Action and the related
    Action."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Action_Reference=None):
        self.Type = _cast(None, Type)
        if Action_Reference is None:
            self.Action_Reference = []
        else:
            self.Action_Reference = Action_Reference
    def factory(*args_, **kwargs_):
        if ActionRelationshipType.subclass:
            return ActionRelationshipType.subclass(*args_, **kwargs_)
        else:
            return ActionRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Reference(self): return self.Action_Reference
    def set_Action_Reference(self, Action_Reference): self.Action_Reference = Action_Reference
    def add_Action_Reference(self, value): self.Action_Reference.append(value)
    def insert_Action_Reference(self, index, value): self.Action_Reference[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def export(self, outfile, level, namespace_='cybox:', name_='ActionRelationshipType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionRelationshipType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='ActionRelationshipType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='ActionRelationshipType', fromsubclass_=False):
        for Action_Reference_ in self.Action_Reference:
            Action_Reference_.export(outfile, level, namespace_, name_='Action_Reference')
    def hasContent_(self):
        if (
            self.Action_Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionRelationshipType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Reference=[\n')
        level += 1
        for Action_Reference_ in self.Action_Reference:
            showIndent(outfile, level)
            outfile.write('model_.ActionReferenceType(\n')
            Action_Reference_.exportLiteral(outfile, level, name_='ActionReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Reference':
            type = node.find("WinRegistryKeyObj:WindowsRegistryKeyObjectType")
            if type == 'WinFile':
	    	obj_ = WinFileObjType.WinFileObjType.factory()
	    	obj_.build(child_)
	    	self.Action_Reference.append(obj_)
	    if type is not None:
	    	obj_ = WinRegistryKeyObj.WinFileObjType.factory()
	    	obj_.build(child_)
	    	self.Action_Reference.append(obj_)
	    if type is None:
	    	print "Found none"
# end class ActionRelationshipType


class ObjectType(GeneratedsSuper):
    """The ObjectType is a complex type representing the characteristics of
    a specific cyber-relevant object (e.g. a file, a registry key or
    a process). The id attribute specifies a unique id for this
    Object.The idref attribute specifies a unique id reference to an
    Object defined elsewhere.The Type attribute specifies what kind
    of object this is.The Object_State attribute enables description
    of the current state of the object.The "any" attribute enables
    the capture of custom attributes describing this Object."""
    subclass = None
    superclass = None
    def __init__(self, idref=None, Type=None, id=None, Object_State=None, Description=None, Defined_Object=None, Domain_specific_Object_Attributes=None, Custom_Attributes=None, Related_Objects=None, Defined_Effect=None, Discovery_Method=None, extensiontype_=None):
        self.idref = _cast(None, idref)
        self.Type = _cast(None, Type)
        self.id = _cast(None, id)
        self.Object_State = _cast(None, Object_State)
        self.Description = Description
        self.Defined_Object = Defined_Object
        self.Domain_specific_Object_Attributes = Domain_specific_Object_Attributes
        self.Custom_Attributes = Custom_Attributes
        self.Related_Objects = Related_Objects
        self.Defined_Effect = Defined_Effect
        self.Discovery_Method = Discovery_Method
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Defined_Object(self): return self.Defined_Object
    def set_Defined_Object(self, Defined_Object): self.Defined_Object = Defined_Object
    def get_Domain_specific_Object_Attributes(self): return self.Domain_specific_Object_Attributes
    def set_Domain_specific_Object_Attributes(self, Domain_specific_Object_Attributes): self.Domain_specific_Object_Attributes = Domain_specific_Object_Attributes
    def get_Custom_Attributes(self): return self.Custom_Attributes
    def set_Custom_Attributes(self, Custom_Attributes): self.Custom_Attributes = Custom_Attributes
    def get_Related_Objects(self): return self.Related_Objects
    def set_Related_Objects(self, Related_Objects): self.Related_Objects = Related_Objects
    def get_Defined_Effect(self): return self.Defined_Effect
    def set_Defined_Effect(self, Defined_Effect): self.Defined_Effect = Defined_Effect
    def get_Discovery_Method(self): return self.Discovery_Method
    def set_Discovery_Method(self, Discovery_Method): self.Discovery_Method = Discovery_Method
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.id
    def set_ID(self, id): self.id = id
    def get_Object_State(self): return self.Object_State
    def set_Object_State(self, Object_State): self.Object_State = Object_State
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='cybox:', name_='ObjectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='ObjectType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.Object_State is not None and 'Object_State' not in already_processed:
            already_processed.append('Object_State')
            outfile.write(' Object_State=%s' % (quote_attrib(self.Object_State), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='ObjectType', fromsubclass_=False):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.Defined_Object is not None:
            self.Defined_Object.export(outfile, level, namespace_, name_='Defined_Object')
        if self.Domain_specific_Object_Attributes is not None:
            self.Domain_specific_Object_Attributes.export(outfile, level, namespace_, name_='Domain_specific_Object_Attributes')
        if self.Custom_Attributes is not None:
            self.Custom_Attributes.export(outfile, level, namespace_, name_='Custom_Attributes')
        if self.Related_Objects is not None:
            self.Related_Objects.export(outfile, level, namespace_, name_='Related_Objects')
        if self.Defined_Effect is not None:
            self.Defined_Effect.export(outfile, level, namespace_, name_='Defined_Effect')
        if self.Discovery_Method is not None:
            showIndent(outfile, level)
            outfile.write('<%sDiscovery_Method>%s</%sDiscovery_Method>\n' % (namespace_, self.gds_format_string(quote_xml(self.Discovery_Method).encode(ExternalEncoding), input_name='Discovery_Method'), namespace_))
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Defined_Object is not None or
            self.Domain_specific_Object_Attributes is not None or
            self.Custom_Attributes is not None or
            self.Related_Objects is not None or
            self.Defined_Effect is not None or
            self.Discovery_Method is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            showIndent(outfile, level)
            outfile.write('idref = %s,\n' % (self.idref,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.Object_State is not None and 'Object_State' not in already_processed:
            already_processed.append('Object_State')
            showIndent(outfile, level)
            outfile.write('Object_State = %s,\n' % (self.Object_State,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Defined_Object is not None:
            showIndent(outfile, level)
            outfile.write('Defined_Object=%s,\n' % quote_python(self.Defined_Object).encode(ExternalEncoding))
        if self.Domain_specificObjectAttributesType is not None:
            showIndent(outfile, level)
            outfile.write('Domain_specificObjectAttributesType=model_.Domain_specificObjectAttributesType(\n')
            self.Domain_specificObjectAttributesType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Custom_Attributes is not None:
            showIndent(outfile, level)
            outfile.write('Custom_Attributes=model_.Custom_Attributes(\n')
            self.Custom_Attributes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Objects is not None:
            showIndent(outfile, level)
            outfile.write('Related_Objects=model_.Related_Objects(\n')
            self.Related_Objects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DefinedEffectType is not None:
            showIndent(outfile, level)
            outfile.write('DefinedEffectType=model_.DefinedEffectType(\n')
            self.DefinedEffectType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discovery_Method is not None:
            showIndent(outfile, level)
            outfile.write('Discovery_Method=%s,\n' % quote_python(self.Discovery_Method).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.append('idref')
            self.idref = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('Object_State', node)
        if value is not None and 'Object_State' not in already_processed:
            already_processed.append('Object_State')
            self.Object_State = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Defined_Object':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                xsi_type_ = type_name_
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Defined_Object> element')
            self.set_Defined_Object(obj_)

        elif nodeName_ == 'Domain-specific_Object_Attributes':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Domain_specific_Object_Attributes> element')
            self.set_Domain_specific_Object_Attributes(obj_)
        elif nodeName_ == 'Custom_Attributes':
            obj_ = Custom_Attributes.factory()
            obj_.build(child_)
            self.set_Custom_Attributes(obj_)
        elif nodeName_ == 'Related_Objects':
            obj_ = Related_Objects.factory()
            obj_.build(child_)
            self.set_Related_Objects(obj_)
        elif nodeName_ == 'Defined_Effect':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Defined_Effect> element')
            self.set_Defined_Effect(obj_)
        elif nodeName_ == 'Discovery_Method':
            Discovery_Method_ = child_.text
            Discovery_Method_ = self.gds_validate_string(Discovery_Method_, node, 'Discovery_Method')
            self.Discovery_Method = Discovery_Method_
# end class ObjectType


class Custom_Attributes(GeneratedsSuper):
    """The Custom_Attributes element is optional and enables the
    specification of a set of custom Object Attributes that may not
    be defined in existing Defined_Object schemas."""
    subclass = None
    superclass = None
    def __init__(self, Attribute=None):
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if Custom_Attributes.subclass:
            return Custom_Attributes.subclass(*args_, **kwargs_)
        else:
            return Custom_Attributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def add_Attribute(self, value): self.Attribute.append(value)
    def insert_Attribute(self, index, value): self.Attribute[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Custom_Attributes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Custom_Attributes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Custom_Attributes'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Custom_Attributes', fromsubclass_=False):
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespace_, name_='Attribute')
    def hasContent_(self):
        if (
            self.Attribute
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Custom_Attributes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attribute=[\n')
        level += 1
        for Attribute_ in self.Attribute:
            showIndent(outfile, level)
            outfile.write('model_.Attribute(\n')
            Attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute.append(obj_)
# end class Custom_Attributes


class Related_Objects(GeneratedsSuper):
    """The Related_Objects element is optional and enables the
    identification and/or specification of Objects with relevant
    relationships with this Object."""
    subclass = None
    superclass = None
    def __init__(self, Related_Object=None):
        if Related_Object is None:
            self.Related_Object = []
        else:
            self.Related_Object = Related_Object
    def factory(*args_, **kwargs_):
        if Related_Objects.subclass:
            return Related_Objects.subclass(*args_, **kwargs_)
        else:
            return Related_Objects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Related_Object(self): return self.Related_Object
    def set_Related_Object(self, Related_Object): self.Related_Object = Related_Object
    def add_Related_Object(self, value): self.Related_Object.append(value)
    def insert_Related_Object(self, index, value): self.Related_Object[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Related_Objects', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Objects')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Related_Objects'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Related_Objects', fromsubclass_=False):
        for Related_Object_ in self.Related_Object:
            Related_Object_.export(outfile, level, namespace_, name_='Related_Object')
    def hasContent_(self):
        if (
            self.Related_Object
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Objects'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Related_Object=[\n')
        level += 1
        for Related_Object_ in self.Related_Object:
            showIndent(outfile, level)
            outfile.write('model_.RelatedObjectType(\n')
            Related_Object_.exportLiteral(outfile, level, name_='RelatedObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Related_Object':
            obj_ = RelatedObjectType.factory()
            obj_.build(child_)
            self.Related_Object.append(obj_)
# end class Related_Objects


class Domain_specificObjectAttributesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Domain_specificObjectAttributesType.subclass:
            return Domain_specificObjectAttributesType.subclass(*args_, **kwargs_)
        else:
            return Domain_specificObjectAttributesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='cybox:', name_='Domain-specificObjectAttributesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Domain-specificObjectAttributesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Domain-specificObjectAttributesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Domain-specificObjectAttributesType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Domain-specificObjectAttributesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Domain_specificObjectAttributesType


class RelatedObjectType(ObjectType):
    """The Relationship attribute specifies the nature of the relationship
    between this Object and the Related_Object."""
    subclass = None
    superclass = ObjectType
    def __init__(self, idref=None, Type=None, id=None, Object_State=None, Description=None, Defined_Object=None, Domain_specific_Object_Attributes=None, Custom_Attributes=None, Related_Objects=None, Defined_Effect=None, Discovery_Method=None, Relationship=None):
        super(RelatedObjectType, self).__init__(idref, Type, id, Object_State, Description, Defined_Object, Domain_specific_Object_Attributes, Custom_Attributes, Related_Objects, Defined_Effect, Discovery_Method, )
        self.Relationship = _cast(None, Relationship)
        pass
    def factory(*args_, **kwargs_):
        if RelatedObjectType.subclass:
            return RelatedObjectType.subclass(*args_, **kwargs_)
        else:
            return RelatedObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def export(self, outfile, level, namespace_='cybox:', name_='RelatedObjectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedObjectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='RelatedObjectType'):
        super(RelatedObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedObjectType')
        if self.Relationship is not None and 'Relationship' not in already_processed:
            already_processed.append('Relationship')
            outfile.write(' Relationship=%s' % (quote_attrib(self.Relationship), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='RelatedObjectType', fromsubclass_=False):
        super(RelatedObjectType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(RelatedObjectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RelatedObjectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Relationship is not None and 'Relationship' not in already_processed:
            already_processed.append('Relationship')
            showIndent(outfile, level)
            outfile.write('Relationship = %s,\n' % (self.Relationship,))
        super(RelatedObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RelatedObjectType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Relationship', node)
        if value is not None and 'Relationship' not in already_processed:
            already_processed.append('Relationship')
            self.Relationship = value
        super(RelatedObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RelatedObjectType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RelatedObjectType


class DefinedEffectType(GeneratedsSuper):
    """The EffectTye attribute specifies the nature of the Defined Effect
    instantiated in the place of the Defined_Effect element."""
    subclass = None
    superclass = None
    def __init__(self, EffectType=None, extensiontype_=None):
        self.EffectType = _cast(None, EffectType)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DefinedEffectType.subclass:
            return DefinedEffectType.subclass(*args_, **kwargs_)
        else:
            return DefinedEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EffectType(self): return self.EffectType
    def set_EffectType(self, EffectType): self.EffectType = EffectType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='cybox:', name_='DefinedEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefinedEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='DefinedEffectType'):
        if self.EffectType is not None and 'EffectType' not in already_processed:
            already_processed.append('EffectType')
            outfile.write(' EffectType=%s' % (quote_attrib(self.EffectType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='DefinedEffectType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefinedEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.EffectType is not None and 'EffectType' not in already_processed:
            already_processed.append('EffectType')
            showIndent(outfile, level)
            outfile.write('EffectType = %s,\n' % (self.EffectType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('EffectType', node)
        if value is not None and 'EffectType' not in already_processed:
            already_processed.append('EffectType')
            self.EffectType = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DefinedEffectType


class StateChangeEffectType(DefinedEffectType):
    """The StateChangeEffectType is intended as a generic way of
    characterizing the effects of actions upon objects where the
    some state of the object is changed."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, EffectType=None, Old_State=None, New_State=None):
        super(StateChangeEffectType, self).__init__(EffectType, )
        self.Old_State = Old_State
        self.New_State = New_State
    def factory(*args_, **kwargs_):
        if StateChangeEffectType.subclass:
            return StateChangeEffectType.subclass(*args_, **kwargs_)
        else:
            return StateChangeEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Old_State(self): return self.Old_State
    def set_Old_State(self, Old_State): self.Old_State = Old_State
    def get_New_State(self): return self.New_State
    def set_New_State(self, New_State): self.New_State = New_State
    def export(self, outfile, level, namespace_='cybox:', name_='StateChangeEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateChangeEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='StateChangeEffectType'):
        super(StateChangeEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StateChangeEffectType')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='StateChangeEffectType', fromsubclass_=False):
        super(StateChangeEffectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Old_State is not None:
            self.Old_State.export(outfile, level, namespace_, name_='Old_State')
        if self.New_State is not None:
            self.New_State.export(outfile, level, namespace_, name_='New_State', )
    def hasContent_(self):
        if (
            self.Old_State is not None or
            self.New_State is not None or
            super(StateChangeEffectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateChangeEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StateChangeEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StateChangeEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Old_State is not None:
            showIndent(outfile, level)
            outfile.write('Old_State=model_.Old_State(\n')
            self.Old_State.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.New_State is not None:
            showIndent(outfile, level)
            outfile.write('New_State=model_.New_State(\n')
            self.New_State.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StateChangeEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Old_State':
            obj_ = Old_State.factory()
            obj_.build(child_)
            self.set_Old_State(obj_)
        elif nodeName_ == 'New_State':
            obj_ = New_State.factory()
            obj_.build(child_)
            self.set_New_State(obj_)
        super(StateChangeEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class StateChangeEffectType


class Old_State(GeneratedsSuper):
    """The Old_State element specifies the object and its attributes as
    they were before the state change effect occurred."""
    subclass = None
    superclass = None
    def __init__(self, Object=None, Defined_Object=None, Object_IDRef=None):
        self.Object = Object
        self.Defined_Object = Defined_Object
        self.Object_IDRef = Object_IDRef
    def factory(*args_, **kwargs_):
        if Old_State.subclass:
            return Old_State.subclass(*args_, **kwargs_)
        else:
            return Old_State(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def get_Defined_Object(self): return self.Defined_Object
    def set_Defined_Object(self, Defined_Object): self.Defined_Object = Defined_Object
    def get_Object_IDRef(self): return self.Object_IDRef
    def set_Object_IDRef(self, Object_IDRef): self.Object_IDRef = Object_IDRef
    def export(self, outfile, level, namespace_='cybox:', name_='Old_State', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Old_State')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Old_State'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Old_State', fromsubclass_=False):
        if self.Object is not None:
            self.Object.export(outfile, level, namespace_, name_='Object', )
        if self.Defined_Object is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefined_Object>%s</%sDefined_Object>\n' % (namespace_, self.gds_format_string(quote_xml(self.Defined_Object).encode(ExternalEncoding), input_name='Defined_Object'), namespace_))
        if self.Object_IDRef is not None:
            showIndent(outfile, level)
            outfile.write('<%sObject_IDRef>%s</%sObject_IDRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.Object_IDRef).encode(ExternalEncoding), input_name='Object_IDRef'), namespace_))
    def hasContent_(self):
        if (
            self.Object is not None or
            self.Defined_Object is not None or
            self.Object_IDRef is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Old_State'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('Object=model_.ObjectType(\n')
            self.Object.exportLiteral(outfile, level, name_='Object')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Defined_Object is not None:
            showIndent(outfile, level)
            outfile.write('Defined_Object=%s,\n' % quote_python(self.Defined_Object).encode(ExternalEncoding))
        if self.Object_IDRef is not None:
            showIndent(outfile, level)
            outfile.write('Object_IDRef=%s,\n' % quote_python(self.Object_IDRef).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Object(obj_)
        elif nodeName_ == 'Defined_Object':
            Defined_Object_ = child_.text
            Defined_Object_ = self.gds_validate_string(Defined_Object_, node, 'Defined_Object')
            self.Defined_Object = Defined_Object_
        elif nodeName_ == 'Object_IDRef':
            Object_IDRef_ = child_.text
            Object_IDRef_ = self.gds_validate_string(Object_IDRef_, node, 'Object_IDRef')
            self.Object_IDRef = Object_IDRef_
# end class Old_State


class New_State(GeneratedsSuper):
    """The New_State element specifies the object and its attributes as
    they are after the state change effect occurred."""
    subclass = None
    superclass = None
    def __init__(self, Object=None, Defined_Object=None, Object_IDRef=None):
        self.Object = Object
        self.Defined_Object = Defined_Object
        self.Object_IDRef = Object_IDRef
    def factory(*args_, **kwargs_):
        if New_State.subclass:
            return New_State.subclass(*args_, **kwargs_)
        else:
            return New_State(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def get_Defined_Object(self): return self.Defined_Object
    def set_Defined_Object(self, Defined_Object): self.Defined_Object = Defined_Object
    def get_Object_IDRef(self): return self.Object_IDRef
    def set_Object_IDRef(self, Object_IDRef): self.Object_IDRef = Object_IDRef
    def export(self, outfile, level, namespace_='cybox:', name_='New_State', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='New_State')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='New_State'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='New_State', fromsubclass_=False):
        if self.Object is not None:
            self.Object.export(outfile, level, namespace_, name_='Object', )
        if self.Defined_Object is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefined_Object>%s</%sDefined_Object>\n' % (namespace_, self.gds_format_string(quote_xml(self.Defined_Object).encode(ExternalEncoding), input_name='Defined_Object'), namespace_))
        if self.Object_IDRef is not None:
            showIndent(outfile, level)
            outfile.write('<%sObject_IDRef>%s</%sObject_IDRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.Object_IDRef).encode(ExternalEncoding), input_name='Object_IDRef'), namespace_))
    def hasContent_(self):
        if (
            self.Object is not None or
            self.Defined_Object is not None or
            self.Object_IDRef is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='New_State'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('Object=model_.ObjectType(\n')
            self.Object.exportLiteral(outfile, level, name_='Object')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Defined_Object is not None:
            showIndent(outfile, level)
            outfile.write('Defined_Object=%s,\n' % quote_python(self.Defined_Object).encode(ExternalEncoding))
        if self.Object_IDRef is not None:
            showIndent(outfile, level)
            outfile.write('Object_IDRef=%s,\n' % quote_python(self.Object_IDRef).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Object(obj_)
        elif nodeName_ == 'Defined_Object':
            Defined_Object_ = child_.text
            Defined_Object_ = self.gds_validate_string(Defined_Object_, node, 'Defined_Object')
            self.Defined_Object = Defined_Object_
        elif nodeName_ == 'Object_IDRef':
            Object_IDRef_ = child_.text
            Object_IDRef_ = self.gds_validate_string(Object_IDRef_, node, 'Object_IDRef')
            self.Object_IDRef = Object_IDRef_
# end class New_State


class DataReadEffectType(DefinedEffectType):
    """The DataReadEffectType type is intended to characterize the effects
    of actions upon objects where some data is read, such as from a
    file or a pipe."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, EffectType=None, Data=None):
        super(DataReadEffectType, self).__init__(EffectType, )
        self.Data = Data
    def factory(*args_, **kwargs_):
        if DataReadEffectType.subclass:
            return DataReadEffectType.subclass(*args_, **kwargs_)
        else:
            return DataReadEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def export(self, outfile, level, namespace_='cybox:', name_='DataReadEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataReadEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='DataReadEffectType'):
        super(DataReadEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataReadEffectType')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='DataReadEffectType', fromsubclass_=False):
        super(DataReadEffectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('<%sData>%s</%sData>\n' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_))
    def hasContent_(self):
        if (
            self.Data is not None or
            super(DataReadEffectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataReadEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DataReadEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DataReadEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DataReadEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        super(DataReadEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class DataReadEffectType


class DataWrittenEffectType(DefinedEffectType):
    """The DataWrittenEffectType type is intended to characterize the
    effects of actions upon objects where some data is written, such
    as to a file or a pipe."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, EffectType=None, Data=None):
        super(DataWrittenEffectType, self).__init__(EffectType, )
        self.Data = Data
    def factory(*args_, **kwargs_):
        if DataWrittenEffectType.subclass:
            return DataWrittenEffectType.subclass(*args_, **kwargs_)
        else:
            return DataWrittenEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def export(self, outfile, level, namespace_='cybox:', name_='DataWrittenEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataWrittenEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='DataWrittenEffectType'):
        super(DataWrittenEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataWrittenEffectType')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='DataWrittenEffectType', fromsubclass_=False):
        super(DataWrittenEffectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('<%sData>%s</%sData>\n' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_))
    def hasContent_(self):
        if (
            self.Data is not None or
            super(DataWrittenEffectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataWrittenEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DataWrittenEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DataWrittenEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DataWrittenEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        super(DataWrittenEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class DataWrittenEffectType


class DataSentEffectType(DefinedEffectType):
    """The DataSentEffectType type is intended to characterize the effects
    of actions upon objects where some data is sent, such as a byte
    sequence on a socket."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, EffectType=None, Data=None):
        super(DataSentEffectType, self).__init__(EffectType, )
        self.Data = Data
    def factory(*args_, **kwargs_):
        if DataSentEffectType.subclass:
            return DataSentEffectType.subclass(*args_, **kwargs_)
        else:
            return DataSentEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def export(self, outfile, level, namespace_='cybox:', name_='DataSentEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSentEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='DataSentEffectType'):
        super(DataSentEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataSentEffectType')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='DataSentEffectType', fromsubclass_=False):
        super(DataSentEffectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('<%sData>%s</%sData>\n' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_))
    def hasContent_(self):
        if (
            self.Data is not None or
            super(DataSentEffectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataSentEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DataSentEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DataSentEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DataSentEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        super(DataSentEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class DataSentEffectType


class DataReceivedEffectType(DefinedEffectType):
    """The DataReceivedEffectType type is intended to characterize the
    effects of actions upon objects where some data is received,
    such as a byte sequence on a socket."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, EffectType=None, Data=None):
        super(DataReceivedEffectType, self).__init__(EffectType, )
        self.Data = Data
    def factory(*args_, **kwargs_):
        if DataReceivedEffectType.subclass:
            return DataReceivedEffectType.subclass(*args_, **kwargs_)
        else:
            return DataReceivedEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def export(self, outfile, level, namespace_='cybox:', name_='DataReceivedEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataReceivedEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='DataReceivedEffectType'):
        super(DataReceivedEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataReceivedEffectType')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='DataReceivedEffectType', fromsubclass_=False):
        super(DataReceivedEffectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('<%sData>%s</%sData>\n' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_))
    def hasContent_(self):
        if (
            self.Data is not None or
            super(DataReceivedEffectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataReceivedEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DataReceivedEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DataReceivedEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DataReceivedEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        super(DataReceivedEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class DataReceivedEffectType


class ValuesEnumeratedEffectType(DefinedEffectType):
    """The ValuesEnumeratedEffectType type is intended to characterize the
    effects of actions upon objects where some values of the object
    are enumerated, such as the values of a registry key."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, EffectType=None, Values=None):
        super(ValuesEnumeratedEffectType, self).__init__(EffectType, )
        self.Values = Values
    def factory(*args_, **kwargs_):
        if ValuesEnumeratedEffectType.subclass:
            return ValuesEnumeratedEffectType.subclass(*args_, **kwargs_)
        else:
            return ValuesEnumeratedEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Values(self): return self.Values
    def set_Values(self, Values): self.Values = Values
    def export(self, outfile, level, namespace_='cybox:', name_='ValuesEnumeratedEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuesEnumeratedEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='ValuesEnumeratedEffectType'):
        super(ValuesEnumeratedEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ValuesEnumeratedEffectType')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='ValuesEnumeratedEffectType', fromsubclass_=False):
        super(ValuesEnumeratedEffectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Values is not None:
            self.Values.export(outfile, level, namespace_, name_='Values', )
    def hasContent_(self):
        if (
            self.Values is not None or
            super(ValuesEnumeratedEffectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuesEnumeratedEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ValuesEnumeratedEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ValuesEnumeratedEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Values is not None:
            showIndent(outfile, level)
            outfile.write('Values=model_.Values(\n')
            self.Values.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ValuesEnumeratedEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Values':
            obj_ = Values.factory()
            obj_.build(child_)
            self.set_Values(obj_)
        super(ValuesEnumeratedEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class ValuesEnumeratedEffectType


class Values(GeneratedsSuper):
    """The Values element specifies the values that were enumerated as a
    result of the action on the object."""
    subclass = None
    superclass = None
    def __init__(self, Value=None):
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if Values.subclass:
            return Values.subclass(*args_, **kwargs_)
        else:
            return Values(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Values', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Values')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Values'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Values', fromsubclass_=False):
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.Value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Values'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
# end class Values


class PropertiesEnumeratedEffectType(DefinedEffectType):
    """The PropertiesEnumeratedEffectType type is intended to characterize
    the effects of actions upon objects where some properties of the
    object are enumerated, such as the startup parameters for a
    process."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, EffectType=None, Properties=None):
        super(PropertiesEnumeratedEffectType, self).__init__(EffectType, )
        self.Properties = Properties
    def factory(*args_, **kwargs_):
        if PropertiesEnumeratedEffectType.subclass:
            return PropertiesEnumeratedEffectType.subclass(*args_, **kwargs_)
        else:
            return PropertiesEnumeratedEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Properties(self): return self.Properties
    def set_Properties(self, Properties): self.Properties = Properties
    def export(self, outfile, level, namespace_='cybox:', name_='PropertiesEnumeratedEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertiesEnumeratedEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='PropertiesEnumeratedEffectType'):
        super(PropertiesEnumeratedEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PropertiesEnumeratedEffectType')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='PropertiesEnumeratedEffectType', fromsubclass_=False):
        super(PropertiesEnumeratedEffectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Properties is not None:
            self.Properties.export(outfile, level, namespace_, name_='Properties', )
    def hasContent_(self):
        if (
            self.Properties is not None or
            super(PropertiesEnumeratedEffectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PropertiesEnumeratedEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PropertiesEnumeratedEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PropertiesEnumeratedEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Properties is not None:
            showIndent(outfile, level)
            outfile.write('Properties=model_.Properties(\n')
            self.Properties.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PropertiesEnumeratedEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Properties':
            obj_ = Properties.factory()
            obj_.build(child_)
            self.set_Properties(obj_)
        super(PropertiesEnumeratedEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class PropertiesEnumeratedEffectType


class Properties(GeneratedsSuper):
    """The Properties element specifies the properties that were enumerated
    as a result of the action on the object."""
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if Properties.subclass:
            return Properties.subclass(*args_, **kwargs_)
        else:
            return Properties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Properties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Properties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Properties'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Properties', fromsubclass_=False):
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('<%sProperty>%s</%sProperty>\n' % (namespace_, self.gds_format_string(quote_xml(Property_).encode(ExternalEncoding), input_name='Property'), namespace_))
    def hasContent_(self):
        if (
            self.Property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Properties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Property_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            Property_ = child_.text
            Property_ = self.gds_validate_string(Property_, node, 'Property')
            self.Property.append(Property_)
# end class Properties


class PropertyReadEffectType(DefinedEffectType):
    """The PropertyReadEffectType type is intended to characterize the
    effects of actions upon objects where some specific property is
    read from an object, such as the current running state of a
    process."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, EffectType=None, Name=None, Value=None):
        super(PropertyReadEffectType, self).__init__(EffectType, )
        self.Name = Name
        self.Value = Value
    def factory(*args_, **kwargs_):
        if PropertyReadEffectType.subclass:
            return PropertyReadEffectType.subclass(*args_, **kwargs_)
        else:
            return PropertyReadEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='cybox:', name_='PropertyReadEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyReadEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='PropertyReadEffectType'):
        super(PropertyReadEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyReadEffectType')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='PropertyReadEffectType', fromsubclass_=False):
        super(PropertyReadEffectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Value is not None or
            super(PropertyReadEffectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PropertyReadEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PropertyReadEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PropertyReadEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PropertyReadEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        super(PropertyReadEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class PropertyReadEffectType


class SendControlCodeEffectType(DefinedEffectType):
    """The SendControlCodeEffectType is intended to characterize the
    effects of actions upon objects where some control code, or
    other control-oriented communication signal, is sent to the
    object. For example, an action may send a control code to change
    the running state of a process."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, EffectType=None, Control_Code=None):
        super(SendControlCodeEffectType, self).__init__(EffectType, )
        self.Control_Code = Control_Code
    def factory(*args_, **kwargs_):
        if SendControlCodeEffectType.subclass:
            return SendControlCodeEffectType.subclass(*args_, **kwargs_)
        else:
            return SendControlCodeEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Control_Code(self): return self.Control_Code
    def set_Control_Code(self, Control_Code): self.Control_Code = Control_Code
    def export(self, outfile, level, namespace_='cybox:', name_='SendControlCodeEffectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SendControlCodeEffectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='SendControlCodeEffectType'):
        super(SendControlCodeEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SendControlCodeEffectType')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='SendControlCodeEffectType', fromsubclass_=False):
        super(SendControlCodeEffectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Control_Code is not None:
            showIndent(outfile, level)
            outfile.write('<%sControl_Code>%s</%sControl_Code>\n' % (namespace_, self.gds_format_string(quote_xml(self.Control_Code).encode(ExternalEncoding), input_name='Control_Code'), namespace_))
    def hasContent_(self):
        if (
            self.Control_Code is not None or
            super(SendControlCodeEffectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SendControlCodeEffectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SendControlCodeEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SendControlCodeEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Control_Code is not None:
            showIndent(outfile, level)
            outfile.write('Control_Code=%s,\n' % quote_python(self.Control_Code).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SendControlCodeEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Control_Code':
            Control_Code_ = child_.text
            Control_Code_ = self.gds_validate_string(Control_Code_, node, 'Control_Code')
            self.Control_Code = Control_Code_
        super(SendControlCodeEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class SendControlCodeEffectType


class AttributeType(GeneratedsSuper):
    """The AttibuteType is a complext type representing the specification
    of a single Object Attribute."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, valueOf_=None):
        self.Name = _cast(None, Name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='cybox:', name_='AttributeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='AttributeType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='AttributeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AttributeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType


class PoolsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Event_Pool=None, Action_Pool=None, Object_Pool=None, Attribute_Pool=None):
        self.Event_Pool = Event_Pool
        self.Action_Pool = Action_Pool
        self.Object_Pool = Object_Pool
        self.Attribute_Pool = Attribute_Pool
    def factory(*args_, **kwargs_):
        if PoolsType.subclass:
            return PoolsType.subclass(*args_, **kwargs_)
        else:
            return PoolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Event_Pool(self): return self.Event_Pool
    def set_Event_Pool(self, Event_Pool): self.Event_Pool = Event_Pool
    def get_Action_Pool(self): return self.Action_Pool
    def set_Action_Pool(self, Action_Pool): self.Action_Pool = Action_Pool
    def get_Object_Pool(self): return self.Object_Pool
    def set_Object_Pool(self, Object_Pool): self.Object_Pool = Object_Pool
    def get_Attribute_Pool(self): return self.Attribute_Pool
    def set_Attribute_Pool(self, Attribute_Pool): self.Attribute_Pool = Attribute_Pool
    def export(self, outfile, level, namespace_='cybox:', name_='PoolsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoolsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='PoolsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='PoolsType', fromsubclass_=False):
        if self.Event_Pool is not None:
            self.Event_Pool.export(outfile, level, namespace_, name_='Event_Pool')
        if self.Action_Pool is not None:
            self.Action_Pool.export(outfile, level, namespace_, name_='Action_Pool')
        if self.Object_Pool is not None:
            self.Object_Pool.export(outfile, level, namespace_, name_='Object_Pool')
        if self.Attribute_Pool is not None:
            self.Attribute_Pool.export(outfile, level, namespace_, name_='Attribute_Pool')
    def hasContent_(self):
        if (
            self.Event_Pool is not None or
            self.Action_Pool is not None or
            self.Object_Pool is not None or
            self.Attribute_Pool is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PoolsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Event_Pool is not None:
            showIndent(outfile, level)
            outfile.write('Event_Pool=model_.Event_PoolType(\n')
            self.Event_Pool.exportLiteral(outfile, level, name_='Event_Pool')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action_Pool is not None:
            showIndent(outfile, level)
            outfile.write('Action_Pool=model_.Action_PoolType(\n')
            self.Action_Pool.exportLiteral(outfile, level, name_='Action_Pool')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Object_Pool is not None:
            showIndent(outfile, level)
            outfile.write('Object_Pool=model_.Object_PoolType(\n')
            self.Object_Pool.exportLiteral(outfile, level, name_='Object_Pool')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attribute_Pool is not None:
            showIndent(outfile, level)
            outfile.write('Attribute_Pool=model_.Attribute_PoolType(\n')
            self.Attribute_Pool.exportLiteral(outfile, level, name_='Attribute_Pool')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Event_Pool':
            obj_ = Event_PoolType.factory()
            obj_.build(child_)
            self.set_Event_Pool(obj_)
        elif nodeName_ == 'Action_Pool':
            obj_ = Action_PoolType.factory()
            obj_.build(child_)
            self.set_Action_Pool(obj_)
        elif nodeName_ == 'Object_Pool':
            obj_ = Object_PoolType.factory()
            obj_.build(child_)
            self.set_Object_Pool(obj_)
        elif nodeName_ == 'Attribute_Pool':
            obj_ = Attribute_PoolType.factory()
            obj_.build(child_)
            self.set_Attribute_Pool(obj_)
# end class PoolsType


class Event_PoolType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Event=None):
        if Event is None:
            self.Event = []
        else:
            self.Event = Event
    def factory(*args_, **kwargs_):
        if Event_PoolType.subclass:
            return Event_PoolType.subclass(*args_, **kwargs_)
        else:
            return Event_PoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def add_Event(self, value): self.Event.append(value)
    def insert_Event(self, index, value): self.Event[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Event_PoolType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Event_PoolType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Event_PoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Event_PoolType', fromsubclass_=False):
        for Event_ in self.Event:
            Event_.export(outfile, level, namespace_, name_='Event')
    def hasContent_(self):
        if (
            self.Event
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Event_PoolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Event=[\n')
        level += 1
        for Event_ in self.Event:
            showIndent(outfile, level)
            outfile.write('model_.EventType(\n')
            Event_.exportLiteral(outfile, level, name_='EventType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Event':
            obj_ = EventType.factory()
            obj_.build(child_)
            self.Event.append(obj_)
# end class Event_PoolType


class Action_PoolType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Action=None):
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
    def factory(*args_, **kwargs_):
        if Action_PoolType.subclass:
            return Action_PoolType.subclass(*args_, **kwargs_)
        else:
            return Action_PoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Action_PoolType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Action_PoolType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Action_PoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Action_PoolType', fromsubclass_=False):
        for Action_ in self.Action:
            Action_.export(outfile, level, namespace_, name_='Action')
    def hasContent_(self):
        if (
            self.Action
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Action_PoolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.ActionType(\n')
            Action_.exportLiteral(outfile, level, name_='ActionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            obj_ = ActionType.factory()
            obj_.build(child_)
            self.Action.append(obj_)
# end class Action_PoolType


class Object_PoolType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Object=None):
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
    def factory(*args_, **kwargs_):
        if Object_PoolType.subclass:
            return Object_PoolType.subclass(*args_, **kwargs_)
        else:
            return Object_PoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object(self, index, value): self.Object[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Object_PoolType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Object_PoolType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Object_PoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Object_PoolType', fromsubclass_=False):
        for Object_ in self.Object:
            Object_.export(outfile, level, namespace_, name_='Object')
    def hasContent_(self):
        if (
            self.Object
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Object_PoolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('model_.ObjectType(\n')
            Object_.exportLiteral(outfile, level, name_='ObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Object.append(obj_)
# end class Object_PoolType


class Attribute_PoolType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None):
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if Attribute_PoolType.subclass:
            return Attribute_PoolType.subclass(*args_, **kwargs_)
        else:
            return Attribute_PoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def add_Attribute(self, value): self.Attribute.append(value)
    def insert_Attribute(self, index, value): self.Attribute[index] = value
    def export(self, outfile, level, namespace_='cybox:', name_='Attribute_PoolType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attribute_PoolType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Attribute_PoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Attribute_PoolType', fromsubclass_=False):
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespace_, name_='Attribute')
    def hasContent_(self):
        if (
            self.Attribute
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attribute_PoolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attribute=[\n')
        level += 1
        for Attribute_ in self.Attribute:
            showIndent(outfile, level)
            outfile.write('model_.AttributeType(\n')
            Attribute_.exportLiteral(outfile, level, name_='AttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute.append(obj_)
# end class Attribute_PoolType


class AssociatedObjectType(ObjectType):
    """The AssociatedObjectType is a complex type representing the
    characterization of a cyber observable Object associated with a
    given cyber observable Action.The AssociationType attribute
    specifies the kind of association this Object holds for this
    Action."""
    subclass = None
    superclass = ObjectType
    def __init__(self, idref=None, Type=None, id=None, Object_State=None, Description=None, Defined_Object=None, Domain_specific_Object_Attributes=None, Custom_Attributes=None, Related_Objects=None, Defined_Effect=None, Discovery_Method=None, AssociationType=None, Action_Pertinent_Object_Attributes=None):
        super(AssociatedObjectType, self).__init__(idref, Type, id, Object_State, Description, Defined_Object, Domain_specific_Object_Attributes, Custom_Attributes, Related_Objects, Defined_Effect, Discovery_Method, )
        self.AssociationType = _cast(None, AssociationType)
        self.Action_Pertinent_Object_Attributes = Action_Pertinent_Object_Attributes
    def factory(*args_, **kwargs_):
        if AssociatedObjectType.subclass:
            return AssociatedObjectType.subclass(*args_, **kwargs_)
        else:
            return AssociatedObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Pertinent_Object_Attributes(self): return self.Action_Pertinent_Object_Attributes
    def set_Action_Pertinent_Object_Attributes(self, Action_Pertinent_Object_Attributes): self.Action_Pertinent_Object_Attributes = Action_Pertinent_Object_Attributes
    def get_AssociationType(self): return self.AssociationType
    def set_AssociationType(self, AssociationType): self.AssociationType = AssociationType
    def export(self, outfile, level, namespace_='cybox:', name_='AssociatedObjectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedObjectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='AssociatedObjectType'):
        super(AssociatedObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedObjectType')
        if self.AssociationType is not None and 'AssociationType' not in already_processed:
            already_processed.append('AssociationType')
            outfile.write(' AssociationType=%s' % (quote_attrib(self.AssociationType), ))
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='AssociatedObjectType', fromsubclass_=False):
        super(AssociatedObjectType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Action_Pertinent_Object_Attributes is not None:
            self.Action_Pertinent_Object_Attributes.export(outfile, level, namespace_, name_='Action-Pertinent_Object_Attributes')
    def hasContent_(self):
        if (
            self.Action_Pertinent_Object_Attributes is not None or
            super(AssociatedObjectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssociatedObjectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AssociationType is not None and 'AssociationType' not in already_processed:
            already_processed.append('AssociationType')
            showIndent(outfile, level)
            outfile.write('AssociationType = %s,\n' % (self.AssociationType,))
        super(AssociatedObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssociatedObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Action_Pertinent_Object_Attributes is not None:
            showIndent(outfile, level)
            outfile.write('Action_Pertinent_Object_Attributes=model_.Action_Pertinent_Object_AttributesType(\n')
            self.Action_Pertinent_Object_Attributes.exportLiteral(outfile, level, name_='Action_Pertinent_Object_Attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AssociationType', node)
        if value is not None and 'AssociationType' not in already_processed:
            already_processed.append('AssociationType')
            self.AssociationType = value
        super(AssociatedObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action-Pertinent_Object_Attributes':
            obj_ = Action_Pertinent_Object_AttributesType.factory()
            obj_.build(child_)
            self.set_Action_Pertinent_Object_Attributes(obj_)
        super(AssociatedObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class AssociatedObjectType


class Observables(ObservablesType):
    """The Observables element represents a collection of cyber
    observables."""
    subclass = None
    superclass = ObservablesType
    def __init__(self, major_version=None, minor_version=None, Observable_Package_Source=None, Observable=None, Pools=None):
        super(Observables, self).__init__(major_version, minor_version, Observable_Package_Source, Observable, Pools, )
        pass
    def factory(*args_, **kwargs_):
        if Observables.subclass:
            return Observables.subclass(*args_, **kwargs_)
        else:
            return Observables(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='cybox:', name_='Observables', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Observables')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='cybox:', name_='Observables'):
        super(Observables, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Observables')
    def exportChildren(self, outfile, level, namespace_='cybox:', name_='Observables', fromsubclass_=False):
        super(Observables, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(Observables, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Observables'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Observables, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Observables, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Observables, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Observables, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Observables


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Observables'
        rootClass = Observables
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    #rootObj.export(sys.stdout, 0, name_=rootTag, 
     #   namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Observables'
        rootClass = Observables
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Observables",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Observables'
        rootClass = Observables
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from CybOX_v1.0 import *\n\n')
    sys.stdout.write('import CybOX_v1.0 as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ActionReferenceType",
    "ActionRelationshipType",
    "ActionType",
    "Action_Aliases",
    "Action_Argument",
    "Action_Arguments",
    "Action_Name",
    "Action_Pertinent_Object_AttributesType",
    "Action_PoolType",
    "Actions",
    "AssociatedObjectType",
    "Associated_Objects",
    "Attribute",
    "AttributeType",
    "Attribute_PoolType",
    "Custom_Attributes",
    "DataReadEffectType",
    "DataReceivedEffectType",
    "DataSentEffectType",
    "DataWrittenEffectType",
    "DefinedEffectType",
    "Delta",
    "Domain_specificObjectAttributesType",
    "Ease_of_Obfuscation",
    "EventType",
    "Event_PoolType",
    "Frequency",
    "New_State",
    "Noisiness",
    "Obfuscation_Technique",
    "Obfuscation_Techniques",
    "ObjectType",
    "Object_PoolType",
    "ObservableType",
    "Observable_CompositionType",
    "Observables",
    "ObservablesType",
    "Old_State",
    "PoolsType",
    "Properties",
    "PropertiesEnumeratedEffectType",
    "PropertyReadEffectType",
    "RelatedObjectType",
    "Related_Objects",
    "Relationships",
    "SendControlCodeEffectType",
    "StateChangeEffectType",
    "StatefulMeasureType",
    "Trend",
    "Values",
    "ValuesEnumeratedEffectType"
    ]
